diff -NurpP --minimal linux-2.6.5/arch/alpha/Kconfig linux-2.6.5-vs1.9.0pre2/arch/alpha/Kconfig
--- linux-2.6.5/arch/alpha/Kconfig	2004-04-04 18:02:53.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/alpha/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -692,6 +692,8 @@ config DEBUG_INFO
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/alpha/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/alpha/kernel/ptrace.c
--- linux-2.6.5/arch/alpha/kernel/ptrace.c	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/alpha/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -287,6 +287,8 @@ do_sys_ptrace(long request, long pid, lo
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out_notsk;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out;
 
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
diff -NurpP --minimal linux-2.6.5/arch/alpha/kernel/systbls.S linux-2.6.5-vs1.9.0pre2/arch/alpha/kernel/systbls.S
--- linux-2.6.5/arch/alpha/kernel/systbls.S	2004-03-11 03:55:35.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/alpha/kernel/systbls.S	2004-04-05 00:55:13.000000000 +0200
@@ -291,7 +291,7 @@ sys_call_table:
 	.quad alpha_ni_syscall			/* 270 */
 	.quad alpha_ni_syscall
 	.quad alpha_ni_syscall
-	.quad alpha_ni_syscall
+	.quad sys_vserver			/* 273 sys_vserver */
 	.quad alpha_ni_syscall
 	.quad alpha_ni_syscall			/* 275 */
 	.quad alpha_ni_syscall
diff -NurpP --minimal linux-2.6.5/arch/arm/Kconfig linux-2.6.5-vs1.9.0pre2/arch/arm/Kconfig
--- linux-2.6.5/arch/arm/Kconfig	2004-04-04 18:02:54.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/arm/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -738,6 +738,8 @@ config DEBUG_CLPS711X_UART2
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/arm/kernel/ecard.c linux-2.6.5-vs1.9.0pre2/arch/arm/kernel/ecard.c
--- linux-2.6.5/arch/arm/kernel/ecard.c	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/arm/kernel/ecard.c	2004-04-05 00:55:16.000000000 +0200
@@ -266,7 +266,7 @@ static void ecard_init_pgtables(struct m
 
 static int ecard_init_mm(void)
 {
-	struct mm_struct * mm = mm_alloc();
+	struct mm_struct * mm = mm_alloc(current->vx_info);
 	struct mm_struct *active_mm = current->active_mm;
 
 	if (!mm)
diff -NurpP --minimal linux-2.6.5/arch/arm/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/arm/kernel/ptrace.c
--- linux-2.6.5/arch/arm/kernel/ptrace.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/arm/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -754,6 +754,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/arm26/Kconfig linux-2.6.5-vs1.9.0pre2/arch/arm26/Kconfig
--- linux-2.6.5/arch/arm26/Kconfig	2004-04-04 18:02:54.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/arm26/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -327,6 +327,8 @@ config DEBUG_LL
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/arm26/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/arm26/kernel/ptrace.c
--- linux-2.6.5/arch/arm26/kernel/ptrace.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/arm26/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -691,6 +691,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/cris/Kconfig linux-2.6.5-vs1.9.0pre2/arch/cris/Kconfig
--- linux-2.6.5/arch/cris/Kconfig	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/cris/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -214,6 +214,8 @@ config PROFILE_SHIFT
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/h8300/Kconfig linux-2.6.5-vs1.9.0pre2/arch/h8300/Kconfig
--- linux-2.6.5/arch/h8300/Kconfig	2004-04-04 18:02:54.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/h8300/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -432,6 +432,8 @@ config CONFIG_BLKDEV_RESERVE_ADDRESS
 	  BLKDEV start address.
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/h8300/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/h8300/kernel/ptrace.c
--- linux-2.6.5/arch/h8300/kernel/ptrace.c	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/h8300/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -257,6 +257,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/i386/Kconfig linux-2.6.5-vs1.9.0pre2/arch/i386/Kconfig
--- linux-2.6.5/arch/i386/Kconfig	2004-04-04 18:02:54.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/i386/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -1302,6 +1302,8 @@ config X86_MPPARSE
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/i386/kernel/entry.S linux-2.6.5-vs1.9.0pre2/arch/i386/kernel/entry.S
--- linux-2.6.5/arch/i386/kernel/entry.S	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/i386/kernel/entry.S	2004-04-05 00:55:13.000000000 +0200
@@ -881,6 +881,6 @@ ENTRY(sys_call_table)
 	.long sys_tgkill	/* 270 */
 	.long sys_utimes
  	.long sys_fadvise64_64
-	.long sys_ni_syscall	/* sys_vserver */
+	.long sys_vserver
 
 syscall_table_size=(.-sys_call_table)
diff -NurpP --minimal linux-2.6.5/arch/i386/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/i386/kernel/ptrace.c
--- linux-2.6.5/arch/i386/kernel/ptrace.c	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/i386/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -257,6 +257,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/i386/kernel/sys_i386.c linux-2.6.5-vs1.9.0pre2/arch/i386/kernel/sys_i386.c
--- linux-2.6.5/arch/i386/kernel/sys_i386.c	2004-03-11 03:55:50.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/i386/kernel/sys_i386.c	2004-04-05 00:55:13.000000000 +0200
@@ -217,7 +217,7 @@ asmlinkage int sys_uname(struct old_utsn
 	if (!name)
 		return -EFAULT;
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	err=copy_to_user(name, &vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	return err?-EFAULT:0;
 }
@@ -225,6 +225,7 @@ asmlinkage int sys_uname(struct old_utsn
 asmlinkage int sys_olduname(struct oldold_utsname __user * name)
 {
 	int error;
+	struct new_utsname *ptr;
 
 	if (!name)
 		return -EFAULT;
@@ -233,15 +234,16 @@ asmlinkage int sys_olduname(struct oldol
   
   	down_read(&uts_sem);
 	
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,__OLD_UTS_LEN);
+	ptr = &vx_new_utsname();
+	error = __copy_to_user(&name->sysname,ptr->sysname,__OLD_UTS_LEN);
 	error |= __put_user(0,name->sysname+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->nodename,&system_utsname.nodename,__OLD_UTS_LEN);
+	error |= __copy_to_user(&name->nodename,ptr->nodename,__OLD_UTS_LEN);
 	error |= __put_user(0,name->nodename+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->release,&system_utsname.release,__OLD_UTS_LEN);
+	error |= __copy_to_user(&name->release,ptr->release,__OLD_UTS_LEN);
 	error |= __put_user(0,name->release+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->version,&system_utsname.version,__OLD_UTS_LEN);
+	error |= __copy_to_user(&name->version,ptr->version,__OLD_UTS_LEN);
 	error |= __put_user(0,name->version+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->machine,&system_utsname.machine,__OLD_UTS_LEN);
+	error |= __copy_to_user(&name->machine,ptr->machine,__OLD_UTS_LEN);
 	error |= __put_user(0,name->machine+__OLD_UTS_LEN);
 	
 	up_read(&uts_sem);
diff -NurpP --minimal linux-2.6.5/arch/i386/mm/hugetlbpage.c linux-2.6.5-vs1.9.0pre2/arch/i386/mm/hugetlbpage.c
--- linux-2.6.5/arch/i386/mm/hugetlbpage.c	2004-04-04 18:02:54.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/i386/mm/hugetlbpage.c	2004-04-05 00:55:16.000000000 +0200
@@ -105,7 +105,8 @@ static void set_huge_pte(struct mm_struc
 {
 	pte_t entry;
 
-	mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	// mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	vx_rsspages_add(mm, HPAGE_SIZE / PAGE_SIZE);
 	if (write_access) {
 		entry =
 		    pte_mkwrite(pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
@@ -145,7 +146,8 @@ int copy_hugetlb_page_range(struct mm_st
 		ptepage = pte_page(entry);
 		get_page(ptepage);
 		set_pte(dst_pte, entry);
-		dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		// dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		vx_rsspages_add(dst, HPAGE_SIZE / PAGE_SIZE);
 		addr += HPAGE_SIZE;
 	}
 	return 0;
@@ -315,7 +317,8 @@ void unmap_hugepage_range(struct vm_area
 		huge_page_release(page);
 		pte_clear(pte);
 	}
-	mm->rss -= (end - start) >> PAGE_SHIFT;
+	// mm->rss -= (end - start) >> PAGE_SHIFT;
+	vx_rsspages_sub(mm, (end - start) >> PAGE_SHIFT);
 	flush_tlb_range(vma, start, end);
 }
 
diff -NurpP --minimal linux-2.6.5/arch/ia64/Kconfig linux-2.6.5-vs1.9.0pre2/arch/ia64/Kconfig
--- linux-2.6.5/arch/ia64/Kconfig	2004-04-04 18:02:54.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ia64/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -499,6 +499,8 @@ config SYSVIPC_COMPAT
 	default y
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/ia64/ia32/binfmt_elf32.c linux-2.6.5-vs1.9.0pre2/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.5/arch/ia64/ia32/binfmt_elf32.c	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/ia64/ia32/binfmt_elf32.c	2004-04-05 00:55:16.000000000 +0200
@@ -185,7 +185,9 @@ ia32_setup_arg_pages (struct linux_binpr
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = 0;
 		insert_vm_struct(current->mm, mpnt);
-		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		// current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(current->mm, current->mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.6.5/arch/ia64/kernel/perfmon.c linux-2.6.5-vs1.9.0pre2/arch/ia64/kernel/perfmon.c
--- linux-2.6.5/arch/ia64/kernel/perfmon.c	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/ia64/kernel/perfmon.c	2004-04-05 00:55:16.000000000 +0200
@@ -2315,7 +2315,8 @@ pfm_smpl_buffer_alloc(struct task_struct
 	 */
 	insert_vm_struct(mm, vma);
 
-	mm->total_vm  += size >> PAGE_SHIFT;
+	// mm->total_vm  += size >> PAGE_SHIFT;
+	vx_vmpages_add(mm, size >> PAGE_SHIFT);
 
 	up_write(&task->mm->mmap_sem);
 
diff -NurpP --minimal linux-2.6.5/arch/ia64/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/ia64/kernel/ptrace.c
--- linux-2.6.5/arch/ia64/kernel/ptrace.c	2004-03-11 03:55:51.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/ia64/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -1310,6 +1310,9 @@ sys_ptrace (long request, pid_t pid, uns
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
+
 	ret = -EPERM;
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
diff -NurpP --minimal linux-2.6.5/arch/ia64/mm/fault.c linux-2.6.5-vs1.9.0pre2/arch/ia64/mm/fault.c
--- linux-2.6.5/arch/ia64/mm/fault.c	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ia64/mm/fault.c	2004-04-05 00:55:16.000000000 +0200
@@ -36,10 +36,14 @@ expand_backing_store (struct vm_area_str
 	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur
 	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur))
 		return -ENOMEM;
+	if (!vx_vmpages_avail(vma->vm_mm, grow)
+		return -ENOMEM;
 	vma->vm_end += PAGE_SIZE;
-	vma->vm_mm->total_vm += grow;
+	// vma->vm_mm->total_vm += grow;
+	vx_vmpages_add(vma->vm_mm, grow);
 	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
+		// vma->vm_mm->locked_vm += grow;
+		vx_vmlocked_add(vma->vm_mm, grow);
 	return 0;
 }
 
diff -NurpP --minimal linux-2.6.5/arch/ia64/mm/hugetlbpage.c linux-2.6.5-vs1.9.0pre2/arch/ia64/mm/hugetlbpage.c
--- linux-2.6.5/arch/ia64/mm/hugetlbpage.c	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ia64/mm/hugetlbpage.c	2004-04-05 00:55:16.000000000 +0200
@@ -122,7 +122,8 @@ set_huge_pte (struct mm_struct *mm, stru
 {
 	pte_t entry;
 
-	mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	// mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	vx_rsspages_add(mm, HPAGE_SIZE / PAGE_SIZE);
 	if (write_access) {
 		entry =
 		    pte_mkwrite(pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
@@ -165,7 +166,8 @@ int copy_hugetlb_page_range(struct mm_st
 		ptepage = pte_page(entry);
 		get_page(ptepage);
 		set_pte(dst_pte, entry);
-		dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		// dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		vx_rsspages_add(dst, HPAGE_SIZE / PAGE_SIZE);
 		addr += HPAGE_SIZE;
 	}
 	return 0;
@@ -335,7 +337,8 @@ void unmap_hugepage_range(struct vm_area
 		huge_page_release(page);
 		pte_clear(pte);
 	}
-	mm->rss -= (end - start) >> PAGE_SHIFT;
+	// mm->rss -= (end - start) >> PAGE_SHIFT;
+	vx_rsspages_sub(mm, (end - start) >> PAGE_SHIFT);
 	flush_tlb_range(vma, start, end);
 }
 
diff -NurpP --minimal linux-2.6.5/arch/m68k/Kconfig linux-2.6.5-vs1.9.0pre2/arch/m68k/Kconfig
--- linux-2.6.5/arch/m68k/Kconfig	2004-03-11 03:55:33.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/m68k/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -690,6 +690,8 @@ config DEBUG_INFO
 	  
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/m68k/atari/stram.c linux-2.6.5-vs1.9.0pre2/arch/m68k/atari/stram.c
--- linux-2.6.5/arch/m68k/atari/stram.c	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/m68k/atari/stram.c	2004-04-05 00:55:16.000000000 +0200
@@ -635,7 +635,8 @@ static inline void unswap_pte(struct vm_
 	set_pte(dir, pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
 	swap_free(entry);
 	get_page(page);
-	++vma->vm_mm->rss;
+	// ++vma->vm_mm->rss;
+	vx_rsspages_inc(vma->vm_mm);
 }
 
 static inline void unswap_pmd(struct vm_area_struct * vma, pmd_t *dir,
diff -NurpP --minimal linux-2.6.5/arch/m68k/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/m68k/kernel/ptrace.c
--- linux-2.6.5/arch/m68k/kernel/ptrace.c	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/m68k/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -126,6 +126,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/m68knommu/Kconfig linux-2.6.5-vs1.9.0pre2/arch/m68knommu/Kconfig
--- linux-2.6.5/arch/m68knommu/Kconfig	2004-03-11 03:55:36.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/m68knommu/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -582,6 +582,8 @@ config BDM_DISABLE
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/m68knommu/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/m68knommu/kernel/ptrace.c
--- linux-2.6.5/arch/m68knommu/kernel/ptrace.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/m68knommu/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -124,6 +124,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/mips/Kconfig linux-2.6.5-vs1.9.0pre2/arch/mips/Kconfig
--- linux-2.6.5/arch/mips/Kconfig	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/mips/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -1533,6 +1533,8 @@ config DEBUG_HIGHMEM
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/mips/kernel/irixelf.c linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/irixelf.c
--- linux-2.6.5/arch/mips/kernel/irixelf.c	2004-03-11 03:56:03.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/irixelf.c	2004-04-05 00:55:16.000000000 +0200
@@ -687,7 +687,8 @@ static int load_irix_binary(struct linux
 	/* Do this so that we can load the interpreter, if need be.  We will
 	 * change some of these later.
 	 */
-	current->mm->rss = 0;
+	// current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	setup_arg_pages(bprm);
 	current->mm->start_stack = bprm->p;
 
diff -NurpP --minimal linux-2.6.5/arch/mips/kernel/linux32.c linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/linux32.c
--- linux-2.6.5/arch/mips/kernel/linux32.c	2004-03-11 03:55:34.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/linux32.c	2004-04-05 00:55:17.000000000 +0200
@@ -297,7 +297,7 @@ do_execve32(char * filename, u32 * argv,
 	bprm.loader = 0;
 	bprm.exec = 0;
 	bprm.security = NULL;
-	bprm.mm = mm_alloc();
+	bprm.mm = mm_alloc(current->vx_info);
 	retval = -ENOMEM;
 	if (!bprm.mm) 
 		goto out_file;
@@ -1715,7 +1715,7 @@ asmlinkage long sys32_newuname(struct ne
 	int ret = 0;
 
 	down_read(&uts_sem);
-	if (copy_to_user(name,&system_utsname,sizeof *name))
+	if (copy_to_user(name, i&vx_new_utsname(), sizeof *name))
 		ret = -EFAULT;
 	up_read(&uts_sem);
 
diff -NurpP --minimal linux-2.6.5/arch/mips/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/ptrace.c
--- linux-2.6.5/arch/mips/kernel/ptrace.c	2004-03-11 03:55:54.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -76,6 +76,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/mips/kernel/syscall.c linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/syscall.c
--- linux-2.6.5/arch/mips/kernel/syscall.c	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/mips/kernel/syscall.c	2004-04-05 00:55:13.000000000 +0200
@@ -202,7 +202,7 @@ out:
  */
 asmlinkage int sys_uname(struct old_utsname * name)
 {
-	if (name && !copy_to_user(name, &system_utsname, sizeof (*name)))
+	if (name && !copy_to_user(name, &vx_new_utsname(), sizeof (*name)))
 		return 0;
 	return -EFAULT;
 }
@@ -213,21 +213,23 @@ asmlinkage int sys_uname(struct old_utsn
 asmlinkage int sys_olduname(struct oldold_utsname * name)
 {
 	int error;
+	struct new_utsname *ptr;
 
 	if (!name)
 		return -EFAULT;
 	if (!access_ok(VERIFY_WRITE,name,sizeof(struct oldold_utsname)))
 		return -EFAULT;
 
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,__OLD_UTS_LEN);
+	ptr = &vx_new_utsname();
+	error = __copy_to_user(&name->sysname,ptr->sysname,__OLD_UTS_LEN);
 	error -= __put_user(0,name->sysname+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->nodename,&system_utsname.nodename,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->nodename,ptr->nodename,__OLD_UTS_LEN);
 	error -= __put_user(0,name->nodename+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->release,&system_utsname.release,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->release,ptr->release,__OLD_UTS_LEN);
 	error -= __put_user(0,name->release+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->version,&system_utsname.version,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->version,ptr->version,__OLD_UTS_LEN);
 	error -= __put_user(0,name->version+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->machine,&system_utsname.machine,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->machine,ptr->machine,__OLD_UTS_LEN);
 	error = __put_user(0,name->machine+__OLD_UTS_LEN);
 	error = error ? -EFAULT : 0;
 
@@ -253,10 +255,10 @@ asmlinkage int _sys_sysmips(int cmd, lon
 			return -EFAULT;
 
 		down_write(&uts_sem);
-		strncpy(system_utsname.nodename, nodename, len);
+		strncpy(vx_new_uts(nodename), nodename, len);
 		nodename[__NEW_UTS_LEN] = '\0';
-		strlcpy(system_utsname.nodename, nodename,
-		        sizeof(system_utsname.nodename));
+		strlcpy(vx_new_uts(nodename), nodename,
+		        sizeof(vx_new_uts(nodename)));
 		up_write(&uts_sem);
 		return 0;
 	}
diff -NurpP --minimal linux-2.6.5/arch/parisc/Kconfig linux-2.6.5-vs1.9.0pre2/arch/parisc/Kconfig
--- linux-2.6.5/arch/parisc/Kconfig	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/parisc/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -224,6 +224,8 @@ config DEBUG_INFO
 	  
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/parisc/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/parisc/kernel/ptrace.c
--- linux-2.6.5/arch/parisc/kernel/ptrace.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/parisc/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -110,6 +110,9 @@ long sys_ptrace(long request, pid_t pid,
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
+
 	ret = -EPERM;
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
diff -NurpP --minimal linux-2.6.5/arch/parisc/kernel/sys_parisc32.c linux-2.6.5-vs1.9.0pre2/arch/parisc/kernel/sys_parisc32.c
--- linux-2.6.5/arch/parisc/kernel/sys_parisc32.c	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/parisc/kernel/sys_parisc32.c	2004-04-05 00:55:18.000000000 +0200
@@ -190,7 +190,7 @@ do_execve32(char * filename, u32 * argv,
 	bprm.loader = 0;
 	bprm.exec = 0;
 
-	bprm.mm = mm_alloc();
+	bprm.mm = mm_alloc(current->vx_info);
 	retval = -ENOMEM;
 	if (!bprm.mm)
 		goto out_file;
@@ -1209,6 +1209,7 @@ asmlinkage int sys32_sysinfo(struct sysi
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
+		/* requires vx virtualization */
 		val.uptime = jiffies / HZ;
 
 		val.loads[0] = avenrun[0] << (SI_LOAD_SHIFT - FSHIFT);
diff -NurpP --minimal linux-2.6.5/arch/ppc/Kconfig linux-2.6.5-vs1.9.0pre2/arch/ppc/Kconfig
--- linux-2.6.5/arch/ppc/Kconfig	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -1227,6 +1227,8 @@ config OCP
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/ppc/kernel/misc.S linux-2.6.5-vs1.9.0pre2/arch/ppc/kernel/misc.S
--- linux-2.6.5/arch/ppc/kernel/misc.S	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc/kernel/misc.S	2004-04-05 00:55:13.000000000 +0200
@@ -1370,3 +1370,22 @@ _GLOBAL(sys_call_table)
 	.long sys_fstatfs64
 	.long ppc_fadvise64_64
 	.long sys_ni_syscall	/* 255 - rtas (used on ppc64) */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 260 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 265 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 270 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_vserver	/* 273 sys_vserver */
+
diff -NurpP --minimal linux-2.6.5/arch/ppc/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/ppc/kernel/ptrace.c
--- linux-2.6.5/arch/ppc/kernel/ptrace.c	2004-04-04 18:02:55.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -197,6 +197,8 @@ int sys_ptrace(long request, long pid, l
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/ppc/kernel/syscalls.c linux-2.6.5-vs1.9.0pre2/arch/ppc/kernel/syscalls.c
--- linux-2.6.5/arch/ppc/kernel/syscalls.c	2004-03-11 03:55:45.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc/kernel/syscalls.c	2004-04-05 00:55:13.000000000 +0200
@@ -229,7 +229,7 @@ int sys_uname(struct old_utsname __user 
 	int err = -EFAULT;
 
 	down_read(&uts_sem);
-	if (name && !copy_to_user(name, &system_utsname, sizeof (*name)))
+	if (name && !copy_to_user(name, &vx_new_utsname(), sizeof (*name)))
 		err = 0;
 	up_read(&uts_sem);
 	return err;
@@ -238,6 +238,7 @@ int sys_uname(struct old_utsname __user 
 int sys_olduname(struct oldold_utsname __user * name)
 {
 	int error;
+	struct new_utsname *ptr;
 
 	if (!name)
 		return -EFAULT;
@@ -245,15 +246,16 @@ int sys_olduname(struct oldold_utsname _
 		return -EFAULT;
 
 	down_read(&uts_sem);
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,__OLD_UTS_LEN);
+	ptr = &vx_new_utsname();
+	error = __copy_to_user(&name->sysname,ptr->sysname,__OLD_UTS_LEN);
 	error -= __put_user(0,name->sysname+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->nodename,&system_utsname.nodename,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->nodename,ptr->nodename,__OLD_UTS_LEN);
 	error -= __put_user(0,name->nodename+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->release,&system_utsname.release,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->release,ptr->release,__OLD_UTS_LEN);
 	error -= __put_user(0,name->release+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->version,&system_utsname.version,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->version,ptr->version,__OLD_UTS_LEN);
 	error -= __put_user(0,name->version+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->machine,&system_utsname.machine,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->machine,ptr->machine,__OLD_UTS_LEN);
 	error = __put_user(0,name->machine+__OLD_UTS_LEN);
 	up_read(&uts_sem);
 
diff -NurpP --minimal linux-2.6.5/arch/ppc64/Kconfig linux-2.6.5-vs1.9.0pre2/arch/ppc64/Kconfig
--- linux-2.6.5/arch/ppc64/Kconfig	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc64/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -389,6 +389,8 @@ config DEBUG_INFO
 	  
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/ppc64/kernel/misc.S linux-2.6.5-vs1.9.0pre2/arch/ppc64/kernel/misc.S
--- linux-2.6.5/arch/ppc64/kernel/misc.S	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc64/kernel/misc.S	2004-04-05 00:55:13.000000000 +0200
@@ -828,6 +828,24 @@ _GLOBAL(sys_call_table32)
 	.llong .compat_fstatfs64
 	.llong .ppc32_fadvise64_64	/* 32bit only fadvise64_64 */
 	.llong .ppc_rtas		/* 255 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 260 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 265 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 270 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_vserver		/* 273 sys_vserver */
 
 	.balign 8
 _GLOBAL(sys_call_table)
@@ -1087,3 +1105,22 @@ _GLOBAL(sys_call_table)
 	.llong .sys_fstatfs64
 	.llong .sys_ni_syscall		/* 32bit only fadvise64_64 */
 	.llong .ppc_rtas		/* 255 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 260 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 265 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 270 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_vserver		/* 273 sys_vserver */
+
diff -NurpP --minimal linux-2.6.5/arch/ppc64/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/ppc64/kernel/ptrace.c
--- linux-2.6.5/arch/ppc64/kernel/ptrace.c	2004-03-11 03:55:43.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc64/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -75,6 +75,8 @@ int sys_ptrace(long request, long pid, l
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/ppc64/kernel/sys_ppc32.c linux-2.6.5-vs1.9.0pre2/arch/ppc64/kernel/sys_ppc32.c
--- linux-2.6.5/arch/ppc64/kernel/sys_ppc32.c	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc64/kernel/sys_ppc32.c	2004-04-05 00:55:18.000000000 +0200
@@ -1838,7 +1838,7 @@ static int do_execve32(char * filename, 
 	bprm.loader = 0;
 	bprm.exec = 0;
 	bprm.security = NULL;
-	bprm.mm = mm_alloc();
+	bprm.mm = mm_alloc(current->vx_info);
 	retval = -ENOMEM;
 	if (!bprm.mm)
 		goto out_file;
@@ -2456,6 +2456,7 @@ asmlinkage long sys32_time(compat_time_t
 int sys32_olduname(struct oldold_utsname * name)
 {
 	int error;
+	struct new_utsname *ptr;
 	
 	if (!name)
 		return -EFAULT;
@@ -2463,15 +2464,16 @@ int sys32_olduname(struct oldold_utsname
 		return -EFAULT;
   
 	down_read(&uts_sem);
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,__OLD_UTS_LEN);
+	ptr = &vx_new_utsname();
+	error = __copy_to_user(&name->sysname,ptr->sysname,__OLD_UTS_LEN);
 	error -= __put_user(0,name->sysname+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->nodename,&system_utsname.nodename,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->nodename,ptr->nodename,__OLD_UTS_LEN);
 	error -= __put_user(0,name->nodename+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->release,&system_utsname.release,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->release,ptr->release,__OLD_UTS_LEN);
 	error -= __put_user(0,name->release+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->version,&system_utsname.version,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->version,ptr->version,__OLD_UTS_LEN);
 	error -= __put_user(0,name->version+__OLD_UTS_LEN);
-	error -= __copy_to_user(&name->machine,&system_utsname.machine,__OLD_UTS_LEN);
+	error -= __copy_to_user(&name->machine,ptr->machine,__OLD_UTS_LEN);
 	error = __put_user(0,name->machine+__OLD_UTS_LEN);
 	up_read(&uts_sem);
 
diff -NurpP --minimal linux-2.6.5/arch/ppc64/mm/hugetlbpage.c linux-2.6.5-vs1.9.0pre2/arch/ppc64/mm/hugetlbpage.c
--- linux-2.6.5/arch/ppc64/mm/hugetlbpage.c	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/ppc64/mm/hugetlbpage.c	2004-04-05 00:55:18.000000000 +0200
@@ -207,7 +207,8 @@ static void setup_huge_pte(struct mm_str
 	hugepte_t entry;
 	int i;
 
-	mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	// mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	vx_rsspages_sub(mm, HPAGE_SIZE / PAGE_SIZE);
 	entry = mk_hugepte(page, write_access);
 	for (i = 0; i < HUGEPTE_BATCH_SIZE; i++)
 		set_hugepte(ptep+i, entry);
@@ -331,7 +332,8 @@ int copy_hugetlb_page_range(struct mm_st
 			/* This is the first hugepte in a batch */
 			ptepage = hugepte_page(entry);
 			get_page(ptepage);
-			dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+			// dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+			vx_rsspages_add(dst, HPAGE_SIZE / PAGE_SIZE);
 		}
 		set_hugepte(dst_pte, entry);
 
@@ -480,7 +482,8 @@ void unmap_hugepage_range(struct vm_area
 		huge_page_release(page);
 	}
 
-	mm->rss -= (end - start) >> PAGE_SHIFT;
+	// mm->rss -= (end - start) >> PAGE_SHIFT;
+	vx_rsspages_sub(mm, (end - start) >> PAGE_SHIFT);
 }
 
 void zap_hugepage_range(struct vm_area_struct *vma,
diff -NurpP --minimal linux-2.6.5/arch/s390/Kconfig linux-2.6.5-vs1.9.0pre2/arch/s390/Kconfig
--- linux-2.6.5/arch/s390/Kconfig	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/s390/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -405,6 +405,8 @@ config DEBUG_SPINLOCK_SLEEP
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/s390/kernel/compat_exec.c linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/compat_exec.c
--- linux-2.6.5/arch/s390/kernel/compat_exec.c	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/compat_exec.c	2004-04-05 00:55:18.000000000 +0200
@@ -74,7 +74,9 @@ int setup_arg_pages32(struct linux_binpr
 		INIT_LIST_HEAD(&mpnt->shared);
 		mpnt->vm_private_data = (void *) 0;
 		insert_vm_struct(mm, mpnt);
-		mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		// mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(mm, mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	} 
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.6.5/arch/s390/kernel/compat_linux.c linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/compat_linux.c
--- linux-2.6.5/arch/s390/kernel/compat_linux.c	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/compat_linux.c	2004-04-05 00:55:18.000000000 +0200
@@ -1159,7 +1159,7 @@ do_execve32(char * filename, u32 * argv,
 	bprm.sh_bang = 0;
 	bprm.loader = 0;
 	bprm.exec = 0;
-	bprm.mm = mm_alloc();
+	bprm.mm = mm_alloc(current->vx_info);
 	retval = -ENOMEM;
 	if (!bprm.mm)
 		goto out_file;
diff -NurpP --minimal linux-2.6.5/arch/s390/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/ptrace.c
--- linux-2.6.5/arch/s390/kernel/ptrace.c	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -680,9 +680,11 @@ sys_ptrace(long request, long pid, long 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = do_ptrace(child, request, addr, data);
-
+out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
diff -NurpP --minimal linux-2.6.5/arch/s390/kernel/syscalls.S linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/syscalls.S
--- linux-2.6.5/arch/s390/kernel/syscalls.S	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/s390/kernel/syscalls.S	2004-04-05 00:55:13.000000000 +0200
@@ -271,7 +271,7 @@ SYSCALL(sys_clock_settime,sys_clock_sett
 SYSCALL(sys_clock_gettime,sys_clock_gettime,sys32_clock_gettime_wrapper)	/* 260 */
 SYSCALL(sys_clock_getres,sys_clock_getres,sys32_clock_getres_wrapper)
 SYSCALL(sys_clock_nanosleep,sys_clock_nanosleep,sys32_clock_nanosleep_wrapper)
-NI_SYSCALL							/* reserved for vserver */
+SYSCALL(sys_vserver,sys_vserver,sys_vserver)
 SYSCALL(s390_fadvise64_64,sys_ni_syscall,sys32_fadvise64_64_wrapper)
 SYSCALL(sys_statfs64,sys_statfs64,compat_sys_statfs64_wrapper)
 SYSCALL(sys_fstatfs64,sys_fstatfs64,compat_sys_fstatfs64_wrapper)
diff -NurpP --minimal linux-2.6.5/arch/sh/Kconfig linux-2.6.5-vs1.9.0pre2/arch/sh/Kconfig
--- linux-2.6.5/arch/sh/Kconfig	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sh/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -792,6 +792,8 @@ config FRAME_POINTER
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/sh/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/sh/kernel/ptrace.c
--- linux-2.6.5/arch/sh/kernel/ptrace.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sh/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -108,6 +108,8 @@ asmlinkage int sys_ptrace(long request, 
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/sh/mm/hugetlbpage.c linux-2.6.5-vs1.9.0pre2/arch/sh/mm/hugetlbpage.c
--- linux-2.6.5/arch/sh/mm/hugetlbpage.c	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sh/mm/hugetlbpage.c	2004-04-05 00:55:18.000000000 +0200
@@ -123,7 +123,8 @@ static void set_huge_pte(struct mm_struc
 	unsigned long i;
 	pte_t entry;
 
-	mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	// mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	vx_rsspages_add(mm, HPAGE_SIZE / PAGE_SIZE);
 
 	if (write_access)
 		entry = pte_mkwrite(pte_mkdirty(mk_pte(page,
@@ -176,7 +177,8 @@ int copy_hugetlb_page_range(struct mm_st
 			pte_val(entry) += PAGE_SIZE;
 			dst_pte++;
 		}
-		dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		// dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		vx_rsspages_add(dst, HPAGE_SIZE / PAGE_SIZE);
 		addr += HPAGE_SIZE;
 	}
 	return 0;
@@ -294,7 +296,8 @@ void unmap_hugepage_range(struct vm_area
 			pte++;
 		}
 	}
-	mm->rss -= (end - start) >> PAGE_SHIFT;
+	// mm->rss -= (end - start) >> PAGE_SHIFT;
+	vx_rsspages_sub(mm, (end - start) >> PAGE_SHIFT);
 	flush_tlb_range(vma, start, end);
 }
 
diff -NurpP --minimal linux-2.6.5/arch/sparc/Kconfig linux-2.6.5-vs1.9.0pre2/arch/sparc/Kconfig
--- linux-2.6.5/arch/sparc/Kconfig	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -450,6 +450,8 @@ config DEBUG_BUGVERBOSE
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/sparc/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/sparc/kernel/ptrace.c
--- linux-2.6.5/arch/sparc/kernel/ptrace.c	2004-03-11 03:55:54.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -319,6 +319,10 @@ asmlinkage void do_ptrace(struct pt_regs
 		pt_error_return(regs, ESRCH);
 		goto out;
 	}
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT)) {
+		pt_error_return(regs, ESRCH);
+		goto out_tsk;
+	}
 
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
diff -NurpP --minimal linux-2.6.5/arch/sparc/kernel/sys_sparc.c linux-2.6.5-vs1.9.0pre2/arch/sparc/kernel/sys_sparc.c
--- linux-2.6.5/arch/sparc/kernel/sys_sparc.c	2004-03-11 03:55:25.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc/kernel/sys_sparc.c	2004-04-05 00:55:13.000000000 +0200
@@ -467,13 +467,13 @@ asmlinkage int sys_getdomainname(char __
  	
  	down_read(&uts_sem);
  	
-	nlen = strlen(system_utsname.domainname) + 1;
+	nlen = strlen(vx_new_uts(domainname)) + 1;
 
 	if (nlen < len)
 		len = nlen;
 	if (len > __NEW_UTS_LEN)
 		goto done;
-	if (copy_to_user(name, system_utsname.domainname, len))
+	if (copy_to_user(name, vx_new_uts(domainname), len))
 		goto done;
 	err = 0;
 done:
diff -NurpP --minimal linux-2.6.5/arch/sparc/kernel/systbls.S linux-2.6.5-vs1.9.0pre2/arch/sparc/kernel/systbls.S
--- linux-2.6.5/arch/sparc/kernel/systbls.S	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc/kernel/systbls.S	2004-04-05 00:55:13.000000000 +0200
@@ -72,7 +72,7 @@ sys_call_table:
 /*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 /*255*/	.long sys_nis_syscall, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.long sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-/*265*/	.long sys_timer_delete, sys_timer_create, sys_nis_syscall, sys_io_setup, sys_io_destroy
+/*265*/	.long sys_timer_delete, sys_timer_create, sys_vserver, sys_io_setup, sys_io_destroy
 /*270*/	.long sys_io_submit, sys_io_cancel, sys_io_getevents, sys_nis_syscall
 
 #ifdef CONFIG_SUNOS_EMUL
diff -NurpP --minimal linux-2.6.5/arch/sparc64/Kconfig linux-2.6.5-vs1.9.0pre2/arch/sparc64/Kconfig
--- linux-2.6.5/arch/sparc64/Kconfig	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -702,6 +702,8 @@ config MCOUNT
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/sparc64/kernel/binfmt_aout32.c linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/binfmt_aout32.c
--- linux-2.6.5/arch/sparc64/kernel/binfmt_aout32.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/binfmt_aout32.c	2004-04-05 00:55:18.000000000 +0200
@@ -239,7 +239,8 @@ static int load_aout32_binary(struct lin
 	current->mm->brk = ex.a_bss +
 		(current->mm->start_brk = N_BSSADDR(ex));
 
-	current->mm->rss = 0;
+	// current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
diff -NurpP --minimal linux-2.6.5/arch/sparc64/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/ptrace.c
--- linux-2.6.5/arch/sparc64/kernel/ptrace.c	2004-03-11 03:55:51.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -168,6 +168,10 @@ asmlinkage void do_ptrace(struct pt_regs
 		pt_error_return(regs, ESRCH);
 		goto out;
 	}
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT)) {
+		pt_error_return(regs, ESRCH);
+		goto out_tsk;
+	}
 
 	if ((current->personality == PER_SUNOS && request == PTRACE_SUNATTACH)
 	    || (current->personality != PER_SUNOS && request == PTRACE_ATTACH)) {
diff -NurpP --minimal linux-2.6.5/arch/sparc64/kernel/sys_sparc.c linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/sys_sparc.c
--- linux-2.6.5/arch/sparc64/kernel/sys_sparc.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/sys_sparc.c	2004-04-05 00:55:13.000000000 +0200
@@ -458,13 +458,13 @@ asmlinkage int sys_getdomainname(char __
 
  	down_read(&uts_sem);
  	
-	nlen = strlen(system_utsname.domainname) + 1;
+	nlen = strlen(vx_new_uts(domainname)) + 1;
 
         if (nlen < len)
                 len = nlen;
 	if (len > __NEW_UTS_LEN)
 		goto done;
-	if (copy_to_user(name, system_utsname.domainname, len))
+	if (copy_to_user(name, vx_new_uts(domainname), len))
 		goto done;
 	err = 0;
 done:
diff -NurpP --minimal linux-2.6.5/arch/sparc64/kernel/sys_sparc32.c linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.6.5/arch/sparc64/kernel/sys_sparc32.c	2004-04-04 18:02:56.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/sys_sparc32.c	2004-04-05 00:55:18.000000000 +0200
@@ -1778,7 +1778,7 @@ do_execve32(char * filename, u32 * argv,
 	bprm.loader = 0;
 	bprm.exec = 0;
 	bprm.security = NULL;
-	bprm.mm = mm_alloc();
+	bprm.mm = mm_alloc(current->vx_info);
 	retval = -ENOMEM;
 	if (!bprm.mm) 
 		goto out_file;
diff -NurpP --minimal linux-2.6.5/arch/sparc64/kernel/systbls.S linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/systbls.S
--- linux-2.6.5/arch/sparc64/kernel/systbls.S	2004-04-04 18:02:57.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/kernel/systbls.S	2004-04-05 00:55:13.000000000 +0200
@@ -72,8 +72,8 @@ sys_call_table32:
 /*250*/	.word sys32_mremap, sys32_sysctl, sys_getsid, sys_fdatasync, sys32_nfsservctl
 	.word sys_ni_syscall, compat_clock_settime, compat_clock_gettime, compat_clock_getres, compat_clock_nanosleep
 /*260*/	.word compat_sys_sched_getaffinity, compat_sys_sched_setaffinity, compat_timer_settime, compat_timer_gettime, sys_timer_getoverrun
-	.word sys_timer_delete, sys32_timer_create, sys_ni_syscall, compat_sys_io_setup, sys_io_destroy
-/*270*/	.word compat_sys_io_submit, sys_io_cancel, compat_sys_io_getevents, sys_ni_syscall
+	.word sys_timer_delete, sys32_timer_create, sys_vserver, compat_sys_io_setup, sys_io_destroy
+/*270*/ .word compat_sys_io_submit, sys_io_cancel, compat_sys_io_getevents, sys_ni_syscall
 
 	/* Now the 64-bit native Linux syscall table. */
 
@@ -134,8 +134,8 @@ sys_call_table:
 /*250*/	.word sys64_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 	.word sys_ni_syscall, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.word sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-	.word sys_timer_delete, sys_timer_create, sys_ni_syscall, sys_io_setup, sys_io_destroy
-/*270*/	.word sys_io_submit, sys_io_cancel, sys_io_getevents, sys_ni_syscall
+	.word sys_timer_delete, sys_timer_create, sys_vserver, sys_io_setup, sys_io_destroy
+/*270*/ .word sys_io_submit, sys_io_cancel, sys_io_getevents, sys_ni_syscall
 
 #if defined(CONFIG_SUNOS_EMUL) || defined(CONFIG_SOLARIS_EMUL) || \
     defined(CONFIG_SOLARIS_EMUL_MODULE)
diff -NurpP --minimal linux-2.6.5/arch/sparc64/mm/hugetlbpage.c linux-2.6.5-vs1.9.0pre2/arch/sparc64/mm/hugetlbpage.c
--- linux-2.6.5/arch/sparc64/mm/hugetlbpage.c	2004-04-04 18:02:57.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/sparc64/mm/hugetlbpage.c	2004-04-05 00:55:18.000000000 +0200
@@ -119,7 +119,8 @@ static void set_huge_pte(struct mm_struc
 	unsigned long i;
 	pte_t entry;
 
-	mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	// mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+	vx_rsspages_add(mm, HPAGE_SIZE / PAGE_SIZE);
 
 	if (write_access)
 		entry = pte_mkwrite(pte_mkdirty(mk_pte(page,
@@ -172,7 +173,8 @@ int copy_hugetlb_page_range(struct mm_st
 			pte_val(entry) += PAGE_SIZE;
 			dst_pte++;
 		}
-		dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		// dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		vx_rsspages_add(dst, HPAGE_SIZE / PAGE_SIZE);
 		addr += HPAGE_SIZE;
 	}
 	return 0;
@@ -290,7 +292,8 @@ void unmap_hugepage_range(struct vm_area
 			pte++;
 		}
 	}
-	mm->rss -= (end - start) >> PAGE_SHIFT;
+	// mm->rss -= (end - start) >> PAGE_SHIFT;
+	vx_rsspages_sub(mm, (end - start) >> PAGE_SHIFT);
 	flush_tlb_range(vma, start, end);
 }
 
diff -NurpP --minimal linux-2.6.5/arch/um/Kconfig linux-2.6.5-vs1.9.0pre2/arch/um/Kconfig
--- linux-2.6.5/arch/um/Kconfig	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/um/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -188,6 +188,8 @@ source "net/Kconfig"
 
 source "fs/Kconfig"
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/um/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/um/kernel/ptrace.c
--- linux-2.6.5/arch/um/kernel/ptrace.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/um/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -58,6 +58,8 @@ int sys_ptrace(long request, long pid, l
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/um/kernel/syscall_kern.c linux-2.6.5-vs1.9.0pre2/arch/um/kernel/syscall_kern.c
--- linux-2.6.5/arch/um/kernel/syscall_kern.c	2004-03-11 03:55:36.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/um/kernel/syscall_kern.c	2004-04-05 00:55:13.000000000 +0200
@@ -264,7 +264,7 @@ int sys_uname(struct old_utsname * name)
 	if (!name)
 		return -EFAULT;
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	err=copy_to_user(name, &vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	return err?-EFAULT:0;
 }
@@ -272,6 +272,7 @@ int sys_uname(struct old_utsname * name)
 int sys_olduname(struct oldold_utsname * name)
 {
 	int error;
+	struct new_utsname *ptr;
 
 	if (!name)
 		return -EFAULT;
@@ -280,19 +281,20 @@ int sys_olduname(struct oldold_utsname *
   
   	down_read(&uts_sem);
 	
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,
+	ptr = &vx_new_utsname();
+	error = __copy_to_user(&name->sysname,ptr->sysname,
 			       __OLD_UTS_LEN);
 	error |= __put_user(0,name->sysname+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->nodename,&system_utsname.nodename,
+	error |= __copy_to_user(&name->nodename,ptr->nodename,
 				__OLD_UTS_LEN);
 	error |= __put_user(0,name->nodename+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->release,&system_utsname.release,
+	error |= __copy_to_user(&name->release,ptr->release,
 				__OLD_UTS_LEN);
 	error |= __put_user(0,name->release+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->version,&system_utsname.version,
+	error |= __copy_to_user(&name->version,ptr->version,
 				__OLD_UTS_LEN);
 	error |= __put_user(0,name->version+__OLD_UTS_LEN);
-	error |= __copy_to_user(&name->machine,&system_utsname.machine,
+	error |= __copy_to_user(&name->machine,ptr->machine,
 				__OLD_UTS_LEN);
 	error |= __put_user(0,name->machine+__OLD_UTS_LEN);
 	
diff -NurpP --minimal linux-2.6.5/arch/v850/Kconfig linux-2.6.5-vs1.9.0pre2/arch/v850/Kconfig
--- linux-2.6.5/arch/v850/Kconfig	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/v850/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -334,6 +334,8 @@ config NO_KERNEL_MSG
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/v850/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/v850/kernel/ptrace.c
--- linux-2.6.5/arch/v850/kernel/ptrace.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/v850/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -138,6 +138,8 @@ int sys_ptrace(long request, long pid, l
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	rval = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/x86_64/Kconfig linux-2.6.5-vs1.9.0pre2/arch/x86_64/Kconfig
--- linux-2.6.5/arch/x86_64/Kconfig	2004-04-04 18:02:57.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -499,6 +499,8 @@ config IOMMU_LEAK
 
 endmenu
 
+source "kernel/vserver/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -NurpP --minimal linux-2.6.5/arch/x86_64/ia32/ia32_aout.c linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/ia32_aout.c
--- linux-2.6.5/arch/x86_64/ia32/ia32_aout.c	2004-03-11 03:55:54.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/ia32_aout.c	2004-04-05 00:55:18.000000000 +0200
@@ -308,7 +308,8 @@ static int load_aout_binary(struct linux
 		(current->mm->start_brk = N_BSSADDR(ex));
 	current->mm->free_area_cache = TASK_UNMAPPED_BASE;
 
-	current->mm->rss = 0;
+	// current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
diff -NurpP --minimal linux-2.6.5/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.5/arch/x86_64/ia32/ia32_binfmt.c	2004-04-04 18:02:57.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/ia32_binfmt.c	2004-04-05 00:55:18.000000000 +0200
@@ -363,7 +363,9 @@ int setup_arg_pages(struct linux_binprm 
 		INIT_LIST_HEAD(&mpnt->shared);
 		mpnt->vm_private_data = (void *) 0;
 		insert_vm_struct(mm, mpnt);
-		mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		// mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(mm, mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	} 
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.6.5/arch/x86_64/ia32/ia32entry.S linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/ia32entry.S
--- linux-2.6.5/arch/x86_64/ia32/ia32entry.S	2004-04-04 18:02:57.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/ia32entry.S	2004-04-05 00:55:13.000000000 +0200
@@ -550,34 +550,35 @@ ia32_sys_call_table:
         .quad compat_sys_sched_getaffinity
 	.quad sys32_set_thread_area
 	.quad sys32_get_thread_area
-	.quad sys32_io_setup
+	.quad sys32_io_setup	/* 245 */
 	.quad sys_io_destroy
 	.quad sys32_io_getevents
 	.quad sys32_io_submit
 	.quad sys_io_cancel
-	.quad sys_fadvise64
+	.quad sys_fadvise64	/* 250 */
 	.quad quiet_ni_syscall /* free_huge_pages */
 	.quad sys_exit_group /* exit_group */
 	.quad sys_lookup_dcookie
 	.quad sys_epoll_create
-	.quad sys_epoll_ctl
+	.quad sys_epoll_ctl	/* 255 */
 	.quad sys_epoll_wait
 	.quad sys_remap_file_pages
 	.quad sys_set_tid_address
 	.quad sys32_timer_create
-	.quad compat_timer_settime
+	.quad compat_timer_settime	/* 260 */
 	.quad compat_timer_gettime
 	.quad sys_timer_getoverrun
 	.quad sys_timer_delete
 	.quad compat_clock_settime
-	.quad compat_clock_gettime
+	.quad compat_clock_gettime	/* 265 */
 	.quad compat_clock_getres
 	.quad compat_clock_nanosleep
 	.quad compat_statfs64   /* statfs64 */
 	.quad compat_fstatfs64  /* fstatfs64 */
-	.quad sys_tgkill
+	.quad sys_tgkill	/* 270 */
 	.quad compat_sys_utimes
 	.quad sys32_fadvise64_64
+	.quad sys_vserver	/* 273 sys_vserver */
 	/* don't forget to change IA32_NR_syscalls */
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
diff -NurpP --minimal linux-2.6.5/arch/x86_64/ia32/sys_ia32.c linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.5/arch/x86_64/ia32/sys_ia32.c	2004-04-04 18:02:57.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/ia32/sys_ia32.c	2004-04-05 00:55:13.000000000 +0200
@@ -1257,6 +1257,7 @@ asmlinkage long sys32_mmap2(unsigned lon
 asmlinkage long sys32_olduname(struct oldold_utsname * name)
 {
 	int error;
+	struct new_utsname *ptr;
 
 	if (!name)
 		return -EFAULT;
@@ -1265,13 +1266,14 @@ asmlinkage long sys32_olduname(struct ol
   
   	down_read(&uts_sem);
 	
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,__OLD_UTS_LEN);
+	ptr = &vx_new_utsname();
+	error = __copy_to_user(&name->sysname,ptr->sysname,__OLD_UTS_LEN);
 	 __put_user(0,name->sysname+__OLD_UTS_LEN);
-	 __copy_to_user(&name->nodename,&system_utsname.nodename,__OLD_UTS_LEN);
+	 __copy_to_user(&name->nodename,ptr->nodename,__OLD_UTS_LEN);
 	 __put_user(0,name->nodename+__OLD_UTS_LEN);
-	 __copy_to_user(&name->release,&system_utsname.release,__OLD_UTS_LEN);
+	 __copy_to_user(&name->release,ptr->release,__OLD_UTS_LEN);
 	 __put_user(0,name->release+__OLD_UTS_LEN);
-	 __copy_to_user(&name->version,&system_utsname.version,__OLD_UTS_LEN);
+	 __copy_to_user(&name->version,ptr->version,__OLD_UTS_LEN);
 	 __put_user(0,name->version+__OLD_UTS_LEN);
 	 { 
 		 char *arch = "x86_64";
@@ -1294,7 +1296,7 @@ long sys32_uname(struct old_utsname * na
 	if (!name)
 		return -EFAULT;
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	err=copy_to_user(name, &vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	if (personality(current->personality) == PER_LINUX32) 
 		err |= copy_to_user(&name->machine, "i686", 5);
diff -NurpP --minimal linux-2.6.5/arch/x86_64/kernel/ptrace.c linux-2.6.5-vs1.9.0pre2/arch/x86_64/kernel/ptrace.c
--- linux-2.6.5/arch/x86_64/kernel/ptrace.c	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/kernel/ptrace.c	2004-04-05 00:55:18.000000000 +0200
@@ -207,6 +207,8 @@ asmlinkage long sys_ptrace(long request,
 	read_unlock(&tasklist_lock);
 	if (!child)
 		goto out;
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out_tsk;
 
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.6.5/arch/x86_64/kernel/sys_x86_64.c linux-2.6.5-vs1.9.0pre2/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.6.5/arch/x86_64/kernel/sys_x86_64.c	2004-03-11 03:55:35.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/arch/x86_64/kernel/sys_x86_64.c	2004-04-05 00:55:13.000000000 +0200
@@ -146,7 +146,7 @@ asmlinkage long sys_uname(struct new_uts
 {
 	int err;
 	down_read(&uts_sem);
-	err = copy_to_user(name, &system_utsname, sizeof (*name));
+	err = copy_to_user(name, &vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	if (personality(current->personality) == PER_LINUX32) 
 		err |= copy_to_user(&name->machine, "i686", 5); 		
diff -NurpP --minimal linux-2.6.5/fs/attr.c linux-2.6.5-vs1.9.0pre2/fs/attr.c
--- linux-2.6.5/fs/attr.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/attr.c	2004-04-05 00:55:19.000000000 +0200
@@ -184,6 +184,8 @@ int notify_change(struct dentry * dentry
 	}
 	if (!error) {
 		unsigned long dn_mask = setattr_mask(ia_valid);
+
+		vx_dq_cond_modify(inode, current->xid);
 		if (dn_mask)
 			dnotify_parent(dentry, dn_mask);
 	}
diff -NurpP --minimal linux-2.6.5/fs/binfmt_aout.c linux-2.6.5-vs1.9.0pre2/fs/binfmt_aout.c
--- linux-2.6.5/fs/binfmt_aout.c	2004-03-11 03:55:23.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/binfmt_aout.c	2004-04-05 00:55:18.000000000 +0200
@@ -309,7 +309,8 @@ static int load_aout_binary(struct linux
 		(current->mm->start_brk = N_BSSADDR(ex));
 	current->mm->free_area_cache = TASK_UNMAPPED_BASE;
 
-	current->mm->rss = 0;
+	// current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
diff -NurpP --minimal linux-2.6.5/fs/binfmt_elf.c linux-2.6.5-vs1.9.0pre2/fs/binfmt_elf.c
--- linux-2.6.5/fs/binfmt_elf.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/binfmt_elf.c	2004-04-05 00:55:18.000000000 +0200
@@ -672,7 +672,8 @@ static int load_elf_binary(struct linux_
 
 	/* Do this so that we can load the interpreter, if need be.  We will
 	   change some of these later */
-	current->mm->rss = 0;
+	// current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	current->mm->free_area_cache = TASK_UNMAPPED_BASE;
 	retval = setup_arg_pages(bprm);
 	if (retval < 0) {
diff -NurpP --minimal linux-2.6.5/fs/binfmt_flat.c linux-2.6.5-vs1.9.0pre2/fs/binfmt_flat.c
--- linux-2.6.5/fs/binfmt_flat.c	2004-03-11 03:55:20.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/binfmt_flat.c	2004-04-05 00:55:18.000000000 +0200
@@ -651,7 +651,8 @@ static int load_flat_file(struct linux_b
 		current->mm->start_brk = datapos + data_len + bss_len;
 		current->mm->brk = (current->mm->start_brk + 3) & ~3;
 		current->mm->context.end_brk = memp + ksize((void *) memp) - stack_len;
-		current->mm->rss = 0;
+		// current->mm->rss = 0;
+		vx_rsspages_sub(current->mm, current->mm->rss);
 	}
 
 	if (flags & FLAT_FLAG_KTRACE)
diff -NurpP --minimal linux-2.6.5/fs/binfmt_som.c linux-2.6.5-vs1.9.0pre2/fs/binfmt_som.c
--- linux-2.6.5/fs/binfmt_som.c	2004-03-11 03:55:25.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/binfmt_som.c	2004-04-05 00:55:18.000000000 +0200
@@ -259,7 +259,8 @@ load_som_binary(struct linux_binprm * bp
 	create_som_tables(bprm);
 
 	current->mm->start_stack = bprm->p;
-	current->mm->rss = 0;
+	// current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 
 #if 0
 	printk("(start_brk) %08lx\n" , (unsigned long) current->mm->start_brk);
diff -NurpP --minimal linux-2.6.5/fs/devpts/inode.c linux-2.6.5-vs1.9.0pre2/fs/devpts/inode.c
--- linux-2.6.5/fs/devpts/inode.c	2004-03-11 03:55:23.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/devpts/inode.c	2004-04-05 00:55:13.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/mount.h>
 #include <linux/tty.h>
 #include <linux/devpts_fs.h>
+#include <linux/vinline.h>
 #include "xattr.h"
 
 #define DEVPTS_SUPER_MAGIC 0x1cd1
@@ -134,11 +135,21 @@ static struct dentry *get_node(int num)
 	return lookup_one_len(s, root, sprintf(s, "%d", num));
 }
 
+static int devpts_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
+	int ret = -EACCES;
+	
+	if (vx_check(inode->i_xid, VX_IDENT))
+		ret = vfs_permission(inode, mask);
+	return ret;
+}
+
 static struct inode_operations devpts_file_inode_operations = {
 	.setxattr	= devpts_setxattr,
 	.getxattr	= devpts_getxattr,
 	.listxattr	= devpts_listxattr,
 	.removexattr	= devpts_removexattr,
+	.permission	= devpts_permission,
 };
 
 int devpts_pty_new(struct tty_struct *tty)
@@ -162,6 +173,7 @@ int devpts_pty_new(struct tty_struct *tt
 	inode->i_gid = config.setgid ? config.gid : current->fsgid;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	init_special_inode(inode, S_IFCHR|config.mode, device);
+	inode->i_xid = vx_current_xid();
 	inode->i_op = &devpts_file_inode_operations;
 	inode->u.generic_ip = tty;
 
diff -NurpP --minimal linux-2.6.5/fs/dquot.c linux-2.6.5-vs1.9.0pre2/fs/dquot.c
--- linux-2.6.5/fs/dquot.c	2004-03-11 03:55:36.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/dquot.c	2004-04-05 00:55:18.000000000 +0200
@@ -73,6 +73,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
+#include <linux/quotaops.h>
 #include <linux/security.h>
 #include <linux/kmod.h>
 
@@ -151,7 +152,7 @@ static void put_quota_format(struct quot
 /*
  * Dquot List Management:
  * The quota code uses three lists for dquot management: the inuse_list,
- * free_dquots, and dquot_hash[] array. A single dquot structure may be
+ * free_dquots, and hash->dqh_hash[] array. A single dquot structure may be
  * on all three lists, depending on its current state.
  *
  * All dquots are placed to the end of inuse_list when first created, and this
@@ -165,7 +166,7 @@ static void put_quota_format(struct quot
  * dquot is invalidated it's completely released from memory.
  *
  * Dquots with a specific identity (device, type and id) are placed on
- * one of the dquot_hash[] hash chains. The provides an efficient search
+ * one of the hash->dqh_hash[] hash chains. The provides an efficient search
  * mechanism to locate a specific dquot.
  */
 
@@ -188,39 +189,41 @@ static void put_quota_format(struct quot
 
 static LIST_HEAD(inuse_list);
 static LIST_HEAD(free_dquots);
-static struct list_head dquot_hash[NR_DQHASH];
 
 struct dqstats dqstats;
 
 static void dqput(struct dquot *dquot);
 
-static inline int const hashfn(struct super_block *sb, unsigned int id, int type)
+static inline int const hashfn(unsigned int id, int type)
 {
-	return((((unsigned long)sb>>L1_CACHE_SHIFT) ^ id) * (MAXQUOTAS - type)) % NR_DQHASH;
+	return (id * (MAXQUOTAS - type)) % NR_DQHASH;
 }
 
 /*
  * Following list functions expect dq_list_lock to be held
  */
-static inline void insert_dquot_hash(struct dquot *dquot)
+static inline void insert_dquot_hash(struct dqhash *hash, struct dquot *dquot)
 {
-	struct list_head *head = dquot_hash + hashfn(dquot->dq_sb, dquot->dq_id, dquot->dq_type);
+	struct list_head *head = hash->dqh_hash + hashfn(dquot->dq_id, dquot->dq_type);
 	list_add(&dquot->dq_hash, head);
+	dquot->dq_dqh = dqhget(hash);
 }
 
 static inline void remove_dquot_hash(struct dquot *dquot)
 {
 	list_del_init(&dquot->dq_hash);
+	dqhput(dquot->dq_dqh);
+	dquot->dq_dqh = NULL;
 }
 
-static inline struct dquot *find_dquot(unsigned int hashent, struct super_block *sb, unsigned int id, int type)
+static inline struct dquot *find_dquot(struct dqhash *hash, unsigned int hashent, unsigned int id, int type)
 {
 	struct list_head *head;
 	struct dquot *dquot;
 
-	for (head = dquot_hash[hashent].next; head != dquot_hash+hashent; head = head->next) {
+	for (head = hash->dqh_hash[hashent].next; head != hash->dqh_hash+hashent; head = head->next) {
 		dquot = list_entry(head, struct dquot, dq_hash);
-		if (dquot->dq_sb == sb && dquot->dq_id == id && dquot->dq_type == type)
+		if (dquot->dq_id == id && dquot->dq_type == type)
 			return dquot;
 	}
 	return NODQUOT;
@@ -264,7 +267,7 @@ static void wait_on_dquot(struct dquot *
 static int read_dqblk(struct dquot *dquot)
 {
 	int ret;
-	struct quota_info *dqopt = sb_dqopt(dquot->dq_sb);
+	struct quota_info *dqopt = dqh_dqopt(dquot->dq_dqh);
 
 	down(&dquot->dq_lock);
 	down(&dqopt->dqio_sem);
@@ -277,7 +280,7 @@ static int read_dqblk(struct dquot *dquo
 static int commit_dqblk(struct dquot *dquot)
 {
 	int ret;
-	struct quota_info *dqopt = sb_dqopt(dquot->dq_sb);
+	struct quota_info *dqopt = dqh_dqopt(dquot->dq_dqh);
 
 	down(&dqopt->dqio_sem);
 	ret = dqopt->ops[dquot->dq_type]->commit_dqblk(dquot);
@@ -289,38 +292,108 @@ static int commit_dqblk(struct dquot *dq
  * quota is disabled so no new quota might be created. Because we hold dqptr_sem
  * for writing and pointers were already removed from inodes we actually know that
  * no quota for this sb+type should be held. */
-static void invalidate_dquots(struct super_block *sb, int type)
+static void invalidate_dquots(struct dqhash *hash, int type)
 {
-	struct dquot *dquot;
-	struct list_head *head;
+	int i;
 
 	spin_lock(&dq_list_lock);
-	for (head = inuse_list.next; head != &inuse_list;) {
-		dquot = list_entry(head, struct dquot, dq_inuse);
-		head = head->next;
-		if (dquot->dq_sb != sb)
-			continue;
-		if (dquot->dq_type != type)
-			continue;
+	for (i=0; i<NR_DQHASH; i++) {
+		struct list_head *head = &hash->dqh_hash[i];
+
+		while ((head = head->next) != &hash->dqh_hash[i]) {
+			struct dquot *dquot = list_entry(head, struct dquot, dq_hash);
+
+			if (dquot->dq_type != type)
+				continue;
 #ifdef __DQUOT_PARANOIA	
-		/* There should be no users of quota - we hold dqptr_sem for writing */
-		if (atomic_read(&dquot->dq_count))
-			BUG();
+			/* There should be no users of quota - we hold dqptr_sem for writing */
+			if (atomic_read(&dquot->dq_count))
+				BUG();
 #endif
-		/* Quota now have no users and it has been written on last dqput() */
-		remove_dquot_hash(dquot);
-		remove_free_dquot(dquot);
-		remove_inuse(dquot);
-		kmem_cache_free(dquot_cachep, dquot);
+			/* Quota now have no users and it has been written on last dqput() */
+			remove_dquot_hash(dquot);
+			remove_free_dquot(dquot);
+			remove_inuse(dquot);
+			kmem_cache_free(dquot_cachep, dquot);
+			/* now restart */
+			head = &hash->dqh_hash[i];
+		}
 	}
 	spin_unlock(&dq_list_lock);
 }
 
-static int vfs_quota_sync(struct super_block *sb, int type)
+/* Dquota Hash Management Functions */
+
+static LIST_HEAD(dqhash_list);
+
+struct dqhash *new_dqhash(struct super_block *sb, unsigned int id)
+{
+	struct dqhash *hash;
+	int i;
+	
+	hash = kmalloc(sizeof(struct dqhash),  GFP_USER);
+	if (!hash)
+		return ERR_PTR(-ENOMEM);
+
+	memset(hash, 0, sizeof(struct dqhash));
+	hash->dqh_id = id;
+	atomic_set(&hash->dqh_count, 1);
+	INIT_LIST_HEAD(&hash->dqh_list);
+	for (i = 0; i < NR_DQHASH; i++)
+		INIT_LIST_HEAD(hash->dqh_hash + i);
+	sema_init(&hash->dqh_dqopt.dqio_sem, 1);
+	sema_init(&hash->dqh_dqopt.dqonoff_sem, 1);
+	init_rwsem(&hash->dqh_dqopt.dqptr_sem);
+	hash->dqh_qop = sb->s_qop;
+	hash->dqh_qcop = sb->s_qcop;
+	hash->dqh_sb = sb;
+
+	lock_kernel();
+	list_add(&hash->dqh_list, &dqhash_list);
+	unlock_kernel();
+	dprintk (" new_dqhash: %p [#0x%08x]\n", hash, hash->dqh_id);
+	return hash;
+}
+
+void destroy_dqhash(struct dqhash *hash)
+{
+	int cnt;
+
+	dprintk (" destroy_dqhash: %p [#0x%08x] c=%d\n", hash, hash->dqh_id, atomic_read(&hash->dqh_count));
+	lock_kernel();
+	list_del_init(&hash->dqh_list);
+	unlock_kernel();
+	for (cnt = 0; cnt < MAXQUOTAS; cnt++)	/* should not be required anymore! */
+		invalidate_dquots(hash, cnt);
+	kfree(hash);
+}
+
+
+struct dqhash *find_dqhash(unsigned int id)
+{
+	struct list_head *head;
+	struct dqhash *hash;
+
+	lock_kernel();
+	list_for_each(head, &dqhash_list) {
+		hash = list_entry(head, struct dqhash, dqh_list);
+		if (hash->dqh_id == id)
+			goto dqh_found;
+	}
+	unlock_kernel();
+	return NULL;
+	
+dqh_found:
+	unlock_kernel();
+	return dqhget(hash);
+}
+
+
+static int vfs_quota_sync(struct dqhash *hash, int type)
 {
 	struct list_head *head;
 	struct dquot *dquot;
-	struct quota_info *dqopt = sb_dqopt(sb);
+	struct quota_info *dqopt = dqh_dqopt(hash);
 	int cnt;
 
 	down_read(&dqopt->dqptr_sem);
@@ -328,32 +401,32 @@ restart:
 	/* At this point any dirty dquot will definitely be written so we can clear
 	   dirty flag from info */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
-		if ((cnt == type || type == -1) && sb_has_quota_enabled(sb, cnt))
+		if ((cnt == type || type == -1) && dqh_has_quota_enabled(hash, cnt))
 			clear_bit(DQF_ANY_DQUOT_DIRTY_B, &dqopt->info[cnt].dqi_flags);
 	spin_lock(&dq_list_lock);
 	list_for_each(head, &inuse_list) {
 		dquot = list_entry(head, struct dquot, dq_inuse);
-		if (sb && dquot->dq_sb != sb)
+		if (hash && dquot->dq_dqh != hash)
 			continue;
                 if (type != -1 && dquot->dq_type != type)
 			continue;
-		if (!dquot->dq_sb)	/* Invalidated? */
+		if (!dquot->dq_dqh)	/* Invalidated? */
 			continue;
 		if (!dquot_dirty(dquot))
 			continue;
 		atomic_inc(&dquot->dq_count);
 		dqstats.lookups++;
 		spin_unlock(&dq_list_lock);
-		sb->dq_op->write_dquot(dquot);
+		hash->dqh_qop->write_dquot(dquot);
 		dqput(dquot);
 		goto restart;
 	}
 	spin_unlock(&dq_list_lock);
 
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
-		if ((cnt == type || type == -1) && sb_has_quota_enabled(sb, cnt) && info_dirty(&dqopt->info[cnt])) {
+		if ((cnt == type || type == -1) && dqh_has_quota_enabled(hash, cnt) && info_dirty(&dqopt->info[cnt])) {
 			down(&dqopt->dqio_sem);
-			dqopt->ops[cnt]->write_file_info(sb, cnt);
+			dqopt->ops[cnt]->write_file_info(hash, cnt);
 			up(&dqopt->dqio_sem);
 		}
 	spin_lock(&dq_list_lock);
@@ -412,7 +485,7 @@ static void dqput(struct dquot *dquot)
 	if (!atomic_read(&dquot->dq_count)) {
 		printk("VFS: dqput: trying to free free dquot\n");
 		printk("VFS: device %s, dquot of %s %d\n",
-			dquot->dq_sb->s_id,
+			dquot->dq_dqh->dqh_sb->s_id,
 			quotatypes[dquot->dq_type],
 			dquot->dq_id);
 		BUG();
@@ -432,7 +505,7 @@ we_slept:
 	}
 	if (dquot_dirty(dquot)) {
 		spin_unlock(&dq_list_lock);
-		dquot->dq_sb->dq_op->write_dquot(dquot);
+		dquot->dq_dqh->dqh_qop->write_dquot(dquot);
 		goto we_slept;
 	}
 	atomic_dec(&dquot->dq_count);
@@ -445,7 +518,7 @@ we_slept:
 	spin_unlock(&dq_list_lock);
 }
 
-static struct dquot *get_empty_dquot(struct super_block *sb, int type)
+static struct dquot *get_empty_dquot(int type)
 {
 	struct dquot *dquot;
 
@@ -458,7 +531,7 @@ static struct dquot *get_empty_dquot(str
 	INIT_LIST_HEAD(&dquot->dq_free);
 	INIT_LIST_HEAD(&dquot->dq_inuse);
 	INIT_LIST_HEAD(&dquot->dq_hash);
-	dquot->dq_sb = sb;
+	dquot->dq_dqh = NULL;
 	dquot->dq_type = type;
 	atomic_set(&dquot->dq_count, 1);
 
@@ -469,19 +542,19 @@ static struct dquot *get_empty_dquot(str
  * Get reference to dquot
  * MUST be called with dqptr_sem held
  */
-static struct dquot *dqget(struct super_block *sb, unsigned int id, int type)
+static struct dquot *dqget(struct dqhash *hash, unsigned int id, int type)
 {
-	unsigned int hashent = hashfn(sb, id, type);
+	unsigned int hashent = hashfn(id, type);
 	struct dquot *dquot, *empty = NODQUOT;
 
-        if (!sb_has_quota_enabled(sb, type))
+        if (!dqh_has_quota_enabled(hash, type))
 		return NODQUOT;
 we_slept:
 	spin_lock(&dq_list_lock);
-	if ((dquot = find_dquot(hashent, sb, id, type)) == NODQUOT) {
+	if ((dquot = find_dquot(hash, hashent, id, type)) == NODQUOT) {
 		if (empty == NODQUOT) {
 			spin_unlock(&dq_list_lock);
-			if ((empty = get_empty_dquot(sb, type)) == NODQUOT)
+			if ((empty = get_empty_dquot(type)) == NODQUOT)
 				schedule();	/* Try to wait for a moment... */
 			goto we_slept;
 		}
@@ -490,7 +563,7 @@ we_slept:
 		/* all dquots go on the inuse_list */
 		put_inuse(dquot);
 		/* hash it first so it can be found */
-		insert_dquot_hash(dquot);
+		insert_dquot_hash(hash, dquot);
 		dqstats.lookups++;
 		spin_unlock(&dq_list_lock);
 		read_dqblk(dquot);
@@ -507,7 +580,7 @@ we_slept:
 	}
 
 #ifdef __DQUOT_PARANOIA
-	if (!dquot->dq_sb)	/* Has somebody invalidated entry under us? */
+	if (!dquot->dq_dqh)	/* Has somebody invalidated entry under us? */
 		BUG();
 #endif
 
@@ -529,9 +602,10 @@ static int dqinit_needed(struct inode *i
 }
 
 /* This routine is guarded by dqptr_sem semaphore */
-static void add_dquot_ref(struct super_block *sb, int type)
+static void add_dquot_ref(struct dqhash *hash, int type)
 {
 	struct list_head *p;
+	struct super_block *sb = hash->dqh_sb;
 
 restart:
 	file_list_lock();
@@ -542,7 +616,7 @@ restart:
 			struct vfsmount *mnt = mntget(filp->f_vfsmnt);
 			struct dentry *dentry = dget(filp->f_dentry);
 			file_list_unlock();
-			sb->dq_op->initialize(inode, type);
+			hash->dqh_qop->initialize(inode, type);
 			dput(dentry);
 			mntput(mnt);
 			/* As we may have blocked we had better restart... */
@@ -674,7 +748,7 @@ static void print_warning(struct dquot *
 
 	if (!need_print_warning(dquot) || (flag && test_and_set_bit(flag, &dquot->dq_flags)))
 		return;
-	tty_write_message(current->tty, dquot->dq_sb->s_id);
+	tty_write_message(current->tty, dquot->dq_dqh->dqh_sb->s_id);
 	if (warntype == ISOFTWARN || warntype == BSOFTWARN)
 		tty_write_message(current->tty, ": warning, ");
 	else
@@ -714,7 +788,7 @@ static inline void flush_warnings(struct
 
 static inline char ignore_hardlimit(struct dquot *dquot)
 {
-	struct mem_dqinfo *info = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_type];
+	struct mem_dqinfo *info = &dqh_dqopt(dquot->dq_dqh)->info[dquot->dq_type];
 
 	return capable(CAP_SYS_RESOURCE) &&
 	    (info->dqi_format->qf_fmt_id != QFMT_VFS_OLD || !(info->dqi_flags & V1_DQF_RSQUASH));
@@ -746,7 +820,7 @@ static int check_idq(struct dquot *dquot
 	   (dquot->dq_dqb.dqb_curinodes + inodes) > dquot->dq_dqb.dqb_isoftlimit &&
 	    dquot->dq_dqb.dqb_itime == 0) {
 		*warntype = ISOFTWARN;
-		dquot->dq_dqb.dqb_itime = get_seconds() + sb_dqopt(dquot->dq_sb)->info[dquot->dq_type].dqi_igrace;
+		dquot->dq_dqb.dqb_itime = get_seconds() + dqh_dqopt(dquot->dq_dqh)->info[dquot->dq_type].dqi_igrace;
 	}
 
 	return QUOTA_OK;
@@ -781,7 +855,7 @@ static int check_bdq(struct dquot *dquot
 	    dquot->dq_dqb.dqb_btime == 0) {
 		if (!prealloc) {
 			*warntype = BSOFTWARN;
-			dquot->dq_dqb.dqb_btime = get_seconds() + sb_dqopt(dquot->dq_sb)->info[dquot->dq_type].dqi_bgrace;
+			dquot->dq_dqb.dqb_btime = get_seconds() + dqh_dqopt(dquot->dq_dqh)->info[dquot->dq_type].dqi_bgrace;
 		}
 		else
 			/*
@@ -802,12 +876,13 @@ static int check_bdq(struct dquot *dquot
 void dquot_initialize(struct inode *inode, int type)
 {
 	unsigned int id = 0;
+	struct dqhash *dqh = inode->i_sb->s_dqh;
 	int cnt;
 
-	down_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	/* Having dqptr_sem we know NOQUOTA flags can't be altered... */
 	if (IS_NOQUOTA(inode)) {
-		up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		up_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 		return;
 	}
 	/* Build list of quotas to initialize... */
@@ -823,12 +898,12 @@ void dquot_initialize(struct inode *inod
 					id = inode->i_gid;
 					break;
 			}
-			inode->i_dquot[cnt] = dqget(inode->i_sb, id, cnt);
+			inode->i_dquot[cnt] = dqget(dqh, id, cnt);
 			if (inode->i_dquot[cnt])
 				inode->i_flags |= S_QUOTA;
 		}
 	}
-	up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 }
 
 /*
@@ -854,9 +929,9 @@ void dquot_drop(struct inode *inode)
 	struct dquot *to_drop[MAXQUOTAS];
 	int cnt;
 
-	down_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	dquot_drop_iupdate(inode, to_drop);
-	up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
 		if (to_drop[cnt] != NODQUOT)
 			dqput(to_drop[cnt]);
@@ -888,7 +963,7 @@ int dquot_alloc_space(struct inode *inod
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
 		warntype[cnt] = NOWARN;
 
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	spin_lock(&dq_data_lock);
 	if (IS_NOQUOTA(inode))
 		goto add_bytes;
@@ -909,7 +984,7 @@ add_bytes:
 warn_put_all:
 	spin_unlock(&dq_data_lock);
 	flush_warnings(inode->i_dquot, warntype);
-	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	return ret;
 }
 
@@ -923,9 +998,9 @@ int dquot_alloc_inode(const struct inode
 
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
 		warntype[cnt] = NOWARN;
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	if (IS_NOQUOTA(inode)) {
-		up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		up_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 		return QUOTA_OK;
 	}
 	spin_lock(&dq_data_lock);
@@ -945,7 +1020,7 @@ int dquot_alloc_inode(const struct inode
 warn_put_all:
 	spin_unlock(&dq_data_lock);
 	flush_warnings((struct dquot **)inode->i_dquot, warntype);
-	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	return ret;
 }
 
@@ -956,7 +1031,7 @@ void dquot_free_space(struct inode *inod
 {
 	unsigned int cnt;
 
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	spin_lock(&dq_data_lock);
 	if (IS_NOQUOTA(inode))
 		goto sub_bytes;
@@ -968,7 +1043,7 @@ void dquot_free_space(struct inode *inod
 sub_bytes:
 	inode_sub_bytes(inode, number);
 	spin_unlock(&dq_data_lock);
-	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 }
 
 /*
@@ -978,9 +1053,9 @@ void dquot_free_inode(const struct inode
 {
 	unsigned int cnt;
 
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	if (IS_NOQUOTA(inode)) {
-		up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		up_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 		return;
 	}
 	spin_lock(&dq_data_lock);
@@ -990,7 +1065,7 @@ void dquot_free_inode(const struct inode
 		dquot_decr_inodes(inode->i_dquot[cnt], number);
 	}
 	spin_unlock(&dq_data_lock);
-	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_read(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 }
 
 /*
@@ -1003,6 +1078,7 @@ int dquot_transfer(struct inode *inode, 
 	qsize_t space;
 	struct dquot *transfer_from[MAXQUOTAS];
 	struct dquot *transfer_to[MAXQUOTAS];
+	struct dqhash *dqh = inode->i_sb->s_dqh;
 	int cnt, ret = NO_QUOTA, chuid = (iattr->ia_valid & ATTR_UID) && inode->i_uid != iattr->ia_uid,
 	    chgid = (iattr->ia_valid & ATTR_GID) && inode->i_gid != iattr->ia_gid;
 	char warntype[MAXQUOTAS];
@@ -1012,9 +1088,9 @@ int dquot_transfer(struct inode *inode, 
 		transfer_to[cnt] = transfer_from[cnt] = NODQUOT;
 		warntype[cnt] = NOWARN;
 	}
-	down_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	down_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	if (IS_NOQUOTA(inode)) {	/* File without quota accounting? */
-		up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		up_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 		return QUOTA_OK;
 	}
 	/* First build the transfer_to list - here we can block on reading of dquots... */
@@ -1023,12 +1099,12 @@ int dquot_transfer(struct inode *inode, 
 			case USRQUOTA:
 				if (!chuid)
 					continue;
-				transfer_to[cnt] = dqget(inode->i_sb, iattr->ia_uid, cnt);
+				transfer_to[cnt] = dqget(dqh, iattr->ia_uid, cnt);
 				break;
 			case GRPQUOTA:
 				if (!chgid)
 					continue;
-				transfer_to[cnt] = dqget(inode->i_sb, iattr->ia_gid, cnt);
+				transfer_to[cnt] = dqget(dqh, iattr->ia_gid, cnt);
 				break;
 		}
 	}
@@ -1073,7 +1149,7 @@ warn_put_all:
 		if (ret == NO_QUOTA && transfer_to[cnt] != NODQUOT)
 			dqput(transfer_to[cnt]);
 	}
-	up_write(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	up_write(&dqh_dqopt(inode->i_dqh)->dqptr_sem);
 	return ret;
 }
 
@@ -1122,18 +1198,15 @@ static inline void reset_enable_flags(st
 }
 
 /* Function in inode.c - remove pointers to dquots in icache */
-extern void remove_dquot_ref(struct super_block *, int);
+extern void remove_dquot_ref(struct dqhash *, int);
 
 /*
  * Turn quota off on a device. type == -1 ==> quotaoff for all types (umount)
  */
-int vfs_quota_off(struct super_block *sb, int type)
+int vfs_quota_off(struct dqhash *hash, int type)
 {
 	int cnt;
-	struct quota_info *dqopt = sb_dqopt(sb);
-
-	if (!sb)
-		goto out;
+	struct quota_info *dqopt = dqh_dqopt(hash);
 
 	/* We need to serialize quota_off() for device */
 	down(&dqopt->dqonoff_sem);
@@ -1141,24 +1214,24 @@ int vfs_quota_off(struct super_block *sb
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
 		if (type != -1 && cnt != type)
 			continue;
-		if (!sb_has_quota_enabled(sb, cnt))
+		if (!dqh_has_quota_enabled(hash, cnt))
 			continue;
 		reset_enable_flags(dqopt, cnt);
 
 		/* Note: these are blocking operations */
-		remove_dquot_ref(sb, cnt);
-		invalidate_dquots(sb, cnt);
+		remove_dquot_ref(hash, cnt);
+		invalidate_dquots(hash, cnt);
 		/*
 		 * Now all dquots should be invalidated, all writes done so we should be only
 		 * users of the info. No locks needed.
 		 */
 		if (info_dirty(&dqopt->info[cnt])) {
 			down(&dqopt->dqio_sem);
-			dqopt->ops[cnt]->write_file_info(sb, cnt);
+			dqopt->ops[cnt]->write_file_info(hash, cnt);
 			up(&dqopt->dqio_sem);
 		}
 		if (dqopt->ops[cnt]->free_file_info)
-			dqopt->ops[cnt]->free_file_info(sb, cnt);
+			dqopt->ops[cnt]->free_file_info(hash, cnt);
 		put_quota_format(dqopt->info[cnt].dqi_format);
 
 		fput(dqopt->files[cnt]);
@@ -1170,15 +1243,14 @@ int vfs_quota_off(struct super_block *sb
 	}
 	up_write(&dqopt->dqptr_sem);
 	up(&dqopt->dqonoff_sem);
-out:
 	return 0;
 }
 
-int vfs_quota_on(struct super_block *sb, int type, int format_id, char *path)
+int vfs_quota_on(struct dqhash *hash, int type, int format_id, char *path)
 {
 	struct file *f;
 	struct inode *inode;
-	struct quota_info *dqopt = sb_dqopt(sb);
+	struct quota_info *dqopt = dqh_dqopt(hash);
 	struct quota_format_type *fmt = find_quota_format(format_id);
 	int error;
 	unsigned int oldflags;
@@ -1203,14 +1275,14 @@ int vfs_quota_on(struct super_block *sb,
 
 	down(&dqopt->dqonoff_sem);
 	down_write(&dqopt->dqptr_sem);
-	if (sb_has_quota_enabled(sb, type)) {
+	if (dqh_has_quota_enabled(hash, type)) {
 		error = -EBUSY;
 		goto out_lock;
 	}
 	oldflags = inode->i_flags;
 	dqopt->files[type] = f;
 	error = -EINVAL;
-	if (!fmt->qf_ops->check_quota_file(sb, type))
+	if (!fmt->qf_ops->check_quota_file(hash, type))
 		goto out_file_init;
 	/* We don't want quota and atime on quota files (deadlocks possible) */
 	dquot_drop_nolock(inode);
@@ -1219,7 +1291,7 @@ int vfs_quota_on(struct super_block *sb,
 	dqopt->ops[type] = fmt->qf_ops;
 	dqopt->info[type].dqi_format = fmt;
 	down(&dqopt->dqio_sem);
-	if ((error = dqopt->ops[type]->read_file_info(sb, type)) < 0) {
+	if ((error = dqopt->ops[type]->read_file_info(hash, type)) < 0) {
 		up(&dqopt->dqio_sem);
 		goto out_file_init;
 	}
@@ -1227,7 +1299,7 @@ int vfs_quota_on(struct super_block *sb,
 	set_enable_flags(dqopt, type);
 	up_write(&dqopt->dqptr_sem);
 
-	add_dquot_ref(sb, type);
+	add_dquot_ref(hash, type);
 	up(&dqopt->dqonoff_sem);
 
 	return 0;
@@ -1264,18 +1336,18 @@ static void do_get_dqblk(struct dquot *d
 	spin_unlock(&dq_data_lock);
 }
 
-int vfs_get_dqblk(struct super_block *sb, int type, qid_t id, struct if_dqblk *di)
+int vfs_get_dqblk(struct dqhash *hash, int type, qid_t id, struct if_dqblk *di)
 {
 	struct dquot *dquot;
 
-	down_read(&sb_dqopt(sb)->dqptr_sem);
-	if (!(dquot = dqget(sb, id, type))) {
-		up_read(&sb_dqopt(sb)->dqptr_sem);
+	down_read(&dqh_dqopt(hash)->dqptr_sem);
+	if (!(dquot = dqget(hash, id, type))) {
+		up_read(&dqh_dqopt(hash)->dqptr_sem);
 		return -ESRCH;
 	}
 	do_get_dqblk(dquot, di);
 	dqput(dquot);
-	up_read(&sb_dqopt(sb)->dqptr_sem);
+	up_read(&dqh_dqopt(hash)->dqptr_sem);
 	return 0;
 }
 
@@ -1315,7 +1387,7 @@ static void do_set_dqblk(struct dquot *d
 			clear_bit(DQ_BLKS_B, &dquot->dq_flags);
 		}
 		else if (!(di->dqb_valid & QIF_BTIME))	/* Set grace only if user hasn't provided his own... */
-			dm->dqb_btime = get_seconds() + sb_dqopt(dquot->dq_sb)->info[dquot->dq_type].dqi_bgrace;
+			dm->dqb_btime = get_seconds() + dqh_dqopt(dquot->dq_dqh)->info[dquot->dq_type].dqi_bgrace;
 	}
 	if (check_ilim) {
 		if (!dm->dqb_isoftlimit || dm->dqb_curinodes < dm->dqb_isoftlimit) {
@@ -1323,7 +1395,7 @@ static void do_set_dqblk(struct dquot *d
 			clear_bit(DQ_INODES_B, &dquot->dq_flags);
 		}
 		else if (!(di->dqb_valid & QIF_ITIME))	/* Set grace only if user hasn't provided his own... */
-			dm->dqb_itime = get_seconds() + sb_dqopt(dquot->dq_sb)->info[dquot->dq_type].dqi_igrace;
+			dm->dqb_itime = get_seconds() + dqh_dqopt(dquot->dq_dqh)->info[dquot->dq_type].dqi_igrace;
 	}
 	if (dm->dqb_bhardlimit || dm->dqb_bsoftlimit || dm->dqb_ihardlimit || dm->dqb_isoftlimit)
 		clear_bit(DQ_FAKE_B, &dquot->dq_flags);
@@ -1333,53 +1405,53 @@ static void do_set_dqblk(struct dquot *d
 	spin_unlock(&dq_data_lock);
 }
 
-int vfs_set_dqblk(struct super_block *sb, int type, qid_t id, struct if_dqblk *di)
+int vfs_set_dqblk(struct dqhash *hash, int type, qid_t id, struct if_dqblk *di)
 {
 	struct dquot *dquot;
 
-	down_read(&sb_dqopt(sb)->dqptr_sem);
-	if (!(dquot = dqget(sb, id, type))) {
-		up_read(&sb_dqopt(sb)->dqptr_sem);
+	down_read(&dqh_dqopt(hash)->dqptr_sem);
+	if (!(dquot = dqget(hash, id, type))) {
+		up_read(&dqh_dqopt(hash)->dqptr_sem);
 		return -ESRCH;
 	}
 	do_set_dqblk(dquot, di);
 	dqput(dquot);
-	up_read(&sb_dqopt(sb)->dqptr_sem);
+	up_read(&dqh_dqopt(hash)->dqptr_sem);
 	return 0;
 }
 
 /* Generic routine for getting common part of quota file information */
-int vfs_get_dqinfo(struct super_block *sb, int type, struct if_dqinfo *ii)
+int vfs_get_dqinfo(struct dqhash *hash, int type, struct if_dqinfo *ii)
 {
 	struct mem_dqinfo *mi;
   
-	down_read(&sb_dqopt(sb)->dqptr_sem);
-	if (!sb_has_quota_enabled(sb, type)) {
-		up_read(&sb_dqopt(sb)->dqptr_sem);
+	down_read(&dqh_dqopt(hash)->dqptr_sem);
+	if (!dqh_has_quota_enabled(hash, type)) {
+		up_read(&dqh_dqopt(hash)->dqptr_sem);
 		return -ESRCH;
 	}
-	mi = sb_dqopt(sb)->info + type;
+	mi = dqh_dqopt(hash)->info + type;
 	spin_lock(&dq_data_lock);
 	ii->dqi_bgrace = mi->dqi_bgrace;
 	ii->dqi_igrace = mi->dqi_igrace;
 	ii->dqi_flags = mi->dqi_flags & DQF_MASK;
 	ii->dqi_valid = IIF_ALL;
 	spin_unlock(&dq_data_lock);
-	up_read(&sb_dqopt(sb)->dqptr_sem);
+	up_read(&dqh_dqopt(hash)->dqptr_sem);
 	return 0;
 }
 
 /* Generic routine for setting common part of quota file information */
-int vfs_set_dqinfo(struct super_block *sb, int type, struct if_dqinfo *ii)
+int vfs_set_dqinfo(struct dqhash *hash, int type, struct if_dqinfo *ii)
 {
 	struct mem_dqinfo *mi;
 
-	down_read(&sb_dqopt(sb)->dqptr_sem);
-	if (!sb_has_quota_enabled(sb, type)) {
-		up_read(&sb_dqopt(sb)->dqptr_sem);
+	down_read(&dqh_dqopt(hash)->dqptr_sem);
+	if (!dqh_has_quota_enabled(hash, type)) {
+		up_read(&dqh_dqopt(hash)->dqptr_sem);
 		return -ESRCH;
 	}
-	mi = sb_dqopt(sb)->info + type;
+	mi = dqh_dqopt(hash)->info + type;
 	spin_lock(&dq_data_lock);
 	if (ii->dqi_valid & IIF_BGRACE)
 		mi->dqi_bgrace = ii->dqi_bgrace;
@@ -1389,7 +1461,7 @@ int vfs_set_dqinfo(struct super_block *s
 		mi->dqi_flags = (mi->dqi_flags & ~DQF_MASK) | (ii->dqi_flags & DQF_MASK);
 	mark_info_dirty(mi);
 	spin_unlock(&dq_data_lock);
-	up_read(&sb_dqopt(sb)->dqptr_sem);
+	up_read(&dqh_dqopt(hash)->dqptr_sem);
 	return 0;
 }
 
@@ -1496,11 +1568,8 @@ kmem_cache_t *dquot_cachep;
 
 static int __init dquot_init(void)
 {
-	int i;
 
 	register_sysctl_table(sys_table, 0);
-	for (i = 0; i < NR_DQHASH; i++)
-		INIT_LIST_HEAD(dquot_hash + i);
 	printk(KERN_NOTICE "VFS: Disk quotas %s\n", __DQUOT_VERSION__);
 
 	dquot_cachep = kmem_cache_create("dquot", 
diff -NurpP --minimal linux-2.6.5/fs/exec.c linux-2.6.5-vs1.9.0pre2/fs/exec.c
--- linux-2.6.5/fs/exec.c	2004-03-11 03:55:25.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/exec.c	2004-04-05 00:55:18.000000000 +0200
@@ -327,7 +327,8 @@ void put_dirty_page(struct task_struct *
 	set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page, prot))));
 	pte_chain = page_add_rmap(page, pte, pte_chain);
 	pte_unmap(pte);
-	tsk->mm->rss++;
+	// tsk->mm->rss++;
+	vx_rsspages_inc(tsk->mm);
 	spin_unlock(&tsk->mm->page_table_lock);
 
 	/* no need for flush_tlb */
@@ -433,7 +434,9 @@ int setup_arg_pages(struct linux_binprm 
 		INIT_LIST_HEAD(&mpnt->shared);
 		mpnt->vm_private_data = (void *) 0;
 		insert_vm_struct(mm, mpnt);
-		mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		// mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(mm, mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
@@ -1110,7 +1113,7 @@ int do_execve(char * filename,
 	bprm.loader = 0;
 	bprm.exec = 0;
 	bprm.security = NULL;
-	bprm.mm = mm_alloc();
+	bprm.mm = mm_alloc(current->vx_info);
 	retval = -ENOMEM;
 	if (!bprm.mm)
 		goto out_file;
diff -NurpP --minimal linux-2.6.5/fs/ext2/ialloc.c linux-2.6.5-vs1.9.0pre2/fs/ext2/ialloc.c
--- linux-2.6.5/fs/ext2/ialloc.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/ext2/ialloc.c	2004-04-05 00:55:13.000000000 +0200
@@ -581,7 +581,7 @@ got:
 	memset(ei->i_data, 0, sizeof(ei->i_data));
 	ei->i_flags = EXT2_I(dir)->i_flags & ~EXT2_BTREE_FL;
 	if (S_ISLNK(mode))
-		ei->i_flags &= ~(EXT2_IMMUTABLE_FL|EXT2_APPEND_FL);
+		ei->i_flags &= ~(EXT2_IMMUTABLE_FL|EXT2_IUNLINK_FL|EXT2_APPEND_FL);
 	/* dirsync is only applied to directories */
 	if (!S_ISDIR(mode))
 		ei->i_flags &= ~EXT2_DIRSYNC_FL;
diff -NurpP --minimal linux-2.6.5/fs/ext2/inode.c linux-2.6.5-vs1.9.0pre2/fs/ext2/inode.c
--- linux-2.6.5/fs/ext2/inode.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/ext2/inode.c	2004-04-05 00:55:19.000000000 +0200
@@ -30,6 +30,7 @@
 #include <linux/module.h>
 #include <linux/buffer_head.h>
 #include <linux/mpage.h>
+#include <linux/vserver/xid.h>
 #include "ext2.h"
 #include "acl.h"
 
@@ -64,6 +65,8 @@ void ext2_put_inode(struct inode *inode)
 		ext2_discard_prealloc(inode);
 }
 
+static void ext2_truncate_nocheck (struct inode * inode);
+
 /*
  * Called at the last iput() if i_nlink is zero.
  */
@@ -77,7 +80,7 @@ void ext2_delete_inode (struct inode * i
 
 	inode->i_size = 0;
 	if (inode->i_blocks)
-		ext2_truncate (inode);
+		ext2_truncate_nocheck(inode);
 	ext2_free_inode (inode);
 
 	return;
@@ -876,7 +879,7 @@ static void ext2_free_branches(struct in
 		ext2_free_data(inode, p, q);
 }
 
-void ext2_truncate (struct inode * inode)
+static void ext2_truncate_nocheck(struct inode * inode)
 {
 	u32 *i_data = EXT2_I(inode)->i_data;
 	int addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);
@@ -893,8 +896,6 @@ void ext2_truncate (struct inode * inode
 		return;
 	if (ext2_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
 
 	ext2_discard_prealloc(inode);
 
@@ -1016,17 +1017,26 @@ Egdp:
 	return ERR_PTR(-EIO);
 }
 
+void ext2_truncate (struct inode * inode)
+{
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return;
+	ext2_truncate_nocheck(inode);
+}
+
 void ext2_set_inode_flags(struct inode *inode)
 {
 	unsigned int flags = EXT2_I(inode)->i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_IUNLINK|S_NOATIME|S_DIRSYNC);
 	if (flags & EXT2_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT2_APPEND_FL)
 		inode->i_flags |= S_APPEND;
 	if (flags & EXT2_IMMUTABLE_FL)
 		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT2_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
 	if (flags & EXT2_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 	if (flags & EXT2_DIRSYNC_FL)
@@ -1039,6 +1049,8 @@ void ext2_read_inode (struct inode * ino
 	ino_t ino = inode->i_ino;
 	struct buffer_head * bh;
 	struct ext2_inode * raw_inode = ext2_get_inode(inode->i_sb, ino, &bh);
+	uid_t uid;
+	gid_t gid;
 	int n;
 
 #ifdef CONFIG_EXT2_FS_POSIX_ACL
@@ -1049,12 +1061,17 @@ void ext2_read_inode (struct inode * ino
  		goto bad_inode;
 
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
-	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
-	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
+	uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
+	gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
 	if (!(test_opt (inode->i_sb, NO_UID32))) {
-		inode->i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
-		inode->i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
+		uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
+		gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
 	}
+	inode->i_uid = INOXID_UID(uid, gid);
+	inode->i_gid = INOXID_GID(uid, gid);
+	if (inode->i_sb->s_flags & MS_TAGXID)
+		inode->i_xid = INOXID_XID(uid, gid, le16_to_cpu(raw_inode->i_raw_xid));
+
 	inode->i_nlink = le16_to_cpu(raw_inode->i_links_count);
 	inode->i_size = le32_to_cpu(raw_inode->i_size);
 	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
@@ -1147,8 +1164,8 @@ static int ext2_update_inode(struct inod
 	struct ext2_inode_info *ei = EXT2_I(inode);
 	struct super_block *sb = inode->i_sb;
 	ino_t ino = inode->i_ino;
-	uid_t uid = inode->i_uid;
-	gid_t gid = inode->i_gid;
+	uid_t uid = XIDINO_UID(inode->i_uid, inode->i_xid);
+	gid_t gid = XIDINO_GID(inode->i_gid, inode->i_xid);
 	struct buffer_head * bh;
 	struct ext2_inode * raw_inode = ext2_get_inode(sb, ino, &bh);
 	int n;
@@ -1183,6 +1200,9 @@ static int ext2_update_inode(struct inod
 		raw_inode->i_uid_high = 0;
 		raw_inode->i_gid_high = 0;
 	}
+#ifdef CONFIG_INOXID_GID32
+	raw_inode->i_raw_xid = cpu_to_le16(inode->i_xid);
+#endif
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
 	raw_inode->i_size = cpu_to_le32(inode->i_size);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
diff -NurpP --minimal linux-2.6.5/fs/ext2/super.c linux-2.6.5-vs1.9.0pre2/fs/ext2/super.c
--- linux-2.6.5/fs/ext2/super.c	2004-03-11 03:55:35.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/ext2/super.c	2004-04-05 00:55:19.000000000 +0200
@@ -270,7 +270,7 @@ enum {
 	Opt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,
 	Opt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic, Opt_err_ro,
 	Opt_nouid32, Opt_check, Opt_nocheck, Opt_debug, Opt_oldalloc, Opt_orlov, Opt_nobh,
-	Opt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl,
+	Opt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl, Opt_tagxid,
 	Opt_ignore, Opt_err,
 };
 
@@ -299,6 +299,7 @@ static match_table_t tokens = {
 	{Opt_nouser_xattr, "nouser_xattr"},
 	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
+	{Opt_tagxid, "tagxid"},
 	{Opt_ignore, "grpquota"},
 	{Opt_ignore, "noquota"},
 	{Opt_ignore, "quota"},
@@ -362,6 +363,11 @@ static int parse_options (char * options
 		case Opt_nouid32:
 			set_opt (sbi->s_mount_opt, NO_UID32);
 			break;
+#ifndef CONFIG_INOXID_NONE
+		case Opt_tagxid:
+			set_opt (sbi->s_mount_opt, TAG_XID);
+			break;
+#endif
 		case Opt_check:
 #ifdef CONFIG_EXT2_CHECK
 			set_opt (sbi->s_mount_opt, CHECK);
@@ -643,6 +649,8 @@ static int ext2_fill_super(struct super_
 	if (!parse_options ((char *) data, sbi))
 		goto failed_mount;
 
+	if (EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_TAG_XID)
+		sb->s_flags |= MS_TAGXID;
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?
 		 MS_POSIXACL : 0);
diff -NurpP --minimal linux-2.6.5/fs/ext3/ialloc.c linux-2.6.5-vs1.9.0pre2/fs/ext3/ialloc.c
--- linux-2.6.5/fs/ext3/ialloc.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/ext3/ialloc.c	2004-04-05 00:55:13.000000000 +0200
@@ -569,7 +569,7 @@ got:
 
 	ei->i_flags = EXT3_I(dir)->i_flags & ~EXT3_INDEX_FL;
 	if (S_ISLNK(mode))
-		ei->i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
+		ei->i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_IUNLINK_FL|EXT3_APPEND_FL);
 	/* dirsync only applies to directories */
 	if (!S_ISDIR(mode))
 		ei->i_flags &= ~EXT3_DIRSYNC_FL;
diff -NurpP --minimal linux-2.6.5/fs/ext3/inode.c linux-2.6.5-vs1.9.0pre2/fs/ext3/inode.c
--- linux-2.6.5/fs/ext3/inode.c	2004-03-11 03:55:35.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/ext3/inode.c	2004-04-05 00:55:19.000000000 +0200
@@ -36,6 +36,7 @@
 #include <linux/writeback.h>
 #include <linux/mpage.h>
 #include <linux/uio.h>
+#include <linux/vserver/xid.h>
 #include "xattr.h"
 #include "acl.h"
 
@@ -189,6 +190,8 @@ void ext3_put_inode(struct inode *inode)
 		ext3_discard_prealloc(inode);
 }
 
+static void ext3_truncate_nocheck (struct inode *inode);
+
 /*
  * Called at the last iput() if i_nlink is zero.
  */
@@ -214,7 +217,7 @@ void ext3_delete_inode (struct inode * i
 		handle->h_sync = 1;
 	inode->i_size = 0;
 	if (inode->i_blocks)
-		ext3_truncate(inode);
+		ext3_truncate_nocheck(inode);
 	/*
 	 * Kill off the orphan record which ext3_truncate created.
 	 * AKPM: I think this can be inside the above `if'.
@@ -2114,7 +2117,7 @@ static void ext3_free_branches(handle_t 
  * ext3_truncate() run will find them and release them.
  */
 
-void ext3_truncate(struct inode * inode)
+void ext3_truncate_nocheck(struct inode * inode)
 {
 	handle_t *handle;
 	struct ext3_inode_info *ei = EXT3_I(inode);
@@ -2135,8 +2138,6 @@ void ext3_truncate(struct inode * inode)
 		return;
 	if (ext3_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
 
 	ext3_discard_prealloc(inode);
 
@@ -2443,17 +2444,26 @@ has_buffer:
 	return 0;
 }
 
+void ext3_truncate(struct inode * inode)
+{
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return;
+	ext3_truncate_nocheck(inode);
+}
+
 void ext3_set_inode_flags(struct inode *inode)
 {
 	unsigned int flags = EXT3_I(inode)->i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
+	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_IUNLINK|S_NOATIME|S_DIRSYNC);
 	if (flags & EXT3_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT3_APPEND_FL)
 		inode->i_flags |= S_APPEND;
 	if (flags & EXT3_IMMUTABLE_FL)
 		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT3_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
 	if (flags & EXT3_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 	if (flags & EXT3_DIRSYNC_FL)
@@ -2467,6 +2477,8 @@ void ext3_read_inode(struct inode * inod
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh;
 	int block;
+	uid_t uid;
+	gid_t gid;
 
 #ifdef CONFIG_EXT3_FS_POSIX_ACL
 	ei->i_acl = EXT3_ACL_NOT_CACHED;
@@ -2477,12 +2489,17 @@ void ext3_read_inode(struct inode * inod
 	bh = iloc.bh;
 	raw_inode = ext3_raw_inode(&iloc);
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
-	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
-	inode->i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
+	uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
+	gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);
 	if(!(test_opt (inode->i_sb, NO_UID32))) {
-		inode->i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
-		inode->i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
+		uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
+		gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
 	}
+	inode->i_uid = INOXID_UID(uid, gid);
+	inode->i_gid = INOXID_GID(uid, gid);
+	if (inode->i_sb->s_flags & MS_TAGXID)
+		inode->i_xid = INOXID_XID(uid, gid, le16_to_cpu(raw_inode->i_raw_xid));
+
 	inode->i_nlink = le16_to_cpu(raw_inode->i_links_count);
 	inode->i_size = le32_to_cpu(raw_inode->i_size);
 	inode->i_atime.tv_sec = le32_to_cpu(raw_inode->i_atime);
@@ -2590,6 +2607,8 @@ static int ext3_do_update_inode(handle_t
 	struct ext3_inode *raw_inode = ext3_raw_inode(iloc);
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	struct buffer_head *bh = iloc->bh;
+	uid_t uid = XIDINO_UID(inode->i_uid, inode->i_xid);
+	gid_t gid = XIDINO_GID(inode->i_gid, inode->i_xid);
 	int err = 0, rc, block;
 
 	/* For fields not not tracking in the in-memory inode,
@@ -2599,29 +2618,32 @@ static int ext3_do_update_inode(handle_t
 
 	raw_inode->i_mode = cpu_to_le16(inode->i_mode);
 	if(!(test_opt(inode->i_sb, NO_UID32))) {
-		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(inode->i_uid));
-		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(inode->i_gid));
+		raw_inode->i_uid_low = cpu_to_le16(low_16_bits(uid));
+		raw_inode->i_gid_low = cpu_to_le16(low_16_bits(gid));
 /*
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
 		if(!ei->i_dtime) {
 			raw_inode->i_uid_high =
-				cpu_to_le16(high_16_bits(inode->i_uid));
+				cpu_to_le16(high_16_bits(uid));
 			raw_inode->i_gid_high =
-				cpu_to_le16(high_16_bits(inode->i_gid));
+				cpu_to_le16(high_16_bits(gid));
 		} else {
 			raw_inode->i_uid_high = 0;
 			raw_inode->i_gid_high = 0;
 		}
 	} else {
 		raw_inode->i_uid_low =
-			cpu_to_le16(fs_high2lowuid(inode->i_uid));
+			cpu_to_le16(fs_high2lowuid(uid));
 		raw_inode->i_gid_low =
-			cpu_to_le16(fs_high2lowgid(inode->i_gid));
+			cpu_to_le16(fs_high2lowgid(gid));
 		raw_inode->i_uid_high = 0;
 		raw_inode->i_gid_high = 0;
 	}
+#ifdef CONFIG_INOXID_GID32
+	raw_inode->i_raw_xid = cpu_to_le16(inode->i_xid);
+#endif
 	raw_inode->i_links_count = cpu_to_le16(inode->i_nlink);
 	raw_inode->i_size = cpu_to_le32(ei->i_disksize);
 	raw_inode->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
diff -NurpP --minimal linux-2.6.5/fs/ext3/ioctl.c linux-2.6.5-vs1.9.0pre2/fs/ext3/ioctl.c
--- linux-2.6.5/fs/ext3/ioctl.c	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/ext3/ioctl.c	2004-04-05 00:55:19.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/ext3_fs.h>
 #include <linux/ext3_jbd.h>
 #include <linux/time.h>
+#include <linux/vserver/xid.h>
 #include <asm/uaccess.h>
 
 
@@ -151,6 +152,38 @@ flags_err:
 			return ret;
 		}
 #endif
+#ifndef CONFIG_INOXID_NONE
+	case EXT3_IOC_SETXID: {
+		handle_t *handle;
+		struct ext3_iloc iloc;
+		int xid;
+		int err;
+
+		/* fixme: if stealth, return -ENOTTY */
+		if (!capable(CAP_CONTEXT))
+			return -EPERM;
+		if (IS_RDONLY(inode))
+			return -EROFS;
+		if (!(inode->i_sb->s_flags & MS_TAGXID))
+			return -ENOSYS;
+		if (get_user(xid, (int *) arg))
+			return -EFAULT;	
+
+		handle = ext3_journal_start(inode, 1);
+		if (IS_ERR(handle))
+			return PTR_ERR(handle);
+		err = ext3_reserve_inode_write(handle, inode, &iloc);
+		if (err)
+			return err;
+
+		inode->i_xid = (xid & 0xFFFF);
+		inode->i_ctime = CURRENT_TIME;
+
+		err = ext3_mark_iloc_dirty(handle, inode, &iloc);
+		ext3_journal_stop(handle);
+		return err;
+	}
+#endif
 	default:
 		return -ENOTTY;
 	}
diff -NurpP --minimal linux-2.6.5/fs/ext3/super.c linux-2.6.5-vs1.9.0pre2/fs/ext3/super.c
--- linux-2.6.5/fs/ext3/super.c	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/ext3/super.c	2004-04-05 00:55:19.000000000 +0200
@@ -536,7 +536,7 @@ enum {
 	Opt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl, Opt_noload,
 	Opt_commit, Opt_journal_update, Opt_journal_inum,
 	Opt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,
-	Opt_ignore, Opt_err,
+	Opt_tagxid, Opt_ignore, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -571,6 +571,7 @@ static match_table_t tokens = {
 	{Opt_data_journal, "data=journal"},
 	{Opt_data_ordered, "data=ordered"},
 	{Opt_data_writeback, "data=writeback"},
+	{Opt_tagxid, "tagxid"},
 	{Opt_ignore, "grpquota"},
 	{Opt_ignore, "noquota"},
 	{Opt_ignore, "quota"},
@@ -660,6 +661,11 @@ static int parse_options (char * options
 		case Opt_nouid32:
 			set_opt (sbi->s_mount_opt, NO_UID32);
 			break;
+#ifndef CONFIG_INOXID_NONE
+		case Opt_tagxid:
+			set_opt (sbi->s_mount_opt, TAG_XID);
+			break;
+#endif
 		case Opt_check:
 #ifdef CONFIG_EXT3_CHECK
 			set_opt (sbi->s_mount_opt, CHECK);
@@ -1120,6 +1126,8 @@ static int ext3_fill_super (struct super
 	if (!parse_options ((char *) data, sbi, &journal_inum, 0))
 		goto failed_mount;
 
+	if (EXT3_SB(sb)->s_mount_opt & EXT3_MOUNT_TAG_XID)
+		sb->s_flags |= MS_TAGXID;
 	sb->s_flags |= MS_ONE_SECOND;
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		((sbi->s_mount_opt & EXT3_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
@@ -1296,7 +1304,8 @@ static int ext3_fill_super (struct super
 	 */
 	sb->s_op = &ext3_sops;
 	sb->s_export_op = &ext3_export_ops;
-	sb->dq_op = &ext3_qops;
+	if (sb->s_dqh)
+		sb->s_dqh->dqh_qop = &ext3_qops;
 	INIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */
 
 	sb->s_root = 0;
@@ -1965,7 +1974,7 @@ static int ext3_write_dquot(struct dquot
 	int ret;
 	int err;
 	handle_t *handle;
-	struct quota_info *dqops = sb_dqopt(dquot->dq_sb);
+	struct quota_info *dqops = dqh_dqopt(dquot->dq_dqh);
 	struct inode *qinode;
 
 	switch (dqops->info[dquot->dq_type].dqi_format->qf_fmt_id) {
diff -NurpP --minimal linux-2.6.5/fs/file_table.c linux-2.6.5-vs1.9.0pre2/fs/file_table.c
--- linux-2.6.5/fs/file_table.c	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/file_table.c	2004-04-05 00:55:18.000000000 +0200
@@ -68,6 +68,8 @@ struct file *get_empty_filp(void)
 static int old_max;
 	struct file * f;
 
+	if (!vx_files_avail(1))
+		return NULL;
 	/*
 	 * Privileged users can go above max_files
 	 */
@@ -82,6 +84,7 @@ static int old_max;
 			}
 			eventpoll_init_file(f);
 			atomic_set(&f->f_count, 1);
+			vx_files_inc(f);
 			f->f_uid = current->fsuid;
 			f->f_gid = current->fsgid;
 			f->f_owner.lock = RW_LOCK_UNLOCKED;
@@ -187,6 +190,7 @@ void fastcall __fput(struct file *file)
 	file_kill(file);
 	file->f_dentry = NULL;
 	file->f_vfsmnt = NULL;
+	vx_files_dec(file);
 	file_free(file);
 	dput(dentry);
 	mntput(mnt);
diff -NurpP --minimal linux-2.6.5/fs/inode.c linux-2.6.5-vs1.9.0pre2/fs/inode.c
--- linux-2.6.5/fs/inode.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/inode.c	2004-04-05 00:55:19.000000000 +0200
@@ -114,6 +114,11 @@ static struct inode *alloc_inode(struct 
 		struct address_space * const mapping = &inode->i_data;
 
 		inode->i_sb = sb;
+		if (sb->s_flags & MS_TAGXID)
+			inode->i_xid = current->xid;
+		else
+			inode->i_xid = 0;       /* maybe xid -1 would be better? */
+		inode->i_dqh = dqhget(sb->s_dqh);
 		inode->i_blkbits = sb->s_blocksize_bits;
 		inode->i_flags = 0;
 		atomic_set(&inode->i_count, 1);
@@ -131,6 +136,7 @@ static struct inode *alloc_inode(struct 
 		inode->i_bdev = NULL;
 		inode->i_cdev = NULL;
 		inode->i_rdev = 0;
+		// inode->i_xid = 0;	/* maybe not too wise ... */
 		inode->i_security = NULL;
 		inode->dirtied_when = 0;
 		if (security_inode_alloc(inode)) {
@@ -160,6 +166,8 @@ void destroy_inode(struct inode *inode) 
 	if (inode_has_buffers(inode))
 		BUG();
 	security_inode_free(inode);
+	if (dqhash_valid(inode->i_dqh))
+		dqhput(inode->i_dqh);
 	if (inode->i_sb->s_op->destroy_inode)
 		inode->i_sb->s_op->destroy_inode(inode);
 	else
@@ -1220,40 +1228,42 @@ EXPORT_SYMBOL(inode_needs_sync);
 void put_dquot_list(struct list_head *);
 int remove_inode_dquot_ref(struct inode *, int, struct list_head *);
 
-void remove_dquot_ref(struct super_block *sb, int type)
+void remove_dquot_ref(struct dqhash *hash, int type)
 {
 	struct inode *inode;
 	struct list_head *act_head;
+	struct super_block *sb = hash->dqh_sb;
 	LIST_HEAD(tofree_head);
 
-	if (!sb->dq_op)
+	if (!hash->dqh_qop)
 		return;	/* nothing to do */
 	spin_lock(&inode_lock);	/* This lock is for inodes code */
 	/* We don't have to lock against quota code - test IS_QUOTAINIT is just for speedup... */
  
 	list_for_each(act_head, &inode_in_use) {
 		inode = list_entry(act_head, struct inode, i_list);
-		if (inode->i_sb == sb && IS_QUOTAINIT(inode))
+		if (inode->i_dqh == hash && IS_QUOTAINIT(inode))
 			remove_inode_dquot_ref(inode, type, &tofree_head);
 	}
 	list_for_each(act_head, &inode_unused) {
 		inode = list_entry(act_head, struct inode, i_list);
-		if (inode->i_sb == sb && IS_QUOTAINIT(inode))
+		if (inode->i_dqh == hash && IS_QUOTAINIT(inode))
 			remove_inode_dquot_ref(inode, type, &tofree_head);
 	}
 	list_for_each(act_head, &sb->s_dirty) {
 		inode = list_entry(act_head, struct inode, i_list);
-		if (IS_QUOTAINIT(inode))
+		if (inode->i_dqh == hash && IS_QUOTAINIT(inode))
 			remove_inode_dquot_ref(inode, type, &tofree_head);
 	}
 	list_for_each(act_head, &sb->s_io) {
 		inode = list_entry(act_head, struct inode, i_list);
-		if (IS_QUOTAINIT(inode))
+		if (inode->i_dqh == hash && IS_QUOTAINIT(inode))
 			remove_inode_dquot_ref(inode, type, &tofree_head);
 	}
 	spin_unlock(&inode_lock);
 
 	put_dquot_list(&tofree_head);
+	dqhput(hash); /* is this required? */
 }
 
 #endif
diff -NurpP --minimal linux-2.6.5/fs/ioctl.c linux-2.6.5-vs1.9.0pre2/fs/ioctl.c
--- linux-2.6.5/fs/ioctl.c	2004-03-11 03:55:23.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/ioctl.c	2004-04-05 00:55:19.000000000 +0200
@@ -9,10 +9,16 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/security.h>
+#include <linux/proc_fs.h>
+#include <linux/vserver/inode.h>
+#include <linux/vserver/xid.h>
 
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+extern int vx_proc_ioctl(struct inode *, struct file *,
+	unsigned int, unsigned long);
+
 static int file_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
 {
 	int error;
@@ -119,6 +125,46 @@ asmlinkage long sys_ioctl(unsigned int f
 			else
 				error = -ENOTTY;
 			break;
+#ifndef CONFIG_INOXID_NONE
+		case FIOC_GETXID: {
+			struct inode *inode = filp->f_dentry->d_inode;
+
+			/* fixme: if stealth, return -ENOTTY */
+			error = -EPERM;
+			if (capable(CAP_CONTEXT))
+				error = put_user(inode->i_xid, (int *) arg);
+			break;
+		}
+		case FIOC_SETXID: {
+			struct inode *inode = filp->f_dentry->d_inode;
+			int xid;
+
+			/* fixme: if stealth, return -ENOTTY */
+			error = -EPERM;
+			if (!capable(CAP_CONTEXT))
+				break;
+			error = -EROFS;
+			if (IS_RDONLY(inode))
+				break;
+			error = -ENOSYS;
+			if (!(inode->i_sb->s_flags & MS_TAGXID))
+				break;
+			error = -EFAULT;
+			if (get_user(xid, (int *) arg))
+				break;
+			error = 0;
+			inode->i_xid = (xid & 0xFFFF);
+			inode->i_ctime = CURRENT_TIME;
+			mark_inode_dirty(inode);
+			break;	
+		}
+#endif
+		case FIOC_GETXFLG:
+		case FIOC_SETXFLG:
+			error = -ENOTTY;
+			if (filp->f_dentry->d_inode->i_sb->s_magic == PROC_SUPER_MAGIC)
+				error = vx_proc_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+			break;
 		default:
 			error = -ENOTTY;
 			if (S_ISREG(filp->f_dentry->d_inode->i_mode))
diff -NurpP --minimal linux-2.6.5/fs/jfs/jfs_imap.c linux-2.6.5-vs1.9.0pre2/fs/jfs/jfs_imap.c
--- linux-2.6.5/fs/jfs/jfs_imap.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/jfs/jfs_imap.c	2004-04-05 00:55:19.000000000 +0200
@@ -44,6 +44,7 @@
 #include <linux/fs.h>
 #include <linux/buffer_head.h>
 #include <linux/pagemap.h>
+#include <linux/vserver/xid.h>
 
 #include "jfs_incore.h"
 #include "jfs_filsys.h"
@@ -3098,14 +3099,21 @@ static void duplicateIXtree(struct super
 static int copy_from_dinode(struct dinode * dip, struct inode *ip)
 {
 	struct jfs_inode_info *jfs_ip = JFS_IP(ip);
+	uid_t uid;
+	gid_t gid;
 
 	jfs_ip->fileset = le32_to_cpu(dip->di_fileset);
 	jfs_ip->mode2 = le32_to_cpu(dip->di_mode);
 
 	ip->i_mode = le32_to_cpu(dip->di_mode) & 0xffff;
 	ip->i_nlink = le32_to_cpu(dip->di_nlink);
-	ip->i_uid = le32_to_cpu(dip->di_uid);
-	ip->i_gid = le32_to_cpu(dip->di_gid);
+
+	uid = le32_to_cpu(dip->di_uid);
+	gid = le32_to_cpu(dip->di_gid);
+	ip->i_uid = INOXID_UID(uid, gid);
+	ip->i_gid = INOXID_GID(uid, gid);
+	ip->i_xid = INOXID_XID(uid, gid, 0);
+	
 	ip->i_size = le64_to_cpu(dip->di_size);
 	ip->i_atime.tv_sec = le32_to_cpu(dip->di_atime.tv_sec);
 	ip->i_atime.tv_nsec = le32_to_cpu(dip->di_atime.tv_nsec);
@@ -3156,6 +3164,8 @@ static int copy_from_dinode(struct dinod
 static void copy_to_dinode(struct dinode * dip, struct inode *ip)
 {
 	struct jfs_inode_info *jfs_ip = JFS_IP(ip);
+	uid_t uid;
+	gid_t gid;
 
 	dip->di_fileset = cpu_to_le32(jfs_ip->fileset);
 	dip->di_inostamp = cpu_to_le32(JFS_SBI(ip->i_sb)->inostamp);
@@ -3164,8 +3174,11 @@ static void copy_to_dinode(struct dinode
 	dip->di_size = cpu_to_le64(ip->i_size);
 	dip->di_nblocks = cpu_to_le64(PBLK2LBLK(ip->i_sb, ip->i_blocks));
 	dip->di_nlink = cpu_to_le32(ip->i_nlink);
-	dip->di_uid = cpu_to_le32(ip->i_uid);
-	dip->di_gid = cpu_to_le32(ip->i_gid);
+
+	uid = XIDINO_UID(ip->i_uid, ip->i_xid);
+	gid = XIDINO_GID(ip->i_gid, ip->i_xid);
+	dip->di_uid = cpu_to_le32(uid);
+	dip->di_gid = cpu_to_le32(gid);
 	/*
 	 * mode2 is only needed for storing the higher order bits.
 	 * Trust i_mode for the lower order ones
diff -NurpP --minimal linux-2.6.5/fs/namei.c linux-2.6.5-vs1.9.0pre2/fs/namei.c
--- linux-2.6.5/fs/namei.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/namei.c	2004-04-05 00:55:19.000000000 +0200
@@ -160,6 +160,10 @@ int vfs_permission(struct inode * inode,
 {
 	umode_t			mode = inode->i_mode;
 
+	if (IS_BARRIER(inode) && S_ISDIR(mode) &&
+		!vx_check(0, VX_ADMIN|VX_WATCH))
+		return -EACCES;
+
 	if (mask & MAY_WRITE) {
 		/*
 		 * Nobody gets write access to a read-only fs.
@@ -205,6 +209,15 @@ int vfs_permission(struct inode * inode,
 	return -EACCES;
 }
 
+static inline int xid_permission(struct inode *inode)
+{
+	if (inode->i_xid == 0)
+		return 0;
+	if (vx_check(inode->i_xid, VX_ADMIN|VX_WATCH|VX_IDENT))
+		return 0;
+	return -EACCES;
+}
+
 int permission(struct inode * inode,int mask, struct nameidata *nd)
 {
 	int retval;
@@ -213,6 +226,8 @@ int permission(struct inode * inode,int 
 	/* Ordinary permission routines do not understand MAY_APPEND. */
 	submask = mask & ~MAY_APPEND;
 
+	if ((retval = xid_permission(inode)))
+		return retval;
 	if (inode->i_op && inode->i_op->permission)
 		retval = inode->i_op->permission(inode, submask, nd);
 	else
@@ -1028,7 +1043,7 @@ static inline int may_delete(struct inod
 	if (IS_APPEND(dir))
 		return -EPERM;
 	if (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||
-	    IS_IMMUTABLE(victim->d_inode))
+		IS_IXORUNLINK(victim->d_inode))
 		return -EPERM;
 	if (isdir) {
 		if (!S_ISDIR(victim->d_inode->i_mode))
@@ -1223,6 +1238,8 @@ int may_open(struct nameidata *nd, int a
 		if (flag & FMODE_WRITE)
 			DQUOT_INIT(inode);
 
+	if ((flag & FMODE_WRITE) || (flag & O_TRUNC))
+		vx_dq_cond_modify(inode, current->xid);
 	return 0;
 }
 
@@ -1298,6 +1315,8 @@ do_last:
 
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
+		/* we might reconsider that later */
+		vx_dq_cond_modify(dir->d_inode, current->xid);
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
 		error = vfs_create(dir->d_inode, dentry, mode, nd);
@@ -1680,9 +1699,15 @@ int vfs_unlink(struct inode *dir, struct
 	if (d_mountpoint(dentry))
 		error = -EBUSY;
 	else {
+		struct inode *in;
+
 		error = security_inode_unlink(dir, dentry);
+		in = igrab(dentry->d_inode);
 		if (!error)
 			error = dir->i_op->unlink(dir, dentry);
+		if (!error && in)
+			vx_dq_unlink(in);
+		iput(in);
 	}
 	up(&dentry->d_inode->i_sem);
 
@@ -1822,7 +1847,7 @@ int vfs_link(struct dentry *old_dentry, 
 	/*
 	 * A link to an append-only or immutable file cannot be created.
 	 */
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+	if (IS_APPEND(inode) || IS_IXORUNLINK(inode))
 		return -EPERM;
 	if (!dir->i_op || !dir->i_op->link)
 		return -EPERM;
diff -NurpP --minimal linux-2.6.5/fs/namespace.c linux-2.6.5-vs1.9.0pre2/fs/namespace.c
--- linux-2.6.5/fs/namespace.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/namespace.c	2004-04-05 00:55:18.000000000 +0200
@@ -224,6 +224,9 @@ static int show_vfsmnt(struct seq_file *
 	};
 	struct proc_fs_info *fs_infop;
 
+	if (vx_flags(VXF_HIDE_MOUNT, 0))
+		return 0;
+
 	mangle(m, mnt->mnt_devname ? mnt->mnt_devname : "none");
 	seq_putc(m, ' ');
 	seq_path(m, mnt, mnt->mnt_root, " \t\n\\");
@@ -265,18 +268,10 @@ int may_umount(struct vfsmount *mnt)
 
 EXPORT_SYMBOL(may_umount);
 
-void umount_tree(struct vfsmount *mnt)
+static inline void __umount_tree(struct vfsmount *mnt, struct list_head *kill)
 {
-	struct vfsmount *p;
-	LIST_HEAD(kill);
-
-	for (p = mnt; p; p = next_mnt(p, mnt)) {
-		list_del(&p->mnt_list);
-		list_add(&p->mnt_list, &kill);
-	}
-
-	while (!list_empty(&kill)) {
-		mnt = list_entry(kill.next, struct vfsmount, mnt_list);
+	while (!list_empty(kill)) {
+		mnt = list_entry(kill->next, struct vfsmount, mnt_list);
 		list_del_init(&mnt->mnt_list);
 		if (mnt->mnt_parent == mnt) {
 			spin_unlock(&vfsmount_lock);
@@ -291,6 +286,32 @@ void umount_tree(struct vfsmount *mnt)
 	}
 }
 
+void umount_tree(struct vfsmount *mnt)
+{
+	struct vfsmount *p;
+	LIST_HEAD(kill);
+
+	for (p = mnt; p; p = next_mnt(p, mnt)) {
+		list_del(&p->mnt_list);
+		list_add(&p->mnt_list, &kill);
+	}
+	__umount_tree(mnt, &kill);
+}
+
+void umount_unused(struct vfsmount *mnt, struct fs_struct *fs)
+{
+	struct vfsmount *p;
+	LIST_HEAD(kill);
+
+	for (p = mnt; p; p = next_mnt(p, mnt)) {
+		if (p == fs->rootmnt || p == fs->pwdmnt)
+			continue;
+		list_del(&p->mnt_list);
+		list_add(&p->mnt_list, &kill);
+	}
+	__umount_tree(mnt, &kill);
+}
+
 static int do_umount(struct vfsmount *mnt, int flags)
 {
 	struct super_block * sb = mnt->mnt_sb;
@@ -346,7 +367,7 @@ static int do_umount(struct vfsmount *mn
 		/* last instance - try to be smart */
 		spin_unlock(&vfsmount_lock);
 		lock_kernel();
-		DQUOT_OFF(sb);
+		DQUOT_OFF(sb->s_dqh);
 		acct_auto_close(sb);
 		unlock_kernel();
 		security_sb_umount_close(mnt);
@@ -388,7 +409,7 @@ asmlinkage long sys_umount(char __user *
 		goto dput_and_out;
 
 	retval = -EPERM;
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) && !vx_ccaps(VXC_SECURE_MOUNT))
 		goto dput_and_out;
 
 	retval = do_umount(nd.mnt, flags);
@@ -411,6 +432,8 @@ static int mount_is_safe(struct nameidat
 {
 	if (capable(CAP_SYS_ADMIN))
 		return 0;
+	if (vx_ccaps(VXC_SECURE_MOUNT))
+		return 0;
 	return -EPERM;
 #ifdef notyet
 	if (S_ISLNK(nd->dentry->d_inode->i_mode))
@@ -771,6 +794,9 @@ long do_mount(char * dev_name, char * di
 		mnt_flags |= MNT_NOEXEC;
 	flags &= ~(MS_NOSUID|MS_NOEXEC|MS_NODEV);
 
+	if (vx_ccaps(VXC_SECURE_MOUNT))
+		mnt_flags |= MNT_NODEV;
+
 	/* ... and get the mountpoint */
 	retval = path_lookup(dir_name, LOOKUP_FOLLOW, &nd);
 	if (retval)
diff -NurpP --minimal linux-2.6.5/fs/nfs/nfsroot.c linux-2.6.5-vs1.9.0pre2/fs/nfs/nfsroot.c
--- linux-2.6.5/fs/nfs/nfsroot.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/nfs/nfsroot.c	2004-04-05 00:55:13.000000000 +0200
@@ -230,7 +230,7 @@ static int __init root_nfs_name(char *na
 	/* Override them by options set on kernel command-line */
 	root_nfs_parse(name, buf);
 
-	cp = system_utsname.nodename;
+	cp = vx_new_uts(nodename);
 	if (strlen(buf) + strlen(cp) > NFS_MAXPATHLEN) {
 		printk(KERN_ERR "Root-NFS: Pathname for remote directory too long.\n");
 		return -1;
diff -NurpP --minimal linux-2.6.5/fs/open.c linux-2.6.5-vs1.9.0pre2/fs/open.c
--- linux-2.6.5/fs/open.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/open.c	2004-04-05 00:55:19.000000000 +0200
@@ -22,6 +22,7 @@
 #include <asm/uaccess.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
+#include <linux/vserver/xid.h>
 
 int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
 {
@@ -594,6 +595,10 @@ asmlinkage long sys_fchmod(unsigned int 
 	dentry = file->f_dentry;
 	inode = dentry->d_inode;
 
+	err = -EPERM;
+	if (S_ISDIR(inode->i_mode) &&
+		IS_BARRIER(inode) && !vx_check(0, VX_ADMIN))
+		goto out_putf;
 	err = -EROFS;
 	if (IS_RDONLY(inode))
 		goto out_putf;
@@ -626,6 +631,11 @@ asmlinkage long sys_chmod(const char __u
 		goto out;
 	inode = nd.dentry->d_inode;
 
+	error = -EPERM;
+	if (S_ISDIR(inode->i_mode) &&
+		IS_BARRIER(inode) && !vx_check(0, VX_ADMIN))
+		goto dput_and_out;
+
 	error = -EROFS;
 	if (IS_RDONLY(inode))
 		goto dput_and_out;
@@ -665,6 +675,8 @@ static int chown_common(struct dentry * 
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
+	if ((user > MAX_UID) || (group > MAX_GID))
+		goto out;
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		newattrs.ia_valid |= ATTR_UID;
diff -NurpP --minimal linux-2.6.5/fs/proc/Makefile linux-2.6.5-vs1.9.0pre2/fs/proc/Makefile
--- linux-2.6.5/fs/proc/Makefile	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/Makefile	2004-04-05 00:55:13.000000000 +0200
@@ -8,7 +8,7 @@ proc-y			:= task_nommu.o
 proc-$(CONFIG_MMU)	:= task_mmu.o
 
 proc-y       += inode.o root.o base.o generic.o array.o \
-		kmsg.o proc_tty.o proc_misc.o
+		kmsg.o proc_tty.o proc_misc.o virtual.o
 
 proc-$(CONFIG_PROC_KCORE)	+= kcore.o
 proc-$(CONFIG_PROC_DEVICETREE)	+= proc_devtree.o
diff -NurpP --minimal linux-2.6.5/fs/proc/array.c linux-2.6.5-vs1.9.0pre2/fs/proc/array.c
--- linux-2.6.5/fs/proc/array.c	2004-03-11 03:55:33.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/array.c	2004-04-05 00:55:13.000000000 +0200
@@ -128,7 +128,8 @@ static const char *task_state_array[] = 
 	"D (disk sleep)",	/*  2 */
 	"T (stopped)",		/*  4 */
 	"Z (zombie)",		/*  8 */
-	"X (dead)"		/* 16 */
+	"X (dead)",		/* 16 */
+	"H (on hold)"		/* 32 */
 };
 
 static inline const char * get_task_state(struct task_struct *tsk)
@@ -137,7 +138,8 @@ static inline const char * get_task_stat
 					   TASK_INTERRUPTIBLE |
 					   TASK_UNINTERRUPTIBLE |
 					   TASK_ZOMBIE |
-					   TASK_STOPPED);
+					   TASK_STOPPED |
+					   TASK_ONHOLD);
 	const char **p = &task_state_array[0];
 
 	while (state) {
@@ -150,8 +152,13 @@ static inline const char * get_task_stat
 static inline char * task_state(struct task_struct *p, char *buffer)
 {
 	int g;
-
+	pid_t ppid;
 	read_lock(&tasklist_lock);
+	ppid = p->real_parent->pid;
+	if (ppid != 0
+		&& current->vx_info
+		&& current->vx_info->vx_initpid == ppid)
+		ppid = 1;
 	buffer += sprintf(buffer,
 		"State:\t%s\n"
 		"SleepAVG:\t%lu%%\n"
@@ -164,7 +171,7 @@ static inline char * task_state(struct t
 		get_task_state(p),
 		(p->sleep_avg/1024)*100/(1000000000/1024),
 	       	p->tgid,
-		p->pid, p->pid ? p->real_parent->pid : 0,
+		p->pid, p->pid ? ppid : 0,
 		p->pid && p->ptrace ? p->parent->pid : 0,
 		p->uid, p->euid, p->suid, p->fsuid,
 		p->gid, p->egid, p->sgid, p->fsgid);
@@ -275,6 +282,8 @@ extern char *task_mem(struct mm_struct *
 int proc_pid_status(struct task_struct *task, char * buffer)
 {
 	char * orig = buffer;
+	struct vx_info *vxi;
+	struct ip_info *ipi;
 	struct mm_struct *mm = get_task_mm(task);
 
 	buffer = task_name(task, buffer);
@@ -286,6 +295,39 @@ int proc_pid_status(struct task_struct *
 	}
 	buffer = task_sig(task, buffer);
 	buffer = task_cap(task, buffer);
+
+	buffer += sprintf (buffer,"s_context: %d\n", vx_task_xid(task));
+	vxi = task_get_vx_info(task);
+	if (vxi) {
+		buffer += sprintf (buffer,"ctxflags: %08llx\n"
+			,vxi->vx_flags);
+		buffer += sprintf (buffer,"initpid: %d\n"
+			,vxi->vx_initpid);
+	} else {
+		buffer += sprintf (buffer,"ctxflags: none\n");
+		buffer += sprintf (buffer,"initpid: none\n");
+	}
+	put_vx_info(vxi);
+	ipi = task_get_ip_info(task);
+	if (ipi) {
+		int i;
+
+		buffer += sprintf (buffer,"ipv4root:");
+		for (i=0; i<ipi->nbipv4; i++){
+			buffer += sprintf (buffer," %08x/%08x"
+				,ipi->ipv4[i]
+				,ipi->mask[i]);
+		}
+		*buffer++ = '\n';
+		buffer += sprintf (buffer,"ipv4root_bcast: %08x\n"
+			,ipi->v4_bcast);
+		buffer += sprintf (buffer,"ipv4root_refcnt: %d\n"
+			,atomic_read(&ipi->ip_refcount));
+	} else {
+		buffer += sprintf (buffer,"ipv4root: 0\n");
+		buffer += sprintf (buffer,"ipv4root_bcast: 0\n");
+	}
+	put_ip_info(ipi);
 #if defined(CONFIG_ARCH_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
@@ -296,7 +338,7 @@ extern unsigned long task_vsize(struct m
 int proc_pid_stat(struct task_struct *task, char * buffer)
 {
 	unsigned long vsize, eip, esp, wchan;
-	long priority, nice;
+	long priority, nice, bias_jiffies;
 	int tty_pgrp = -1, tty_nr = 0;
 	sigset_t sigign, sigcatch;
 	char state;
@@ -307,7 +349,12 @@ int proc_pid_stat(struct task_struct *ta
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
+	bias_jiffies = INITIAL_JIFFIES;
+
 	task_lock(task);
+	if (task->vx_info)
+		bias_jiffies = task->vx_info->cvirt.bias_jiffies;
+
 	mm = task->mm;
 	if(mm)
 		mm = mmgrab(mm);
@@ -370,7 +417,7 @@ int proc_pid_stat(struct task_struct *ta
 		num_threads,
 		jiffies_to_clock_t(task->it_real_value),
 		(unsigned long long)
-		    jiffies_64_to_clock_t(task->start_time - INITIAL_JIFFIES),
+		    jiffies_64_to_clock_t(task->start_time - bias_jiffies),
 		vsize,
 		mm ? mm->rss : 0, /* you might want to shift this left 3 */
 		task->rlim[RLIMIT_RSS].rlim_cur,
diff -NurpP --minimal linux-2.6.5/fs/proc/base.c linux-2.6.5-vs1.9.0pre2/fs/proc/base.c
--- linux-2.6.5/fs/proc/base.c	2004-03-11 03:55:34.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/base.c	2004-04-05 00:55:13.000000000 +0200
@@ -67,6 +67,7 @@ enum pid_directory_inos {
 	PROC_TGID_ATTR_EXEC,
 	PROC_TGID_ATTR_FSCREATE,
 #endif
+	PROC_TGID_VINFO,
 	PROC_TGID_FD_DIR,
 	PROC_TID_INO,
 	PROC_TID_STATUS,
@@ -90,6 +91,7 @@ enum pid_directory_inos {
 	PROC_TID_ATTR_EXEC,
 	PROC_TID_ATTR_FSCREATE,
 #endif
+	PROC_TID_VINFO,
 	PROC_TID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 };
 
@@ -123,6 +125,7 @@ static struct pid_entry tgid_base_stuff[
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TGID_WCHAN,     "wchan",   S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TGID_VINFO,     "vinfo",   S_IFREG|S_IRUGO),
 	{0,0,NULL,0}
 };
 static struct pid_entry tid_base_stuff[] = {
@@ -145,6 +148,7 @@ static struct pid_entry tid_base_stuff[]
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TID_WCHAN,      "wchan",   S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TID_VINFO,      "vinfo",   S_IFREG|S_IRUGO),
 	{0,0,NULL,0}
 };
 
@@ -181,6 +185,7 @@ int proc_pid_stat(struct task_struct*,ch
 int proc_pid_status(struct task_struct*,char*);
 int proc_pid_statm(struct task_struct*,char*);
 int proc_pid_cpu(struct task_struct*,char*);
+// int proc_pid_vinfo(struct task_struct*,char*);
 
 static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsmount **mnt)
 {
@@ -962,6 +967,7 @@ static struct inode *proc_pid_make_inode
 		inode->i_uid = task->euid;
 		inode->i_gid = task->egid;
 	}
+	inode->i_xid = vx_task_xid(task);
 	security_task_to_inode(task, inode);
 
 out:
@@ -987,6 +993,11 @@ static int pid_revalidate(struct dentry 
 {
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task = proc_task(inode);
+
+	if (!vx_check(vx_task_xid(task), VX_WATCH|VX_IDENT))
+		goto out_drop;
+	/* discard wrong fakeinit */
+
 	if (pid_alive(task)) {
 		if (proc_type(inode) == PROC_TGID_INO || proc_type(inode) == PROC_TID_INO || task_dumpable(task)) {
 			inode->i_uid = task->euid;
@@ -998,6 +1009,7 @@ static int pid_revalidate(struct dentry 
 		security_task_to_inode(task, inode);
 		return 1;
 	}
+out_drop:
 	d_drop(dentry);
 	return 0;
 }
@@ -1391,6 +1403,11 @@ static struct dentry *proc_pident_lookup
 			ei->op.proc_read = proc_pid_wchan;
 			break;
 #endif
+		case PROC_TID_VINFO:
+		case PROC_TGID_VINFO:
+			inode->i_fop = &proc_info_file_operations;
+			ei->op.proc_read = proc_pid_vinfo;
+			break;
 		default:
 			printk("procfs: impossible type (%d)",p->type);
 			iput(inode);
@@ -1564,6 +1581,7 @@ struct dentry *proc_pid_lookup(struct in
 		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 		inode->i_ino = fake_ino(0, PROC_TGID_INO);
 		ei->pde = NULL;
+		ei->vxi = NULL;
 		inode->i_mode = S_IFLNK|S_IRWXUGO;
 		inode->i_uid = inode->i_gid = 0;
 		inode->i_size = 64;
@@ -1571,7 +1589,7 @@ struct dentry *proc_pid_lookup(struct in
 		d_add(dentry, inode);
 		return NULL;
 	}
-	tgid = name_to_int(dentry);
+	tgid = vx_rmap_tgid(current->vx_info, name_to_int(dentry));
 	if (tgid == ~0U)
 		goto out;
 
@@ -1583,8 +1601,9 @@ struct dentry *proc_pid_lookup(struct in
 	if (!task)
 		goto out;
 
-	inode = proc_pid_make_inode(dir->i_sb, task, PROC_TGID_INO);
-
+	inode = NULL;
+	if (vx_check(vx_task_xid(task), VX_WATCH|VX_IDENT))
+		inode = proc_pid_make_inode(dir->i_sb, task, PROC_TGID_INO);
 
 	if (!inode) {
 		put_task_struct(task);
@@ -1626,10 +1645,12 @@ static struct dentry *proc_task_lookup(s
 	struct inode *inode;
 	unsigned tid;
 
-	tid = name_to_int(dentry);
+	tid = vx_rmap_tgid(current->vx_info, name_to_int(dentry));
 	if (tid == ~0U)
 		goto out;
 
+/*	handle fakeinit */
+
 	read_lock(&tasklist_lock);
 	task = find_task_by_pid(tid);
 	if (task)
@@ -1640,8 +1661,9 @@ static struct dentry *proc_task_lookup(s
 	if (leader->tgid != task->tgid)
 		goto out_drop_task;
 
-	inode = proc_pid_make_inode(dir->i_sb, task, PROC_TID_INO);
-
+	inode = NULL;
+	if (vx_check(vx_task_xid(task), VX_WATCH|VX_IDENT))
+		inode = proc_pid_make_inode(dir->i_sb, task, PROC_TID_INO);
 
 	if (!inode)
 		goto out_drop_task;
@@ -1692,11 +1714,14 @@ static int get_tgid_list(int index, unsi
 
 	for ( ; p != &init_task; p = next_task(p)) {
 		int tgid = p->pid;
+
+		if (!vx_check(vx_task_xid(p), VX_WATCH|VX_IDENT))
+			continue;
 		if (!pid_alive(p))
 			continue;
 		if (--index >= 0)
 			continue;
-		tgids[nr_tgids] = tgid;
+		tgids[nr_tgids] = vx_map_tgid(current->vx_info, tgid);
 		nr_tgids++;
 		if (nr_tgids >= PROC_MAXPIDS)
 			break;
@@ -1726,9 +1751,11 @@ static int get_tid_list(int index, unsig
 	if (pid_alive(task)) do {
 		int tid = task->pid;
 
+		if (!vx_check(vx_task_xid(task), VX_WATCH|VX_IDENT))
+			continue;
 		if (--index >= 0)
 			continue;
-		tids[nr_tids] = tid;
+		tids[nr_tids] = vx_map_tgid(current->vx_info, tid);
 		nr_tids++;
 		if (nr_tids >= PROC_MAXPIDS)
 			break;
@@ -1782,11 +1809,14 @@ static int proc_task_readdir(struct file
 	unsigned int nr_tids, i;
 	struct dentry *dentry = filp->f_dentry;
 	struct inode *inode = dentry->d_inode;
+	struct task_struct *task = proc_task(inode);
 	int retval = -ENOENT;
 	ino_t ino;
 	unsigned long pos = filp->f_pos;  /* avoiding "long long" filp->f_pos */
 
-	if (!pid_alive(proc_task(inode)))
+	if (!vx_check(vx_task_xid(task), VX_WATCH|VX_IDENT))
+		goto out;
+	if (!pid_alive(task))
 		goto out;
 	retval = 0;
 
diff -NurpP --minimal linux-2.6.5/fs/proc/generic.c linux-2.6.5-vs1.9.0pre2/fs/proc/generic.c
--- linux-2.6.5/fs/proc/generic.c	2004-04-04 18:03:09.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/generic.c	2004-04-05 00:55:13.000000000 +0200
@@ -15,6 +15,8 @@
 #include <linux/module.h>
 #include <linux/mount.h>
 #include <linux/smp_lock.h>
+#include <linux/vinline.h>
+#include <linux/vserver/inode.h>
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 
@@ -345,6 +347,8 @@ struct dentry *proc_lookup(struct inode 
 		for (de = de->subdir; de ; de = de->next) {
 			if (de->namelen != dentry->d_name.len)
 				continue;
+			if (!vx_hide_check(0, de->vx_flags))
+				continue;
 			if (!memcmp(dentry->d_name.name, de->name, de->namelen)) {
 				int ino = de->low_ino;
 				error = -EINVAL;
@@ -420,9 +424,12 @@ int proc_readdir(struct file * filp,
 			}
 
 			do {
+				if (!vx_hide_check(0, de->vx_flags))
+					goto skip;
 				if (filldir(dirent, de->name, de->namelen, filp->f_pos,
 					    de->low_ino, de->mode >> 12) < 0)
 					goto out;
+			skip:
 				filp->f_pos++;
 				de = de->next;
 			} while (de);
@@ -534,6 +541,7 @@ static struct proc_dir_entry *proc_creat
 	ent->namelen = len;
 	ent->mode = mode;
 	ent->nlink = nlink;
+	ent->vx_flags = IATTR_PROC_DEFAULT;
  out:
 	return ent;
 }
@@ -554,7 +562,8 @@ struct proc_dir_entry *proc_symlink(cons
 				kfree(ent->data);
 				kfree(ent);
 				ent = NULL;
-			}
+			} else
+				ent->vx_flags = IATTR_PROC_SYMLINK;
 		} else {
 			kfree(ent);
 			ent = NULL;
diff -NurpP --minimal linux-2.6.5/fs/proc/inode.c linux-2.6.5-vs1.9.0pre2/fs/proc/inode.c
--- linux-2.6.5/fs/proc/inode.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/inode.c	2004-04-05 00:55:13.000000000 +0200
@@ -60,6 +60,7 @@ static void proc_delete_inode(struct ino
 {
 	struct proc_dir_entry *de;
 	struct task_struct *tsk;
+	struct vx_info *vxi;
 
 	/* Let go of any associated process */
 	tsk = PROC_I(inode)->task;
@@ -73,6 +74,9 @@ static void proc_delete_inode(struct ino
 			module_put(de->owner);
 		de_put(de);
 	}
+	vxi = PROC_I(inode)->vxi;
+	if (vxi)
+		put_vx_info(vxi);
 	clear_inode(inode);
 }
 
@@ -97,6 +101,7 @@ static struct inode *proc_alloc_inode(st
 	ei->type = 0;
 	ei->op.proc_get_link = NULL;
 	ei->pde = NULL;
+	ei->vxi = NULL;
 	inode = &ei->vfs_inode;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	return inode;
@@ -207,6 +212,8 @@ printk("proc_iget: using deleted entry %
 			inode->i_uid = de->uid;
 			inode->i_gid = de->gid;
 		}
+		if (de->vx_flags)
+			PROC_I(inode)->vx_flags = de->vx_flags;
 		if (de->size)
 			inode->i_size = de->size;
 		if (de->nlink)
diff -NurpP --minimal linux-2.6.5/fs/proc/proc_misc.c linux-2.6.5-vs1.9.0pre2/fs/proc/proc_misc.c
--- linux-2.6.5/fs/proc/proc_misc.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/proc_misc.c	2004-04-05 00:55:18.000000000 +0200
@@ -44,6 +44,7 @@
 #include <linux/jiffies.h>
 #include <linux/sysrq.h>
 #include <linux/vmalloc.h>
+#include <linux/vinline.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/io.h>
@@ -144,6 +145,9 @@ static int uptime_read_proc(char *page, 
 
 	do_posix_clock_monotonic_gettime(&uptime);
 	jiffies_to_timespec(idle_jiffies, &idle);
+	if (vx_flags(VXF_VIRT_UPTIME, 0))
+		vx_vsi_uptime(&uptime);
+
 	len = sprintf(page,"%lu.%02lu %lu.%02lu\n",
 			(unsigned long) uptime.tv_sec,
 			(uptime.tv_nsec / (NSEC_PER_SEC / 100)),
diff -NurpP --minimal linux-2.6.5/fs/proc/root.c linux-2.6.5-vs1.9.0pre2/fs/proc/root.c
--- linux-2.6.5/fs/proc/root.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/root.c	2004-04-05 00:55:13.000000000 +0200
@@ -23,6 +23,9 @@ struct proc_dir_entry *proc_net, *proc_b
 #ifdef CONFIG_SYSCTL
 struct proc_dir_entry *proc_sys_root;
 #endif
+struct proc_dir_entry *proc_virtual;
+
+extern void proc_vx_init(void);
 
 static struct super_block *proc_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
@@ -75,6 +78,7 @@ void __init proc_root_init(void)
 	proc_device_tree_init();
 #endif
 	proc_bus = proc_mkdir("bus", 0);
+	proc_vx_init();
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
diff -NurpP --minimal linux-2.6.5/fs/proc/virtual.c linux-2.6.5-vs1.9.0pre2/fs/proc/virtual.c
--- linux-2.6.5/fs/proc/virtual.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/proc/virtual.c	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,873 @@
+/*
+ *  linux/fs/proc/virtual.c
+ *
+ *  Virtual Context Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  basic structure
+ *  V0.02  adaptation vs1.3.0
+ *  V0.03  proc permissions
+ *  V0.04  locking/generic
+ *  V0.05  next generation procfs
+ *  V0.06  inode validation
+ *  V0.07  generic rewrite vid
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+
+#include <linux/vinline.h>
+
+#include <asm/uaccess.h>
+#include <asm/unistd.h>
+
+
+static struct proc_dir_entry *proc_virtual;
+
+static struct proc_dir_entry *proc_vnet;
+
+
+enum vid_directory_inos {
+	PROC_XID_INO = 32,
+	PROC_XID_INFO,
+	PROC_XID_STATUS,
+	PROC_XID_CVIRT,
+	PROC_XID_LIMIT,
+	PROC_XID_SCHED,
+
+	PROC_NID_INO = 64,
+	PROC_NID_INFO,
+	PROC_NID_STATUS,
+};
+
+#define	PROC_VID_MASK	0x60
+
+
+/* first the actual feeds */
+
+
+static int proc_virtual_info(int vid, char *buffer)
+{
+	return sprintf(buffer,
+		"VCIVersion:\t%04x:%04x\n"
+		"VCISyscall:\t%d\n"
+		,VCI_VERSION >> 16
+		,VCI_VERSION & 0xFFFF
+		,__NR_vserver
+		);
+}
+
+
+int proc_xid_info (int vid, char *buffer)
+{
+	struct vx_info *vxi;
+	int length;
+
+	vxi = find_vx_info(vid);
+	if (!vxi)
+		return 0;
+	length = sprintf(buffer,
+		"ID:\t%d\n"
+		"Info:\t%p\n"
+		"Init:\t%d\n"
+		,vxi->vx_id
+		,vxi
+		,vxi->vx_initpid
+		);
+	put_vx_info(vxi);
+	return length;
+}
+
+int proc_xid_status (int vid, char *buffer)
+{
+	struct vx_info *vxi;
+	int length;
+
+	vxi = find_vx_info(vid);
+	if (!vxi)
+		return 0;
+	length = sprintf(buffer,
+		"RefC:\t%d\n"		
+		"Flags:\t%016llx\n"
+		"BCaps:\t%016llx\n"
+		"CCaps:\t%016llx\n"
+		"Ticks:\t%d\n"		
+		,atomic_read(&vxi->vx_refcount)
+		,vxi->vx_flags
+		,vxi->vx_bcaps
+		,vxi->vx_ccaps
+		,atomic_read(&vxi->limit.ticks)
+		);
+	put_vx_info(vxi);
+	return length;
+}
+
+int proc_xid_cvirt (int vid, char *buffer)
+{
+	struct vx_info *vxi;
+	int length;
+
+	vxi = find_vx_info(vid);
+	if (!vxi)
+		return 0;
+	length = vx_info_proc_cvirt(&vxi->cvirt, buffer);
+	put_vx_info(vxi);
+	return length;
+}
+
+int proc_xid_limit (int vid, char *buffer)
+{
+	struct vx_info *vxi;
+	int length;
+
+	vxi = find_vx_info(vid);
+	if (!vxi)
+		return 0;
+	length = vx_info_proc_limit(&vxi->limit, buffer);
+	put_vx_info(vxi);
+	return length;
+}
+
+int proc_xid_sched (int vid, char *buffer)
+{
+	struct vx_info *vxi;
+	int length;
+
+	vxi = find_vx_info(vid);
+	if (!vxi)
+		return 0;
+	length = vx_info_proc_sched(&vxi->sched, buffer);
+	put_vx_info(vxi);
+	return length;
+}
+
+
+static int proc_vnet_info(int vid, char *buffer)
+{
+	return sprintf(buffer,
+		"VCIVersion:\t%04x:%04x\n"
+		"VCISyscall:\t%d\n"
+		,VCI_VERSION >> 16
+		,VCI_VERSION & 0xFFFF
+		,__NR_vserver
+		);
+}
+
+#define	atoquad(a) \
+	(((a)>>0) & 0xff), (((a)>>8) & 0xff), \
+	(((a)>>16) & 0xff), (((a)>>24) & 0xff)
+
+int proc_nid_info (int vid, char *buffer)
+{
+	struct ip_info *ipi;
+	int length, i;
+
+	ipi = find_ip_info(vid);
+	if (!ipi)
+		return 0;
+	length = sprintf(buffer,
+		"ID:\t%d\n"
+		"Info:\t%p\n"
+		,ipi->ip_id
+		,ipi
+		);
+	for (i=0; i<ipi->nbipv4; i++) {
+		length += sprintf(buffer + length,
+			"%d:\t%d.%d.%d.%d/%d.%d.%d.%d\n", i,
+			atoquad(ipi->ipv4[i]),
+			atoquad(ipi->mask[i]));
+	}
+	put_ip_info(ipi);
+	return length;
+}
+
+int proc_nid_status (int vid, char *buffer)
+{
+	struct ip_info *ipi;
+	int length;
+
+	ipi = find_ip_info(vid);
+	if (!ipi)
+		return 0;
+	length = sprintf(buffer,
+		"RefC:\t%d\n"		
+		,atomic_read(&ipi->ip_refcount)
+		);
+	put_ip_info(ipi);
+	return length;
+}
+
+/* here the inode helpers */
+
+
+
+#define fake_ino(id,ino) (((id)<<16)|(ino))
+
+#define	inode_vid(i)	((i)->i_ino >> 16)
+#define	inode_type(i)	((i)->i_ino & 0xFFFF)
+
+#define MAX_MULBY10	((~0U-9)/10)
+
+
+static struct inode *proc_vid_make_inode(struct super_block * sb,
+	int vid, int ino)
+{
+	struct inode *inode = new_inode(sb);
+
+	if (!inode)
+		goto out;
+
+	inode->i_mtime = inode->i_atime =
+		inode->i_ctime = CURRENT_TIME;
+	inode->i_ino = fake_ino(vid, ino);
+
+	inode->i_uid = 0;
+	inode->i_gid = 0;
+	// inode->i_xid = xid;
+out:
+	return inode;
+}
+
+static int proc_vid_revalidate(struct dentry * dentry, struct nameidata *nd)
+{
+	struct inode * inode = dentry->d_inode;
+	int vid, valid=0;
+
+	vid = inode_vid(inode);
+	switch (inode_type(inode) & PROC_VID_MASK) {
+		case PROC_XID_INO:
+			valid = vx_info_id_valid(vid);
+			break;
+		case PROC_NID_INO:
+			valid = ip_info_id_valid(vid);
+			break;
+	}	
+	if (valid)
+		return 1;
+	d_drop(dentry);
+	return 0;
+}
+
+/*
+static int proc_vid_delete_dentry(struct dentry * dentry)
+{
+        return 1;
+}
+*/
+
+
+#define PROC_BLOCK_SIZE (PAGE_SIZE - 1024)
+
+static ssize_t proc_vid_info_read(struct file * file, char * buf,
+			  size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	unsigned long page;
+	ssize_t length;
+	ssize_t end;
+	int vid;
+
+	if (count > PROC_BLOCK_SIZE)
+		count = PROC_BLOCK_SIZE;
+	if (!(page = __get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+
+	vid = inode_vid(inode);
+	length = PROC_I(inode)->op.proc_vid_read(vid, (char*)page);
+
+	if (length < 0) {
+		free_page(page);
+		return length;
+	}
+	/* Static 4kB (or whatever) block capacity */
+	if (*ppos >= length) {
+		free_page(page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	copy_to_user(buf, (char *) page + *ppos, count);
+	*ppos = end;
+	free_page(page);
+	return count;
+}
+
+
+
+
+
+/* here comes the lower level (vid) */
+
+static struct file_operations proc_vid_info_file_operations = {
+	read:		proc_vid_info_read,
+};
+
+static struct dentry_operations proc_vid_dentry_operations = {
+	d_revalidate:   proc_vid_revalidate,
+//	d_delete:       proc_vid_delete_dentry,
+};
+
+
+struct vid_entry {
+	int type;
+	int len;
+	char *name;
+	mode_t mode;
+};
+
+#define E(type,name,mode) {(type),sizeof(name)-1,(name),(mode)}
+
+static struct vid_entry vx_base_stuff[] = {
+	E(PROC_XID_INFO,	"info",		S_IFREG|S_IRUGO),
+	E(PROC_XID_STATUS,	"status",	S_IFREG|S_IRUGO),
+	E(PROC_XID_CVIRT,	"cvirt",	S_IFREG|S_IRUGO),
+	E(PROC_XID_LIMIT,	"limit",	S_IFREG|S_IRUGO),
+	E(PROC_XID_SCHED,	"sched",	S_IFREG|S_IRUGO),
+	{0,0,NULL,0}
+};
+
+static struct vid_entry vn_base_stuff[] = {
+	E(PROC_NID_INFO,	"info",		S_IFREG|S_IRUGO),
+	E(PROC_NID_STATUS,	"status",	S_IFREG|S_IRUGO),
+	{0,0,NULL,0}
+};
+
+
+
+static struct dentry *proc_vid_lookup(struct inode *dir,
+	struct dentry *dentry, struct nameidata *nd)
+{
+	struct inode *inode;
+	struct vid_entry *p;
+	int error;
+
+	error = -ENOENT;
+	inode = NULL;
+
+	switch (inode_type(dir)) {
+		case PROC_XID_INO:
+			p = vx_base_stuff;	
+			break;
+		case PROC_NID_INO:
+			p = vn_base_stuff;	
+			break;
+		default:
+			goto out;
+	}
+
+	for (; p->name; p++) {
+		if (p->len != dentry->d_name.len)
+			continue;
+		if (!memcmp(dentry->d_name.name, p->name, p->len))
+			break;
+	}
+	if (!p->name)
+		goto out;
+
+	error = -EINVAL;
+	inode = proc_vid_make_inode(dir->i_sb, inode_vid(dir), p->type);
+	if (!inode)
+		goto out;
+
+	switch(p->type) {
+		case PROC_XID_INFO:
+			PROC_I(inode)->op.proc_vid_read = proc_xid_info;
+			break;
+		case PROC_XID_STATUS:
+			PROC_I(inode)->op.proc_vid_read = proc_xid_status;
+			break;
+		case PROC_XID_CVIRT:
+			PROC_I(inode)->op.proc_vid_read = proc_xid_cvirt;
+			break;
+		case PROC_XID_LIMIT:
+			PROC_I(inode)->op.proc_vid_read = proc_xid_limit;
+			break;
+		case PROC_XID_SCHED:
+			PROC_I(inode)->op.proc_vid_read = proc_xid_sched;
+			break;
+
+		case PROC_NID_INFO:
+			PROC_I(inode)->op.proc_vid_read = proc_nid_info;
+			break;
+		case PROC_NID_STATUS:
+			PROC_I(inode)->op.proc_vid_read = proc_nid_status;
+			break;
+		
+		default:
+			printk("procfs: impossible type (%d)",p->type);
+			iput(inode);
+			return ERR_PTR(-EINVAL);
+	}
+	inode->i_mode = p->mode;
+//	inode->i_op = &proc_vid_info_inode_operations;
+	inode->i_fop = &proc_vid_info_file_operations;
+	inode->i_nlink = 1;
+	inode->i_flags|=S_IMMUTABLE;
+	
+	dentry->d_op = &proc_vid_dentry_operations;
+	d_add(dentry, inode);
+	error = 0;
+out:
+	return ERR_PTR(error);
+}
+
+
+static int proc_vid_readdir(struct file * filp,
+	void * dirent, filldir_t filldir)
+{
+	int i, size;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct vid_entry *p;
+	
+	i = filp->f_pos;
+	switch (i) {
+		case 0:
+			if (filldir(dirent, ".", 1, i,
+				inode->i_ino, DT_DIR) < 0)
+				return 0;
+			i++;
+			filp->f_pos++;
+			/* fall through */
+		case 1:
+			if (filldir(dirent, "..", 2, i,
+				PROC_ROOT_INO, DT_DIR) < 0)
+				return 0;
+			i++;
+			filp->f_pos++;
+			/* fall through */
+		default:
+			i -= 2;
+			switch (inode_type(inode)) {
+				case PROC_XID_INO:
+					size = sizeof(vx_base_stuff);
+					p = vx_base_stuff + i;	
+					break;
+				case PROC_NID_INO:
+					size = sizeof(vn_base_stuff);
+					p = vn_base_stuff + i;	
+					break;
+				default:
+					return 1;
+			}
+			if (i >= size/sizeof(struct vid_entry))
+				return 1;
+			while (p->name) {
+				if (filldir(dirent, p->name, p->len,
+					filp->f_pos, fake_ino(inode_vid(inode),
+					p->type), p->mode >> 12) < 0)
+					return 0;
+				filp->f_pos++;
+				p++;
+			}
+	}
+	return 1;
+}
+
+
+
+
+/* now the upper level (virtual) */
+
+static struct file_operations proc_vid_file_operations = {
+	read:		generic_read_dir,
+	readdir:	proc_vid_readdir,
+};
+
+static struct inode_operations proc_vid_inode_operations = {
+	lookup:		proc_vid_lookup,
+};
+
+
+
+static __inline__ int atovid(const char *str, int len)
+{
+	int vid, c;
+
+	vid = 0;
+	while (len-- > 0) {
+		c = *str - '0';
+		str++;
+		if (c > 9)
+			return -1;
+		if (vid >= MAX_MULBY10)
+			return -1;
+		vid *= 10;
+		vid += c;
+		if (!vid)
+			return -1;
+	}
+	return vid;
+}
+
+
+struct dentry *proc_virtual_lookup(struct inode *dir,
+	struct dentry * dentry, struct nameidata *nd)
+{
+	int xid, len, ret;
+	struct vx_info *vxi;
+	const char *name;
+	struct inode *inode;
+
+	name = dentry->d_name.name;
+	len = dentry->d_name.len;
+	ret = -ENOMEM;
+
+	if (len == 7 && !memcmp(name, "current", 7)) {
+		inode = new_inode(dir->i_sb);
+		if (!inode)
+			goto out;
+		inode->i_mtime = inode->i_atime =
+			inode->i_ctime = CURRENT_TIME;
+		inode->i_ino = fake_ino(1, PROC_XID_INO);
+		inode->i_mode = S_IFLNK|S_IRWXUGO;
+		inode->i_uid = inode->i_gid = 0;
+		inode->i_size = 64;
+//		inode->i_op = &proc_current_inode_operations;
+		d_add(dentry, inode);
+		return NULL;
+	}
+	if (len == 4 && !memcmp(name, "info", 4)) {
+		inode = proc_vid_make_inode(dir->i_sb, 0, PROC_XID_INFO);
+		if (!inode)
+			goto out;
+		inode->i_fop = &proc_vid_info_file_operations;
+		PROC_I(inode)->op.proc_vid_read = proc_virtual_info;
+		inode->i_mode = S_IFREG|S_IRUGO;
+//		inode->i_size = 64;
+//		inode->i_op = &proc_current_inode_operations;
+		d_add(dentry, inode);
+		return NULL;
+	}
+
+	ret = -ENOENT;
+	xid = atovid(name, len);
+	if (xid < 0)
+		goto out;
+	vxi = find_vx_info(xid);
+	if (!vxi)
+		goto out;
+
+	inode = NULL;
+	if (vx_check(xid, VX_ADMIN|VX_WATCH|VX_IDENT))
+		inode = proc_vid_make_inode(dir->i_sb,
+			vxi->vx_id, PROC_XID_INO);
+	if (!inode)
+		goto out_release;
+
+	inode->i_mode = S_IFDIR|S_IRUGO;
+	inode->i_op = &proc_vid_inode_operations;
+	inode->i_fop = &proc_vid_file_operations;
+	inode->i_nlink = 2;
+	inode->i_flags|=S_IMMUTABLE;
+
+	dentry->d_op = &proc_vid_dentry_operations;
+	d_add(dentry, inode);
+	ret = 0;
+	
+out_release:
+	put_vx_info(vxi);
+out:
+	return ERR_PTR(ret);
+}
+
+
+struct dentry *proc_vnet_lookup(struct inode *dir,
+	struct dentry * dentry, struct nameidata *nd)
+{
+	int nid, len, ret;
+	struct ip_info *ipi;
+	const char *name;
+	struct inode *inode;
+
+	name = dentry->d_name.name;
+	len = dentry->d_name.len;
+	ret = -ENOMEM;
+	if (len == 7 && !memcmp(name, "current", 7)) {
+		inode = new_inode(dir->i_sb);
+		if (!inode)
+			goto out;
+		inode->i_mtime = inode->i_atime =
+			inode->i_ctime = CURRENT_TIME;
+		inode->i_ino = fake_ino(1, PROC_NID_INO);
+		inode->i_mode = S_IFLNK|S_IRWXUGO;
+		inode->i_uid = inode->i_gid = 0;
+		inode->i_size = 64;
+//		inode->i_op = &proc_current_inode_operations;
+		d_add(dentry, inode);
+		return NULL;
+	}
+	if (len == 4 && !memcmp(name, "info", 4)) {
+		inode = proc_vid_make_inode(dir->i_sb, 0, PROC_NID_INFO);
+		if (!inode)
+			goto out;
+		inode->i_fop = &proc_vid_info_file_operations;
+		PROC_I(inode)->op.proc_vid_read = proc_vnet_info;
+		inode->i_mode = S_IFREG|S_IRUGO;
+//		inode->i_size = 64;
+//		inode->i_op = &proc_current_inode_operations;
+		d_add(dentry, inode);
+		return NULL;
+	}
+
+	ret = -ENOENT;
+	nid = atovid(name, len);
+	if (nid < 0)
+		goto out;
+	ipi = find_ip_info(nid);
+	if (!ipi)
+		goto out;
+
+	inode = NULL;
+	if (1)
+		inode = proc_vid_make_inode(dir->i_sb,
+			ipi->ip_id, PROC_NID_INO);
+	if (!inode)
+		goto out_release;
+
+	inode->i_mode = S_IFDIR|S_IRUGO;
+	inode->i_op = &proc_vid_inode_operations;
+	inode->i_fop = &proc_vid_file_operations;
+	inode->i_nlink = 2;
+	inode->i_flags|=S_IMMUTABLE;
+
+	dentry->d_op = &proc_vid_dentry_operations;
+	d_add(dentry, inode);
+	ret = 0;
+	
+out_release:
+	put_ip_info(ipi);
+out:
+	return ERR_PTR(ret);
+}
+
+
+
+
+#define PROC_NUMBUF 10
+#define PROC_MAXVIDS 32
+
+
+static int get_xid_list(int index, unsigned int *xids)
+{
+	struct vx_info *p;
+	int nr_xids = 0;
+
+	index--;
+	spin_lock(&vxlist_lock);
+	list_for_each_entry(p, &vx_infos, vx_list) {
+		int xid = p->vx_id;
+
+		if (--index >= 0)
+			continue;
+		xids[nr_xids] = xid;
+		if (++nr_xids >= PROC_MAXVIDS)
+			break;
+	}
+	spin_unlock(&vxlist_lock);
+	return nr_xids;
+}
+
+int proc_virtual_readdir(struct file * filp,
+	void * dirent, filldir_t filldir)
+{
+	unsigned int xid_array[PROC_MAXVIDS];
+	char buf[PROC_NUMBUF];
+	unsigned int nr = filp->f_pos-3;
+	unsigned int nr_xids, i;
+	ino_t ino;
+
+	switch ((long)filp->f_pos) {
+		case 0:
+			ino = fake_ino(0, PROC_XID_INO);
+			if (filldir(dirent, ".", 1,
+				filp->f_pos, ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 1:
+			ino = filp->f_dentry->d_parent->d_inode->i_ino;
+			if (filldir(dirent, "..", 2,
+				filp->f_pos, ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 2:
+			ino = fake_ino(0, PROC_XID_INFO);
+			if (filldir(dirent, "info", 4,
+				filp->f_pos, ino, DT_LNK) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 3:
+			if (current->xid > 1) {
+				ino = fake_ino(1, PROC_XID_INO);
+				if (filldir(dirent, "current", 7,
+					filp->f_pos, ino, DT_LNK) < 0)
+					return 0;
+			}
+			filp->f_pos++;
+	}
+
+	nr_xids = get_xid_list(nr, xid_array);
+
+	for (i = 0; i < nr_xids; i++) {
+		int xid = xid_array[i];
+		ino_t ino = fake_ino(xid, PROC_XID_INO);
+		unsigned long j = PROC_NUMBUF;
+
+		do buf[--j] = '0' + (xid % 10); while (xid/=10);
+
+		if (filldir(dirent, buf+j, PROC_NUMBUF-j,
+			filp->f_pos, ino, DT_DIR) < 0)
+			break;
+		filp->f_pos++;
+	}
+	return 0;
+}
+
+
+static struct file_operations proc_virtual_dir_operations = {
+	read:		generic_read_dir,
+	readdir:	proc_virtual_readdir,
+};
+
+static struct inode_operations proc_virtual_dir_inode_operations = {
+	lookup:		proc_virtual_lookup,
+};
+
+
+
+static int get_nid_list(int index, unsigned int *nids)
+{
+	struct ip_info *p;
+	int nr_nids = 0;
+
+	index--;
+	spin_lock(&iplist_lock);
+	list_for_each_entry(p, &ip_infos, ip_list) {
+		int nid = p->ip_id;
+
+		if (--index >= 0)
+			continue;
+		nids[nr_nids] = nid;
+		if (++nr_nids >= PROC_MAXVIDS)
+			break;
+	}
+	spin_unlock(&iplist_lock);
+	return nr_nids;
+}
+
+int proc_vnet_readdir(struct file * filp,
+	void * dirent, filldir_t filldir)
+{
+	unsigned int nid_array[PROC_MAXVIDS];
+	char buf[PROC_NUMBUF];
+	unsigned int nr = filp->f_pos-3;
+	unsigned int nr_nids, i;
+	ino_t ino;
+
+	switch ((long)filp->f_pos) {
+		case 0:
+			ino = fake_ino(0, PROC_NID_INO);
+			if (filldir(dirent, ".", 1,
+				filp->f_pos, ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 1:
+			ino = filp->f_dentry->d_parent->d_inode->i_ino;
+			if (filldir(dirent, "..", 2,
+				filp->f_pos, ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 2:
+			ino = fake_ino(0, PROC_NID_INFO);
+			if (filldir(dirent, "info", 4,
+				filp->f_pos, ino, DT_LNK) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 3:
+			if (current->xid > 1) {
+				ino = fake_ino(1, PROC_NID_INO);
+				if (filldir(dirent, "current", 7,
+					filp->f_pos, ino, DT_LNK) < 0)
+					return 0;
+			}
+			filp->f_pos++;
+	}
+
+	nr_nids = get_nid_list(nr, nid_array);
+
+	for (i = 0; i < nr_nids; i++) {
+		int nid = nid_array[i];
+		ino_t ino = fake_ino(nid, PROC_NID_INO);
+		unsigned long j = PROC_NUMBUF;
+
+		do buf[--j] = '0' + (nid % 10); while (nid/=10);
+
+		if (filldir(dirent, buf+j, PROC_NUMBUF-j,
+			filp->f_pos, ino, DT_DIR) < 0)
+			break;
+		filp->f_pos++;
+	}
+	return 0;
+}
+
+
+static struct file_operations proc_vnet_dir_operations = {
+	read:		generic_read_dir,
+	readdir:	proc_vnet_readdir,
+};
+
+static struct inode_operations proc_vnet_dir_inode_operations = {
+	lookup:		proc_vnet_lookup,
+};
+
+
+
+void proc_vx_init(void)
+{
+	struct proc_dir_entry *ent;
+
+	ent = proc_mkdir("virtual", 0);
+	if (ent) {
+		ent->proc_fops = &proc_virtual_dir_operations;
+		ent->proc_iops = &proc_virtual_dir_inode_operations;
+	}
+	proc_virtual = ent;
+
+	ent = proc_mkdir("vnet", 0);
+	if (ent) {
+		ent->proc_fops = &proc_vnet_dir_operations;
+		ent->proc_iops = &proc_vnet_dir_inode_operations;
+	}
+	proc_vnet = ent;
+}
+
+
+
+
+/* per pid info */
+
+
+char *task_vinfo(struct task_struct *p, char *buffer)
+{
+	return buffer + sprintf(buffer,
+		"XID:\t%d\n"
+		,p->xid);
+}
+
+int proc_pid_vinfo(struct task_struct *p, char *buffer)
+{
+	char * orig = buffer;
+
+	buffer = task_vinfo(p, buffer);
+	return buffer - orig;
+}
+
diff -NurpP --minimal linux-2.6.5/fs/quota.c linux-2.6.5-vs1.9.0pre2/fs/quota.c
--- linux-2.6.5/fs/quota.c	2004-03-11 03:55:49.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/quota.c	2004-04-05 00:55:18.000000000 +0200
@@ -15,63 +15,63 @@
 #include <linux/security.h>
 
 /* Check validity of quotactl */
-static int check_quotactl_valid(struct super_block *sb, int type, int cmd, qid_t id)
+static int check_quotactl_valid(struct dqhash *hash, int type, int cmd, qid_t id)
 {
 	if (type >= MAXQUOTAS)
 		return -EINVAL;
-	if (!sb && cmd != Q_SYNC)
+	if (!hash && cmd != Q_SYNC)
 		return -ENODEV;
 	/* Is operation supported? */
-	if (sb && !sb->s_qcop)
+	if (hash && !hash->dqh_qcop)
 		return -ENOSYS;
 
 	switch (cmd) {
 		case Q_GETFMT:
 			break;
 		case Q_QUOTAON:
-			if (!sb->s_qcop->quota_on)
+			if (!hash->dqh_qcop->quota_on)
 				return -ENOSYS;
 			break;
 		case Q_QUOTAOFF:
-			if (!sb->s_qcop->quota_off)
+			if (!hash->dqh_qcop->quota_off)
 				return -ENOSYS;
 			break;
 		case Q_SETINFO:
-			if (!sb->s_qcop->set_info)
+			if (!hash->dqh_qcop->set_info)
 				return -ENOSYS;
 			break;
 		case Q_GETINFO:
-			if (!sb->s_qcop->get_info)
+			if (!hash->dqh_qcop->get_info)
 				return -ENOSYS;
 			break;
 		case Q_SETQUOTA:
-			if (!sb->s_qcop->set_dqblk)
+			if (!hash->dqh_qcop->set_dqblk)
 				return -ENOSYS;
 			break;
 		case Q_GETQUOTA:
-			if (!sb->s_qcop->get_dqblk)
+			if (!hash->dqh_qcop->get_dqblk)
 				return -ENOSYS;
 			break;
 		case Q_SYNC:
-			if (sb && !sb->s_qcop->quota_sync)
+			if (hash && !hash->dqh_qcop->quota_sync)
 				return -ENOSYS;
 			break;
 		case Q_XQUOTAON:
 		case Q_XQUOTAOFF:
 		case Q_XQUOTARM:
-			if (!sb->s_qcop->set_xstate)
+			if (!hash->dqh_qcop->set_xstate)
 				return -ENOSYS;
 			break;
 		case Q_XGETQSTAT:
-			if (!sb->s_qcop->get_xstate)
+			if (!hash->dqh_qcop->get_xstate)
 				return -ENOSYS;
 			break;
 		case Q_XSETQLIM:
-			if (!sb->s_qcop->set_xquota)
+			if (!hash->dqh_qcop->set_xquota)
 				return -ENOSYS;
 			break;
 		case Q_XGETQUOTA:
-			if (!sb->s_qcop->get_xquota)
+			if (!hash->dqh_qcop->get_xquota)
 				return -ENOSYS;
 			break;
 		default:
@@ -87,7 +87,7 @@ static int check_quotactl_valid(struct s
 		case Q_SETQUOTA:
 		case Q_GETQUOTA:
 			/* This is just informative test so we are satisfied without a lock */
-			if (!sb_has_quota_enabled(sb, type))
+			if (!dqh_has_quota_enabled(hash, type))
 				return -ESRCH;
 	}
 	/* Check privileges */
@@ -101,7 +101,7 @@ static int check_quotactl_valid(struct s
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 
-	return security_quotactl (cmd, type, id, sb);
+	return security_quotactl (cmd, type, id, hash);
 }
 
 static struct super_block *get_super_to_sync(int type)
@@ -113,10 +113,11 @@ restart:
 	spin_lock(&sb_lock);
 	list_for_each(head, &super_blocks) {
 		struct super_block *sb = list_entry(head, struct super_block, s_list);
+		struct dqhash *dqh = sb->s_dqh;
 
 		for (cnt = 0, dirty = 0; cnt < MAXQUOTAS; cnt++)
-			if ((type == cnt || type == -1) && sb_has_quota_enabled(sb, cnt)
-			    && info_any_dquot_dirty(&sb_dqopt(sb)->info[cnt]))
+			if ((type == cnt || type == -1) && dqh_has_quota_enabled(dqh, cnt)
+			    && info_any_dquot_dirty(&dqh_dqopt(dqh)->info[cnt]))
 				dirty = 1;
 		if (!dirty)
 			continue;
@@ -133,23 +134,33 @@ restart:
 	return NULL;
 }
 
+void sync_dquots_dqh(struct dqhash *hash, int type)
+{
+        if (hash->dqh_qcop->quota_sync)
+                hash->dqh_qcop->quota_sync(hash, type);
+}
+
 void sync_dquots(struct super_block *sb, int type)
 {
+        struct dqhash *dqh;
+
 	if (sb) {
-		if (sb->s_qcop->quota_sync)
-			sb->s_qcop->quota_sync(sb, type);
-	}
-	else {
-		while ((sb = get_super_to_sync(type))) {
-			if (sb->s_qcop->quota_sync)
-				sb->s_qcop->quota_sync(sb, type);
-			drop_super(sb);
-		}
+		dqh = sb->s_dqh;
+		if (dqh && dqh->dqh_qcop->quota_sync)
+			dqh->dqh_qcop->quota_sync(dqh, type);
 	}
+        else {
+                while ((sb = get_super_to_sync(type))) {
+			dqh = sb->s_dqh;
+                        if (dqh && dqh->dqh_qcop->quota_sync)
+                                dqh->dqh_qcop->quota_sync(dqh, type);
+                        drop_super(sb);
+                }
+        }
 }
 
 /* Copy parameters and call proper function */
-static int do_quotactl(struct super_block *sb, int type, int cmd, qid_t id, caddr_t addr)
+static int do_quotactl(struct dqhash *hash, int type, int cmd, qid_t id, caddr_t addr)
 {
 	int ret;
 
@@ -159,23 +170,23 @@ static int do_quotactl(struct super_bloc
 
 			if (IS_ERR(pathname = getname(addr)))
 				return PTR_ERR(pathname);
-			ret = sb->s_qcop->quota_on(sb, type, id, pathname);
+			ret = hash->dqh_qcop->quota_on(hash, type, id, pathname);
 			putname(pathname);
 			return ret;
 		}
 		case Q_QUOTAOFF:
-			return sb->s_qcop->quota_off(sb, type);
+			return hash->dqh_qcop->quota_off(hash, type);
 
 		case Q_GETFMT: {
 			__u32 fmt;
 
-			down_read(&sb_dqopt(sb)->dqptr_sem);
-			if (!sb_has_quota_enabled(sb, type)) {
-				up_read(&sb_dqopt(sb)->dqptr_sem);
+			down_read(&dqh_dqopt(hash)->dqptr_sem);
+			if (!dqh_has_quota_enabled(hash, type)) {
+				up_read(&dqh_dqopt(hash)->dqptr_sem);
 				return -ESRCH;
 			}
-			fmt = sb_dqopt(sb)->info[type].dqi_format->qf_fmt_id;
-			up_read(&sb_dqopt(sb)->dqptr_sem);
+			fmt = dqh_dqopt(hash)->info[type].dqi_format->qf_fmt_id;
+			up_read(&dqh_dqopt(hash)->dqptr_sem);
 			if (copy_to_user(addr, &fmt, sizeof(fmt)))
 				return -EFAULT;
 			return 0;
@@ -183,7 +194,7 @@ static int do_quotactl(struct super_bloc
 		case Q_GETINFO: {
 			struct if_dqinfo info;
 
-			if ((ret = sb->s_qcop->get_info(sb, type, &info)))
+			if ((ret = hash->dqh_qcop->get_info(hash, type, &info)))
 				return ret;
 			if (copy_to_user(addr, &info, sizeof(info)))
 				return -EFAULT;
@@ -194,12 +205,12 @@ static int do_quotactl(struct super_bloc
 
 			if (copy_from_user(&info, addr, sizeof(info)))
 				return -EFAULT;
-			return sb->s_qcop->set_info(sb, type, &info);
+			return hash->dqh_qcop->set_info(hash, type, &info);
 		}
 		case Q_GETQUOTA: {
 			struct if_dqblk idq;
 
-			if ((ret = sb->s_qcop->get_dqblk(sb, type, id, &idq)))
+			if ((ret = hash->dqh_qcop->get_dqblk(hash, type, id, &idq)))
 				return ret;
 			if (copy_to_user(addr, &idq, sizeof(idq)))
 				return -EFAULT;
@@ -210,10 +221,10 @@ static int do_quotactl(struct super_bloc
 
 			if (copy_from_user(&idq, addr, sizeof(idq)))
 				return -EFAULT;
-			return sb->s_qcop->set_dqblk(sb, type, id, &idq);
+			return hash->dqh_qcop->set_dqblk(hash, type, id, &idq);
 		}
 		case Q_SYNC:
-			sync_dquots(sb, type);
+			sync_dquots_dqh(hash, type);
 			return 0;
 
 		case Q_XQUOTAON:
@@ -223,12 +234,12 @@ static int do_quotactl(struct super_bloc
 
 			if (copy_from_user(&flags, addr, sizeof(flags)))
 				return -EFAULT;
-			return sb->s_qcop->set_xstate(sb, flags, cmd);
+			return hash->dqh_qcop->set_xstate(hash, flags, cmd);
 		}
 		case Q_XGETQSTAT: {
 			struct fs_quota_stat fqs;
 		
-			if ((ret = sb->s_qcop->get_xstate(sb, &fqs)))
+			if ((ret = hash->dqh_qcop->get_xstate(hash, &fqs)))
 				return ret;
 			if (copy_to_user(addr, &fqs, sizeof(fqs)))
 				return -EFAULT;
@@ -239,12 +250,12 @@ static int do_quotactl(struct super_bloc
 
 			if (copy_from_user(&fdq, addr, sizeof(fdq)))
 				return -EFAULT;
-		       return sb->s_qcop->set_xquota(sb, type, id, &fdq);
+		       return hash->dqh_qcop->set_xquota(hash, type, id, &fdq);
 		}
 		case Q_XGETQUOTA: {
 			struct fs_disk_quota fdq;
 
-			if ((ret = sb->s_qcop->get_xquota(sb, type, id, &fdq)))
+			if ((ret = hash->dqh_qcop->get_xquota(hash, type, id, &fdq)))
 				return ret;
 			if (copy_to_user(addr, &fdq, sizeof(fdq)))
 				return -EFAULT;
@@ -267,6 +278,7 @@ asmlinkage long sys_quotactl(unsigned in
 {
 	uint cmds, type;
 	struct super_block *sb = NULL;
+	struct dqhash *dqh = NULL;
 	struct block_device *bdev;
 	char *tmp;
 	int ret;
@@ -287,10 +299,11 @@ asmlinkage long sys_quotactl(unsigned in
 		if (!sb)
 			return -ENODEV;
 	}
-
-	ret = check_quotactl_valid(sb, type, cmds, id);
+	if (sb)
+                dqh = sb->s_dqh;
+	ret = check_quotactl_valid(dqh, type, cmds, id);
 	if (ret >= 0)
-		ret = do_quotactl(sb, type, cmds, id, addr);
+		ret = do_quotactl(dqh, type, cmds, id, addr);
 	if (sb)
 		drop_super(sb);
 
diff -NurpP --minimal linux-2.6.5/fs/quota_v1.c linux-2.6.5-vs1.9.0pre2/fs/quota_v1.c
--- linux-2.6.5/fs/quota_v1.c	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/quota_v1.c	2004-04-05 00:55:18.000000000 +0200
@@ -46,7 +46,7 @@ static int v1_read_dqblk(struct dquot *d
 	loff_t offset;
 	struct v1_disk_dqblk dqblk;
 
-	filp = sb_dqopt(dquot->dq_sb)->files[type];
+	filp = dqh_dqopt(dquot->dq_dqh)->files[type];
 	if (filp == (struct file *)NULL)
 		return -EINVAL;
 
@@ -75,7 +75,7 @@ static int v1_commit_dqblk(struct dquot 
 	ssize_t ret;
 	struct v1_disk_dqblk dqblk;
 
-	filp = sb_dqopt(dquot->dq_sb)->files[type];
+	filp = dqh_dqopt(dquot->dq_dqh)->files[type];
 	offset = v1_dqoff(dquot->dq_id);
 	fs = get_fs();
 	set_fs(KERNEL_DS);
@@ -87,8 +87,8 @@ static int v1_commit_dqblk(struct dquot 
 	v1_mem2disk_dqblk(&dqblk, &dquot->dq_dqb);
 	dquot->dq_flags &= ~DQ_MOD;
 	if (dquot->dq_id == 0) {
-		dqblk.dqb_btime = sb_dqopt(dquot->dq_sb)->info[type].dqi_bgrace;
-		dqblk.dqb_itime = sb_dqopt(dquot->dq_sb)->info[type].dqi_igrace;
+		dqblk.dqb_btime = dqh_dqopt(dquot->dq_dqh)->info[type].dqi_bgrace;
+		dqblk.dqb_itime = dqh_dqopt(dquot->dq_dqh)->info[type].dqi_igrace;
 	}
 	ret = 0;
 	if (filp)
@@ -96,7 +96,7 @@ static int v1_commit_dqblk(struct dquot 
 					sizeof(struct v1_disk_dqblk), &offset);
 	if (ret != sizeof(struct v1_disk_dqblk)) {
 		printk(KERN_WARNING "VFS: dquota write failed on dev %s\n",
-			dquot->dq_sb->s_id);
+			dquot->dq_dqh->dqh_sb->s_id);
 		if (ret >= 0)
 			ret = -EIO;
 		goto out;
@@ -122,9 +122,9 @@ struct v2_disk_dqheader {
 	__u32 dqh_version;      /* File version */
 };
 
-static int v1_check_quota_file(struct super_block *sb, int type)
+static int v1_check_quota_file(struct dqhash *hash, int type)
 {
-	struct file *f = sb_dqopt(sb)->files[type];
+	struct file *f = dqh_dqopt(hash)->files[type];
 	struct inode *inode = f->f_dentry->d_inode;
 	ulong blocks;
 	size_t off; 
@@ -151,13 +151,13 @@ static int v1_check_quota_file(struct su
 		return 1;	/* Probably not new format */
 	if (le32_to_cpu(dqhead.dqh_magic) != quota_magics[type])
 		return 1;	/* Definitely not new format */
-	printk(KERN_INFO "VFS: %s: Refusing to turn on old quota format on given file. It probably contains newer quota format.\n", sb->s_id);
+	printk(KERN_INFO "VFS: Refusing to turn on old quota format on given file. It probably contains newer quota format.\n");
         return 0;		/* Seems like a new format file -> refuse it */
 }
 
-static int v1_read_file_info(struct super_block *sb, int type)
+static int v1_read_file_info(struct dqhash *hash, int type)
 {
-	struct quota_info *dqopt = sb_dqopt(sb);
+	struct quota_info *dqopt = dqh_dqopt(hash);
 	mm_segment_t fs;
 	loff_t offset;
 	struct file *filp = dqopt->files[type];
@@ -180,9 +180,9 @@ out:
 	return ret;
 }
 
-static int v1_write_file_info(struct super_block *sb, int type)
+static int v1_write_file_info(struct dqhash *hash, int type)
 {
-	struct quota_info *dqopt = sb_dqopt(sb);
+	struct quota_info *dqopt = dqh_dqopt(hash);
 	mm_segment_t fs;
 	struct file *filp = dqopt->files[type];
 	struct v1_disk_dqblk dqblk;
diff -NurpP --minimal linux-2.6.5/fs/quota_v2.c linux-2.6.5-vs1.9.0pre2/fs/quota_v2.c
--- linux-2.6.5/fs/quota_v2.c	2004-03-11 03:55:43.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/quota_v2.c	2004-04-05 00:55:18.000000000 +0200
@@ -27,10 +27,10 @@ typedef char *dqbuf_t;
 #define GETENTRIES(buf) ((struct v2_disk_dqblk *)(((char *)buf)+sizeof(struct v2_disk_dqdbheader)))
 
 /* Check whether given file is really vfsv0 quotafile */
-static int v2_check_quota_file(struct super_block *sb, int type)
+static int v2_check_quota_file(struct dqhash *hash, int type)
 {
 	struct v2_disk_dqheader dqhead;
-	struct file *f = sb_dqopt(sb)->files[type];
+	struct file *f = dqh_dqopt(hash)->files[type];
 	mm_segment_t fs;
 	ssize_t size;
 	loff_t offset = 0;
@@ -50,12 +50,12 @@ static int v2_check_quota_file(struct su
 }
 
 /* Read information header from quota file */
-static int v2_read_file_info(struct super_block *sb, int type)
+static int v2_read_file_info(struct dqhash *hash, int type)
 {
 	mm_segment_t fs;
 	struct v2_disk_dqinfo dinfo;
-	struct mem_dqinfo *info = sb_dqopt(sb)->info+type;
-	struct file *f = sb_dqopt(sb)->files[type];
+	struct mem_dqinfo *info = dqh_dqopt(hash)->info+type;
+	struct file *f = dqh_dqopt(hash)->files[type];
 	ssize_t size;
 	loff_t offset = V2_DQINFOOFF;
 
@@ -78,12 +78,12 @@ static int v2_read_file_info(struct supe
 }
 
 /* Write information header to quota file */
-static int v2_write_file_info(struct super_block *sb, int type)
+static int v2_write_file_info(struct dqhash *hash, int type)
 {
 	mm_segment_t fs;
 	struct v2_disk_dqinfo dinfo;
-	struct mem_dqinfo *info = sb_dqopt(sb)->info+type;
-	struct file *f = sb_dqopt(sb)->files[type];
+	struct mem_dqinfo *info = dqh_dqopt(hash)->info+type;
+	struct file *f = dqh_dqopt(hash)->files[type];
 	ssize_t size;
 	loff_t offset = V2_DQINFOOFF;
 
@@ -286,8 +286,8 @@ out_buf:
 /* Find space for dquot */
 static uint find_free_dqentry(struct dquot *dquot, int *err)
 {
-	struct file *filp = sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
-	struct mem_dqinfo *info = sb_dqopt(dquot->dq_sb)->info+dquot->dq_type;
+	struct file *filp = dqh_dqopt(dquot->dq_dqh)->files[dquot->dq_type];
+	struct mem_dqinfo *info = dqh_dqopt(dquot->dq_dqh)->info+dquot->dq_type;
 	uint blk, i;
 	struct v2_disk_dqdbheader *dh;
 	struct v2_disk_dqblk *ddquot;
@@ -348,8 +348,8 @@ out_buf:
 /* Insert reference to structure into the trie */
 static int do_insert_tree(struct dquot *dquot, uint *treeblk, int depth)
 {
-	struct file *filp = sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
-	struct mem_dqinfo *info = sb_dqopt(dquot->dq_sb)->info + dquot->dq_type;
+	struct file *filp = dqh_dqopt(dquot->dq_dqh)->files[dquot->dq_type];
+	struct mem_dqinfo *info = dqh_dqopt(dquot->dq_dqh)->info + dquot->dq_type;
 	dqbuf_t buf;
 	int ret = 0, newson = 0, newact = 0;
 	u32 *ref;
@@ -422,7 +422,7 @@ static int v2_write_dquot(struct dquot *
 			printk(KERN_ERR "VFS: Error %Zd occurred while creating quota.\n", ret);
 			return ret;
 		}
-	filp = sb_dqopt(dquot->dq_sb)->files[type];
+	filp = dqh_dqopt(dquot->dq_dqh)->files[type];
 	offset = dquot->dq_off;
 	mem2diskdqb(&ddquot, &dquot->dq_dqb, dquot->dq_id);
 	fs = get_fs();
@@ -430,7 +430,7 @@ static int v2_write_dquot(struct dquot *
 	ret = filp->f_op->write(filp, (char *)&ddquot, sizeof(struct v2_disk_dqblk), &offset);
 	set_fs(fs);
 	if (ret != sizeof(struct v2_disk_dqblk)) {
-		printk(KERN_WARNING "VFS: dquota write failed on dev %s\n", dquot->dq_sb->s_id);
+		printk(KERN_WARNING "VFS: dquota write failed on dev %s\n", dquot->dq_dqh->dqh_sb->s_id);
 		if (ret >= 0)
 			ret = -ENOSPC;
 	}
@@ -444,8 +444,8 @@ static int v2_write_dquot(struct dquot *
 /* Free dquot entry in data block */
 static int free_dqentry(struct dquot *dquot, uint blk)
 {
-	struct file *filp = sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
-	struct mem_dqinfo *info = sb_dqopt(dquot->dq_sb)->info + dquot->dq_type;
+	struct file *filp = dqh_dqopt(dquot->dq_dqh)->files[dquot->dq_type];
+	struct mem_dqinfo *info = dqh_dqopt(dquot->dq_dqh)->info + dquot->dq_type;
 	struct v2_disk_dqdbheader *dh;
 	dqbuf_t buf = getdqbuf();
 	int ret = 0;
@@ -493,8 +493,8 @@ out_buf:
 /* Remove reference to dquot from tree */
 static int remove_tree(struct dquot *dquot, uint *blk, int depth)
 {
-	struct file *filp = sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
-	struct mem_dqinfo *info = sb_dqopt(dquot->dq_sb)->info + dquot->dq_type;
+	struct file *filp = dqh_dqopt(dquot->dq_dqh)->files[dquot->dq_type];
+	struct mem_dqinfo *info = dqh_dqopt(dquot->dq_dqh)->info + dquot->dq_type;
 	dqbuf_t buf = getdqbuf();
 	int ret = 0;
 	uint newblk;
@@ -543,7 +543,7 @@ static int v2_delete_dquot(struct dquot 
 /* Find entry in block */
 static loff_t find_block_dqentry(struct dquot *dquot, uint blk)
 {
-	struct file *filp = sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
+	struct file *filp = dqh_dqopt(dquot->dq_dqh)->files[dquot->dq_type];
 	dqbuf_t buf = getdqbuf();
 	loff_t ret = 0;
 	int i;
@@ -580,7 +580,7 @@ out_buf:
 /* Find entry for given id in the tree */
 static loff_t find_tree_dqentry(struct dquot *dquot, uint blk, int depth)
 {
-	struct file *filp = sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
+	struct file *filp = dqh_dqopt(dquot->dq_dqh)->files[dquot->dq_type];
 	dqbuf_t buf = getdqbuf();
 	loff_t ret = 0;
 	u32 *ref = (u32 *)buf;
@@ -619,10 +619,10 @@ static int v2_read_dquot(struct dquot *d
 	struct v2_disk_dqblk ddquot;
 	int ret = 0;
 
-	filp = sb_dqopt(dquot->dq_sb)->files[type];
+	filp = dqh_dqopt(dquot->dq_dqh)->files[type];
 
 #ifdef __QUOTA_V2_PARANOIA
-	if (!filp || !dquot->dq_sb) {	/* Invalidated quota? */
+	if (!filp || !dquot->dq_dqh) {	/* Invalidated quota? */
 		printk(KERN_ERR "VFS: Quota invalidated while reading!\n");
 		return -EIO;
 	}
diff -NurpP --minimal linux-2.6.5/fs/reiserfs/inode.c linux-2.6.5-vs1.9.0pre2/fs/reiserfs/inode.c
--- linux-2.6.5/fs/reiserfs/inode.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/reiserfs/inode.c	2004-04-05 00:55:19.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/buffer_head.h>
 #include <linux/mpage.h>
 #include <linux/writeback.h>
+#include <linux/vserver/xid.h>
 
 extern int reiserfs_default_io_size; /* default io size devuned in super.c */
 
@@ -955,6 +956,8 @@ static void init_inode (struct inode * i
     struct buffer_head * bh;
     struct item_head * ih;
     __u32 rdev;
+    uid_t uid;
+    gid_t gid;
     //int version = ITEM_VERSION_1;
 
     bh = PATH_PLAST_BUFFER (path);
@@ -975,12 +978,13 @@ static void init_inode (struct inode * i
 	struct stat_data_v1 * sd = (struct stat_data_v1 *)B_I_PITEM (bh, ih);
 	unsigned long blocks;
 
+	uid = sd_v1_uid(sd);
+	gid = sd_v1_gid(sd);
+
 	set_inode_item_key_version (inode, KEY_FORMAT_3_5);
         set_inode_sd_version (inode, STAT_DATA_V1);
 	inode->i_mode  = sd_v1_mode(sd);
 	inode->i_nlink = sd_v1_nlink(sd);
-	inode->i_uid   = sd_v1_uid(sd);
-	inode->i_gid   = sd_v1_gid(sd);
 	inode->i_size  = sd_v1_size(sd);
 	inode->i_atime.tv_sec = sd_v1_atime(sd);
 	inode->i_mtime.tv_sec = sd_v1_mtime(sd);
@@ -1012,11 +1016,12 @@ static void init_inode (struct inode * i
 	// (directories and symlinks)
 	struct stat_data * sd = (struct stat_data *)B_I_PITEM (bh, ih);
 
+	uid    = sd_v2_uid(sd);
+	gid    = sd_v2_gid(sd);
+
 	inode->i_mode   = sd_v2_mode(sd);
 	inode->i_nlink  = sd_v2_nlink(sd);
-	inode->i_uid    = sd_v2_uid(sd);
 	inode->i_size   = sd_v2_size(sd);
-	inode->i_gid    = sd_v2_gid(sd);
 	inode->i_mtime.tv_sec  = sd_v2_mtime(sd);
 	inode->i_atime.tv_sec = sd_v2_atime(sd);
 	inode->i_ctime.tv_sec  = sd_v2_ctime(sd);
@@ -1041,6 +1046,9 @@ static void init_inode (struct inode * i
 	REISERFS_I(inode)->i_attrs = sd_v2_attrs( sd );
 	sd_attrs_to_i_attrs( sd_v2_attrs( sd ), inode );
     }
+    inode->i_uid = INOXID_UID(uid, gid);
+    inode->i_gid = INOXID_GID(uid, gid);
+    inode->i_xid = INOXID_XID(uid, gid, 0);
 
     pathrelse (path);
     if (S_ISREG (inode->i_mode)) {
@@ -1064,13 +1072,15 @@ static void init_inode (struct inode * i
 static void inode2sd (void * sd, struct inode * inode)
 {
     struct stat_data * sd_v2 = (struct stat_data *)sd;
+    uid_t uid = XIDINO_UID(inode->i_uid, inode->i_xid);
+    gid_t gid = XIDINO_GID(inode->i_gid, inode->i_xid);
     __u16 flags;
 
+    set_sd_v2_uid(sd_v2, uid );
+    set_sd_v2_gid(sd_v2, gid );
     set_sd_v2_mode(sd_v2, inode->i_mode );
     set_sd_v2_nlink(sd_v2, inode->i_nlink );
-    set_sd_v2_uid(sd_v2, inode->i_uid );
     set_sd_v2_size(sd_v2, inode->i_size );
-    set_sd_v2_gid(sd_v2, inode->i_gid );
     set_sd_v2_mtime(sd_v2, inode->i_mtime.tv_sec );
     set_sd_v2_atime(sd_v2, inode->i_atime.tv_sec );
     set_sd_v2_ctime(sd_v2, inode->i_ctime.tv_sec );
@@ -2295,6 +2305,14 @@ void sd_attrs_to_i_attrs( __u16 sd_attrs
 			inode -> i_flags |= S_IMMUTABLE;
 		else
 			inode -> i_flags &= ~S_IMMUTABLE;
+		if( sd_attrs & REISERFS_IUNLINK_FL )
+			inode -> i_flags |= S_IUNLINK;
+		else
+			inode -> i_flags &= ~S_IUNLINK;
+		if( sd_attrs & REISERFS_BARRIER_FL )
+			inode -> i_flags |= S_BARRIER;
+		else
+			inode -> i_flags &= ~S_BARRIER;
 		if( sd_attrs & REISERFS_APPEND_FL )
 			inode -> i_flags |= S_APPEND;
 		else
@@ -2317,6 +2335,14 @@ void i_attrs_to_sd_attrs( struct inode *
 			*sd_attrs |= REISERFS_IMMUTABLE_FL;
 		else
 			*sd_attrs &= ~REISERFS_IMMUTABLE_FL;
+		if( inode -> i_flags & S_IUNLINK )
+			*sd_attrs |= REISERFS_IUNLINK_FL;
+		else
+			*sd_attrs &= ~REISERFS_IUNLINK_FL;
+		if( inode -> i_flags & S_BARRIER )
+			*sd_attrs |= REISERFS_BARRIER_FL;
+		else
+			*sd_attrs &= ~REISERFS_BARRIER_FL;
 		if( inode -> i_flags & S_SYNC )
 			*sd_attrs |= REISERFS_SYNC_FL;
 		else
diff -NurpP --minimal linux-2.6.5/fs/reiserfs/ioctl.c linux-2.6.5-vs1.9.0pre2/fs/reiserfs/ioctl.c
--- linux-2.6.5/fs/reiserfs/ioctl.c	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/fs/reiserfs/ioctl.c	2004-04-05 00:55:13.000000000 +0200
@@ -47,7 +47,8 @@ int reiserfs_ioctl (struct inode * inode
 		if (get_user(flags, (int *) arg))
 			return -EFAULT;
 
-		if ( ( ( flags ^ REISERFS_I(inode) -> i_attrs) & ( REISERFS_IMMUTABLE_FL | REISERFS_APPEND_FL)) &&
+		if ( ( ( flags ^ REISERFS_I(inode) -> i_attrs) &
+		   ( REISERFS_IMMUTABLE_FL | REISERFS_IUNLINK_FL | REISERFS_APPEND_FL)) &&
 		     !capable( CAP_LINUX_IMMUTABLE ) )
 			return -EPERM;
 			
diff -NurpP --minimal linux-2.6.5/fs/super.c linux-2.6.5-vs1.9.0pre2/fs/super.c
--- linux-2.6.5/fs/super.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/super.c	2004-04-05 00:55:18.000000000 +0200
@@ -74,13 +74,12 @@ static struct super_block *alloc_super(v
 		s->s_count = S_BIAS;
 		atomic_set(&s->s_active, 1);
 		sema_init(&s->s_vfs_rename_sem,1);
-		sema_init(&s->s_dquot.dqio_sem, 1);
-		sema_init(&s->s_dquot.dqonoff_sem, 1);
-		init_rwsem(&s->s_dquot.dqptr_sem);
 		s->s_maxbytes = MAX_NON_LFS;
-		s->dq_op = sb_dquot_ops;
+		s->s_qop = sb_dquot_ops;
 		s->s_qcop = sb_quotactl_ops;
 		s->s_op = &default_op;
+		/* quick hack to make dqhash id unique, sufficient for now */
+		s->s_dqh = new_dqhash(s, (unsigned int)s);
 	}
 out:
 	return s;
@@ -95,6 +94,7 @@ out:
 static inline void destroy_super(struct super_block *s)
 {
 	security_sb_free(s);
+	dqhput(s->s_dqh);
 	kfree(s);
 }
 
diff -NurpP --minimal linux-2.6.5/fs/udf/super.c linux-2.6.5-vs1.9.0pre2/fs/udf/super.c
--- linux-2.6.5/fs/udf/super.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/udf/super.c	2004-04-05 00:55:18.000000000 +0200
@@ -1560,7 +1560,7 @@ static int udf_fill_super(struct super_b
 
 	/* Fill in the rest of the superblock */
 	sb->s_op = &udf_sb_ops;
-	sb->dq_op = NULL;
+	sb->s_qop = NULL;
 	sb->s_dirt = 0;
 	sb->s_magic = UDF_SUPER_MAGIC;
 
diff -NurpP --minimal linux-2.6.5/fs/ufs/super.c linux-2.6.5-vs1.9.0pre2/fs/ufs/super.c
--- linux-2.6.5/fs/ufs/super.c	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/fs/ufs/super.c	2004-04-05 00:55:18.000000000 +0200
@@ -869,7 +869,7 @@ magic_found:
 	 * Read ufs_super_block into internal data structures
 	 */
 	sb->s_op = &ufs_super_ops;
-	sb->dq_op = NULL; /***/
+	sb->s_qop = NULL; /***/
 	sb->s_magic = fs32_to_cpu(sb, usb3->fs_magic);
 
 	uspi->s_sblkno = fs32_to_cpu(sb, usb1->fs_sblkno);
diff -NurpP --minimal linux-2.6.5/include/asm-alpha/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-alpha/unistd.h
--- linux-2.6.5/include/asm-alpha/unistd.h	2004-04-04 18:03:11.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-alpha/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -233,6 +233,7 @@
 #define __NR_osf_memcntl	260	/* not implemented */
 #define __NR_osf_fdatasync	261	/* not implemented */
 
+#define __NR_vserver		273
 
 /*
  * Linux-specific system calls begin at 300
diff -NurpP --minimal linux-2.6.5/include/asm-arm/tlb.h linux-2.6.5-vs1.9.0pre2/include/asm-arm/tlb.h
--- linux-2.6.5/include/asm-arm/tlb.h	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-arm/tlb.h	2004-04-05 00:55:18.000000000 +0200
@@ -57,7 +57,8 @@ tlb_finish_mmu(struct mmu_gather *tlb, u
 
 	if (rss < freed)
 		freed = rss;
-	mm->rss = rss - freed;
+	// mm->rss = rss - freed;
+	vx_rsspages_sub(mm, freed);
 
 	if (freed) {
 		flush_tlb_mm(mm);
diff -NurpP --minimal linux-2.6.5/include/asm-arm26/tlb.h linux-2.6.5-vs1.9.0pre2/include/asm-arm26/tlb.h
--- linux-2.6.5/include/asm-arm26/tlb.h	2004-03-11 03:55:54.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-arm26/tlb.h	2004-04-05 00:55:18.000000000 +0200
@@ -38,7 +38,8 @@ tlb_finish_mmu(struct mmu_gather *tlb, u
 
         if (rss < freed)
                 freed = rss;
-        mm->rss = rss - freed;
+        // mm->rss = rss - freed;
+	vx_rsspages_sub(mm, freed);
 
         if (freed) {
                 flush_tlb_mm(mm);
diff -NurpP --minimal linux-2.6.5/include/asm-generic/tlb.h linux-2.6.5-vs1.9.0pre2/include/asm-generic/tlb.h
--- linux-2.6.5/include/asm-generic/tlb.h	2004-03-11 03:55:20.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-generic/tlb.h	2004-04-05 00:55:18.000000000 +0200
@@ -15,6 +15,7 @@
 
 #include <linux/config.h>
 #include <linux/swap.h>
+#include <linux/vinline.h>
 #include <asm/tlbflush.h>
 
 /*
@@ -91,7 +92,8 @@ tlb_finish_mmu(struct mmu_gather *tlb, u
 
 	if (rss < freed)
 		freed = rss;
-	mm->rss = rss - freed;
+	// mm->rss = rss - freed;
+	vx_rsspages_sub(mm, freed);
 	tlb_flush_mmu(tlb, start, end);
 
 	/* keep the page table cache within bounds */
diff -NurpP --minimal linux-2.6.5/include/asm-ia64/tlb.h linux-2.6.5-vs1.9.0pre2/include/asm-ia64/tlb.h
--- linux-2.6.5/include/asm-ia64/tlb.h	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-ia64/tlb.h	2004-04-05 00:55:18.000000000 +0200
@@ -163,7 +163,8 @@ tlb_finish_mmu (struct mmu_gather *tlb, 
 
 	if (rss < freed)
 		freed = rss;
-	mm->rss = rss - freed;
+	// mm->rss = rss - freed;
+	vx_rsspages_sub(mm, freed);
 	/*
 	 * Note: tlb->nr may be 0 at this point, so we can't rely on tlb->start_addr and
 	 * tlb->end_addr.
diff -NurpP --minimal linux-2.6.5/include/asm-m68k/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-m68k/unistd.h
--- linux-2.6.5/include/asm-m68k/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-m68k/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -239,7 +239,9 @@
 #define __NR_fremovexattr	234
 #define __NR_futex		235
 
-#define NR_syscalls		236
+#define __NR_vserver		273
+
+#define NR_syscalls		274
 
 /* user-visible error numbers are in the range -1 - -124: see
    <asm-m68k/errno.h> */
diff -NurpP --minimal linux-2.6.5/include/asm-m68knommu/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-m68knommu/unistd.h
--- linux-2.6.5/include/asm-m68knommu/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-m68knommu/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -221,7 +221,9 @@
 #define __NR_setfsuid32		215
 #define __NR_setfsgid32		216
 
-#define	NR_syscalls		256
+#define __NR_vserver		273
+
+#define	NR_syscalls		274
 
 /* user-visible error numbers are in the range -1 - -122: see
    <asm-m68k/errno.h> */
diff -NurpP --minimal linux-2.6.5/include/asm-mips/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-mips/unistd.h
--- linux-2.6.5/include/asm-mips/unistd.h	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-mips/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -289,10 +289,12 @@
 #define __NR_tgkill			(__NR_Linux + 266)
 #define __NR_utimes			(__NR_Linux + 267)
 
+#define __NR_vserver			(__NR_Linux + 273)
+
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		267
+#define __NR_Linux_syscalls		273
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
diff -NurpP --minimal linux-2.6.5/include/asm-parisc/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-parisc/unistd.h
--- linux-2.6.5/include/asm-parisc/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-parisc/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -722,8 +722,9 @@
 #define __NR_remap_file_pages	(__NR_Linux + 227)
 #define __NR_semtimedop		(__NR_Linux + 228)
 
+#define __NR_vserver		(__NR_Linux + 273)
 
-#define __NR_Linux_syscalls     228
+#define __NR_Linux_syscalls     273
 
 #define HPUX_GATEWAY_ADDR       0xC0000004
 #define LINUX_GATEWAY_ADDR      0x100
diff -NurpP --minimal linux-2.6.5/include/asm-ppc/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-ppc/unistd.h
--- linux-2.6.5/include/asm-ppc/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-ppc/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -261,7 +261,9 @@
 #define __NR_fadvise64_64	254
 #define __NR_rtas		255
 
-#define __NR_syscalls		256
+#define __NR_vserver		273
+
+#define __NR_syscalls		274
 
 #define __NR(n)	#n
 
diff -NurpP --minimal linux-2.6.5/include/asm-ppc64/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-ppc64/unistd.h
--- linux-2.6.5/include/asm-ppc64/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-ppc64/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -267,7 +267,9 @@
 #define __NR_fadvise64_64	254
 #define __NR_rtas		255
 
-#define __NR_syscalls		256
+#define __NR_vserver		273
+
+#define __NR_syscalls		274
 #ifdef __KERNEL__
 #define NR_syscalls	__NR_syscalls
 #endif
diff -NurpP --minimal linux-2.6.5/include/asm-s390/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-s390/unistd.h
--- linux-2.6.5/include/asm-s390/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-s390/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -256,10 +256,7 @@
 #define __NR_clock_gettime	(__NR_timer_create+6)
 #define __NR_clock_getres	(__NR_timer_create+7)
 #define __NR_clock_nanosleep	(__NR_timer_create+8)
-
-/*
- * Number 263 is reserved for vserver
- */
+#define __NR_vserver		263
 #define __NR_fadvise64_64	264
 #define __NR_statfs64		265
 #define __NR_fstatfs64		266
diff -NurpP --minimal linux-2.6.5/include/asm-sparc/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-sparc/unistd.h
--- linux-2.6.5/include/asm-sparc/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-sparc/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -283,7 +283,7 @@
 #define __NR_timer_getoverrun	264
 #define __NR_timer_delete	265
 #define __NR_timer_create	266
-/* #define __NR_vserver		267 Reserved for VSERVER */
+#define __NR_vserver		267
 #define __NR_io_setup		268
 #define __NR_io_destroy		269
 #define __NR_io_submit		270
diff -NurpP --minimal linux-2.6.5/include/asm-sparc64/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-sparc64/unistd.h
--- linux-2.6.5/include/asm-sparc64/unistd.h	2004-04-04 18:03:12.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/asm-sparc64/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -285,7 +285,7 @@
 #define __NR_timer_getoverrun	264
 #define __NR_timer_delete	265
 #define __NR_timer_create	266
-/* #define __NR_vserver		267 Reserved for VSERVER */
+#define __NR_vserver		267
 #define __NR_io_setup		268
 #define __NR_io_destroy		269
 #define __NR_io_submit		270
diff -NurpP --minimal linux-2.6.5/include/asm-x86_64/ia32_unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-x86_64/ia32_unistd.h
--- linux-2.6.5/include/asm-x86_64/ia32_unistd.h	2004-03-11 03:55:35.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-x86_64/ia32_unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -278,6 +278,7 @@
 #define __NR_ia32_tgkill		270
 #define __NR_ia32_utimes		271
 #define __NR_ia32_fadvise64_64		272
+#define __NR_ia32_vserver		273
 
 #define IA32_NR_syscalls 275	/* must be > than biggest syscall! */	
 
diff -NurpP --minimal linux-2.6.5/include/asm-x86_64/unistd.h linux-2.6.5-vs1.9.0pre2/include/asm-x86_64/unistd.h
--- linux-2.6.5/include/asm-x86_64/unistd.h	2004-03-11 03:55:36.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/asm-x86_64/unistd.h	2004-04-05 00:55:13.000000000 +0200
@@ -531,7 +531,7 @@ __SYSCALL(__NR_tgkill, sys_tgkill)
 #define __NR_utimes		235
 __SYSCALL(__NR_utimes, sys_utimes)
 #define __NR_vserver		236
-__SYSCALL(__NR_vserver, sys_ni_syscall)
+__SYSCALL(__NR_vserver, sys_vserver)
 
 /* 237,238,239 reserved for NUMA API */
 
diff -NurpP --minimal linux-2.6.5/include/linux/capability.h linux-2.6.5-vs1.9.0pre2/include/linux/capability.h
--- linux-2.6.5/include/linux/capability.h	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/capability.h	2004-04-05 00:55:16.000000000 +0200
@@ -235,6 +235,7 @@ typedef __u32 kernel_cap_t;
 /* Allow enabling/disabling tagged queuing on SCSI controllers and sending
    arbitrary SCSI commands */
 /* Allow setting encryption key on loopback filesystem */
+/* Allow the selection of a security context */
 
 #define CAP_SYS_ADMIN        21
 
@@ -284,6 +285,15 @@ typedef __u32 kernel_cap_t;
 
 #define CAP_LEASE            28
 
+/* Allow quotactl */
+
+#define CAP_QUOTACTL         29
+
+/* Allow context manipulations */
+/* Allow changing context info on files */
+
+#define CAP_CONTEXT          30
+
 #ifdef __KERNEL__
 /* 
  * Bounding set
diff -NurpP --minimal linux-2.6.5/include/linux/ext2_fs.h linux-2.6.5-vs1.9.0pre2/include/linux/ext2_fs.h
--- linux-2.6.5/include/linux/ext2_fs.h	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/ext2_fs.h	2004-04-05 00:55:19.000000000 +0200
@@ -192,10 +192,12 @@ struct ext2_group_desc
 #define EXT2_NOTAIL_FL			0x00008000 /* file tail should not be merged */
 #define EXT2_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
 #define EXT2_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
+#define EXT2_BARRIER_FL			0x04000000 /* chroot barrier */
+#define EXT2_IUNLINK_FL			0x08000000 /* Immutable unlink */
 #define EXT2_RESERVED_FL		0x80000000 /* reserved for ext2 lib */
 
-#define EXT2_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
-#define EXT2_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
+#define EXT2_FL_USER_VISIBLE		0x0c03DFFF /* User visible flags */
+#define EXT2_FL_USER_MODIFIABLE		0x0c0380FF /* User modifiable flags */
 
 /*
  * ioctl commands
@@ -240,7 +242,7 @@ struct ext2_inode {
 		struct {
 			__u8	l_i_frag;	/* Fragment number */
 			__u8	l_i_fsize;	/* Fragment size */
-			__u16	i_pad1;
+			__u16	l_i_xid;	/* LRU Context */
 			__u16	l_i_uid_high;	/* these 2 fields    */
 			__u16	l_i_gid_high;	/* were reserved2[0] */
 			__u32	l_i_reserved2;
@@ -272,6 +274,7 @@ struct ext2_inode {
 #define i_gid_low	i_gid
 #define i_uid_high	osd2.linux2.l_i_uid_high
 #define i_gid_high	osd2.linux2.l_i_gid_high
+#define i_raw_xid	osd2.linux2.l_i_xid
 #define i_reserved2	osd2.linux2.l_i_reserved2
 #endif
 
@@ -312,6 +315,7 @@ struct ext2_inode {
 #define EXT2_MOUNT_NO_UID32		0x0200  /* Disable 32-bit UIDs */
 #define EXT2_MOUNT_XATTR_USER		0x4000	/* Extended user attributes */
 #define EXT2_MOUNT_POSIX_ACL		0x8000	/* POSIX Access Control Lists */
+#define EXT2_MOUNT_TAG_XID		(1<<16) /* Enable Context Tags */
 
 #define clear_opt(o, opt)		o &= ~EXT2_MOUNT_##opt
 #define set_opt(o, opt)			o |= EXT2_MOUNT_##opt
diff -NurpP --minimal linux-2.6.5/include/linux/ext3_fs.h linux-2.6.5-vs1.9.0pre2/include/linux/ext3_fs.h
--- linux-2.6.5/include/linux/ext3_fs.h	2004-03-11 03:55:33.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/ext3_fs.h	2004-04-05 00:55:19.000000000 +0200
@@ -185,10 +185,12 @@ struct ext3_group_desc
 #define EXT3_NOTAIL_FL			0x00008000 /* file tail should not be merged */
 #define EXT3_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
 #define EXT3_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
+#define EXT3_BARRIER_FL			0x04000000 /* chroot barrier */
+#define EXT3_IUNLINK_FL			0x08000000 /* Immutable unlink */
 #define EXT3_RESERVED_FL		0x80000000 /* reserved for ext3 lib */
 
-#define EXT3_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
-#define EXT3_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
+#define EXT3_FL_USER_VISIBLE		0x0c03DFFF /* User visible flags */
+#define EXT3_FL_USER_MODIFIABLE		0x0c0380FF /* User modifiable flags */
 
 /*
  * Inode dynamic state flags
@@ -208,6 +210,7 @@ struct ext3_group_desc
 #ifdef CONFIG_JBD_DEBUG
 #define EXT3_IOC_WAIT_FOR_READONLY	_IOR('f', 99, long)
 #endif
+#define	EXT3_IOC_SETXID			FIOC_SETXIDJ
 
 /*
  * Structure of an inode on the disk
@@ -244,7 +247,7 @@ struct ext3_inode {
 		struct {
 			__u8	l_i_frag;	/* Fragment number */
 			__u8	l_i_fsize;	/* Fragment size */
-			__u16	i_pad1;
+			__u16	l_i_xid;	/* LRU Context */
 			__u16	l_i_uid_high;	/* these 2 fields    */
 			__u16	l_i_gid_high;	/* were reserved2[0] */
 			__u32	l_i_reserved2;
@@ -276,6 +279,7 @@ struct ext3_inode {
 #define i_gid_low	i_gid
 #define i_uid_high	osd2.linux2.l_i_uid_high
 #define i_gid_high	osd2.linux2.l_i_gid_high
+#define i_raw_xid	osd2.linux2.l_i_xid
 #define i_reserved2	osd2.linux2.l_i_reserved2
 
 #elif defined(__GNU__)
@@ -324,6 +328,7 @@ struct ext3_inode {
 #define EXT3_MOUNT_NO_UID32		0x2000  /* Disable 32-bit UIDs */
 #define EXT3_MOUNT_XATTR_USER		0x4000	/* Extended user attributes */
 #define EXT3_MOUNT_POSIX_ACL		0x8000	/* POSIX Access Control Lists */
+#define EXT3_MOUNT_TAG_XID		(1<<16) /* Enable Context Tags */
 
 /* Compatibility, for having both ext2_fs.h and ext3_fs.h included at once */
 #ifndef _LINUX_EXT2_FS_H
diff -NurpP --minimal linux-2.6.5/include/linux/fs.h linux-2.6.5-vs1.9.0pre2/include/linux/fs.h
--- linux-2.6.5/include/linux/fs.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/fs.h	2004-04-05 00:55:19.000000000 +0200
@@ -113,6 +113,7 @@ extern int leases_enable, dir_notify_ena
 #define MS_VERBOSE	32768
 #define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_ONE_SECOND	(1<<17)	/* fs has 1 sec a/m/ctime resolution */
+#define MS_TAGXID	(1<<24)	/* tag inodes with context information */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 
@@ -139,6 +140,8 @@ extern int leases_enable, dir_notify_ena
 #define S_NOQUOTA	64	/* Inode is not counted to quota */
 #define S_DIRSYNC	128	/* Directory modifications are synchronous */
 #define S_NOCMTIME	256	/* Do not update file c/mtime */
+#define S_BARRIER	512	/* chroot barrier */
+#define S_IUNLINK	1024	/* Immutable unlink */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -166,11 +169,14 @@ extern int leases_enable, dir_notify_ena
 #define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
 #define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
 #define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
+#define IS_IUNLINK(inode)	((inode)->i_flags & S_IUNLINK)
+#define IS_IXORUNLINK(inode)	((IS_IUNLINK(inode) ? S_IMMUTABLE : 0) ^ IS_IMMUTABLE(inode))
 #define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
 #define IS_NODIRATIME(inode)	__IS_FLG(inode, MS_NODIRATIME)
 #define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
 #define IS_ONE_SECOND(inode)	__IS_FLG(inode, MS_ONE_SECOND)
 
+#define IS_BARRIER(inode)	((inode)->i_flags & S_BARRIER)
 #define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
 #define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
 
@@ -385,6 +391,7 @@ struct inode {
 	unsigned int		i_nlink;
 	uid_t			i_uid;
 	gid_t			i_gid;
+	xid_t			i_xid;
 	dev_t			i_rdev;
 	loff_t			i_size;
 	struct timespec		i_atime;
@@ -403,6 +410,7 @@ struct inode {
 	struct file_lock	*i_flock;
 	struct address_space	*i_mapping;
 	struct address_space	i_data;
+	struct dqhash		*i_dqh;
 	struct dquot		*i_dquot[MAXQUOTAS];
 	/* These three should probably be a union */
 	struct list_head	i_devices;
@@ -691,7 +699,7 @@ struct super_block {
 	unsigned long long	s_maxbytes;	/* Max file size */
 	struct file_system_type	*s_type;
 	struct super_operations	*s_op;
-	struct dquot_operations	*dq_op;
+	struct dquot_operations	*s_qop;
  	struct quotactl_ops	*s_qcop;
 	struct export_operations *s_export_op;
 	unsigned long		s_flags;
@@ -712,7 +720,7 @@ struct super_block {
 
 	struct block_device	*s_bdev;
 	struct list_head	s_instances;
-	struct quota_info	s_dquot;	/* Diskquota specific options */
+	struct dqhash		*s_dqh;		/* Diskquota hash */
 
 	char s_id[32];				/* Informational name */
 
diff -NurpP --minimal linux-2.6.5/include/linux/init_task.h linux-2.6.5-vs1.9.0pre2/include/linux/init_task.h
--- linux-2.6.5/include/linux/init_task.h	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/init_task.h	2004-04-05 00:55:13.000000000 +0200
@@ -112,6 +112,9 @@ extern struct group_info init_groups;
 	.proc_lock	= SPIN_LOCK_UNLOCKED,				\
 	.switch_lock	= SPIN_LOCK_UNLOCKED,				\
 	.journal_info	= NULL,						\
+	.xid		= 0,						\
+	.vx_info	= NULL,						\
+	.ip_info	= NULL,						\
 }
 
 
diff -NurpP --minimal linux-2.6.5/include/linux/ip.h linux-2.6.5-vs1.9.0pre2/include/linux/ip.h
--- linux-2.6.5/include/linux/ip.h	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/ip.h	2004-04-05 00:55:13.000000000 +0200
@@ -111,6 +111,7 @@ struct inet_opt {
 	/* Socket demultiplex comparisons on incoming packets. */
 	__u32			daddr;		/* Foreign IPv4 addr */
 	__u32			rcv_saddr;	/* Bound local IPv4 addr */
+	__u32			rcv_saddr2;	/* Second bound ipv4 addr, for ipv4root */
 	__u16			dport;		/* Destination port */
 	__u16			num;		/* Local port */
 	__u32			saddr;		/* Sending source */
diff -NurpP --minimal linux-2.6.5/include/linux/mm.h linux-2.6.5-vs1.9.0pre2/include/linux/mm.h
--- linux-2.6.5/include/linux/mm.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/mm.h	2004-04-05 00:55:18.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/list.h>
 #include <linux/mmzone.h>
 #include <linux/rbtree.h>
+#include <linux/vinline.h>
 #include <linux/fs.h>
 
 #ifndef CONFIG_DISCONTIGMEM          /* Don't use mapnrs, do it properly */
diff -NurpP --minimal linux-2.6.5/include/linux/namespace.h linux-2.6.5-vs1.9.0pre2/include/linux/namespace.h
--- linux-2.6.5/include/linux/namespace.h	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/namespace.h	2004-04-05 00:55:18.000000000 +0200
@@ -13,6 +13,7 @@ struct namespace {
 };
 
 extern void umount_tree(struct vfsmount *);
+extern void umount_unused(struct vfsmount *, struct fs_struct *);
 extern int copy_namespace(int, struct task_struct *);
 void __put_namespace(struct namespace *namespace);
 
diff -NurpP --minimal linux-2.6.5/include/linux/net.h linux-2.6.5-vs1.9.0pre2/include/linux/net.h
--- linux-2.6.5/include/linux/net.h	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/net.h	2004-04-05 00:55:18.000000000 +0200
@@ -60,6 +60,8 @@ typedef enum {
 #define SOCK_ASYNC_NOSPACE	0
 #define SOCK_ASYNC_WAITDATA	1
 #define SOCK_NOSPACE		2
+#define SOCK_PASS_CRED		16
+#define SOCK_USER_SOCKET	17
 
 /**
  *  struct socket - general BSD socket
@@ -82,9 +84,9 @@ struct socket {
 	struct sock		*sk;
 	wait_queue_head_t	wait;
 	short			type;
-	unsigned char		passcred;
 };
 
+
 struct vm_area_struct;
 struct page;
 struct kiocb;
diff -NurpP --minimal linux-2.6.5/include/linux/proc_fs.h linux-2.6.5-vs1.9.0pre2/include/linux/proc_fs.h
--- linux-2.6.5/include/linux/proc_fs.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/proc_fs.h	2004-04-05 00:55:13.000000000 +0200
@@ -60,6 +60,7 @@ struct proc_dir_entry {
 	nlink_t nlink;
 	uid_t uid;
 	gid_t gid;
+	int vx_flags;
 	unsigned long size;
 	struct inode_operations * proc_iops;
 	struct file_operations * proc_fops;
@@ -239,12 +240,17 @@ extern void kclist_add(struct kcore_list
 extern struct kcore_list *kclist_del(void *);
 #endif
 
+struct vx_info;
+
 struct proc_inode {
 	struct task_struct *task;
 	int type;
+	int vx_flags;
+	struct vx_info *vxi;
 	union {
 		int (*proc_get_link)(struct inode *, struct dentry **, struct vfsmount **);
 		int (*proc_read)(struct task_struct *task, char *page);
+		int (*proc_vid_read)(int vid, char *page);
 	} op;
 	struct proc_dir_entry *pde;
 	struct inode vfs_inode;
diff -NurpP --minimal linux-2.6.5/include/linux/quota.h linux-2.6.5-vs1.9.0pre2/include/linux/quota.h
--- linux-2.6.5/include/linux/quota.h	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/quota.h	2004-04-05 00:55:18.000000000 +0200
@@ -57,6 +57,13 @@ extern spinlock_t dq_data_lock;
 #define kb2qb(x) ((x) >> (QUOTABLOCK_BITS-10))
 #define toqb(x) (((x) + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS)
 
+/* are NULL dqhash ptrs valid? */
+#ifdef HANDLE_DQHASH_NULL
+#define	dqhash_valid(hash)      ((hash) != NULL)
+#else
+#define	dqhash_valid(hash)      (0 == 0)
+#endif
+
 #define MAXQUOTAS 2
 #define USRQUOTA  0		/* element used for user quotas */
 #define GRPQUOTA  1		/* element used for group quotas */
@@ -183,7 +190,7 @@ extern inline void mark_info_dirty(struc
 #define info_any_dquot_dirty(info) test_bit(DQF_ANY_DQUOT_DIRTY_B, &(info)->dqi_flags)
 #define info_any_dirty(info) (info_dirty(info) || info_any_dquot_dirty(info))
 
-#define sb_dqopt(sb) (&(sb)->s_dquot)
+#define dqh_dqopt(hash) (&(hash)->dqh_dqopt)
 
 struct dqstats {
 	int lookups;
@@ -198,7 +205,7 @@ struct dqstats {
 
 extern struct dqstats dqstats;
 
-#define NR_DQHASH 43            /* Just an arbitrary number */
+#define NR_DQHASH	13		/* Just an arbitrary number */
 
 #define DQ_MOD_B	0
 #define DQ_BLKS_B	1
@@ -218,7 +225,7 @@ struct dquot {
 	atomic_t dq_count;		/* Use count */
 
 	/* fields after this point are cleared when invalidating */
-	struct super_block *dq_sb;	/* superblock this applies to */
+	struct dqhash *dq_dqh;		/* quota hash backpointer */
 	unsigned int dq_id;		/* ID this applies to (uid, gid) */
 	loff_t dq_off;			/* Offset of dquot on disk */
 	unsigned long dq_flags;		/* See DQ_* */
@@ -233,12 +240,12 @@ struct dquot {
 
 /* Operations which must be implemented by each quota format */
 struct quota_format_ops {
-	int (*check_quota_file)(struct super_block *sb, int type);	/* Detect whether file is in our format */
-	int (*read_file_info)(struct super_block *sb, int type);	/* Read main info about file - called on quotaon() */
-	int (*write_file_info)(struct super_block *sb, int type);	/* Write main info about file */
-	int (*free_file_info)(struct super_block *sb, int type);	/* Called on quotaoff() */
-	int (*read_dqblk)(struct dquot *dquot);		/* Read structure for one user */
-	int (*commit_dqblk)(struct dquot *dquot);	/* Write (or delete) structure for one user */
+	int (*check_quota_file)(struct dqhash *, int);	/* Detect whether file is in our format */
+	int (*read_file_info)(struct dqhash *, int);	/* Read main info about file - called on quotaon() */
+	int (*write_file_info)(struct dqhash *, int);	/* Write main info about file */
+	int (*free_file_info)(struct dqhash *, int);	/* Called on quotaoff() */
+	int (*read_dqblk)(struct dquot *);		/* Read structure for one user */
+	int (*commit_dqblk)(struct dquot *);		/* Write (or delete) structure for one user */
 };
 
 /* Operations working with dquots */
@@ -255,17 +262,17 @@ struct dquot_operations {
 
 /* Operations handling requests from userspace */
 struct quotactl_ops {
-	int (*quota_on)(struct super_block *, int, int, char *);
-	int (*quota_off)(struct super_block *, int);
-	int (*quota_sync)(struct super_block *, int);
-	int (*get_info)(struct super_block *, int, struct if_dqinfo *);
-	int (*set_info)(struct super_block *, int, struct if_dqinfo *);
-	int (*get_dqblk)(struct super_block *, int, qid_t, struct if_dqblk *);
-	int (*set_dqblk)(struct super_block *, int, qid_t, struct if_dqblk *);
-	int (*get_xstate)(struct super_block *, struct fs_quota_stat *);
-	int (*set_xstate)(struct super_block *, unsigned int, int);
-	int (*get_xquota)(struct super_block *, int, qid_t, struct fs_disk_quota *);
-	int (*set_xquota)(struct super_block *, int, qid_t, struct fs_disk_quota *);
+	int (*quota_on)(struct dqhash *, int, int, char *);
+	int (*quota_off)(struct dqhash *, int);
+	int (*quota_sync)(struct dqhash *, int);
+	int (*get_info)(struct dqhash *, int, struct if_dqinfo *);
+	int (*set_info)(struct dqhash *, int, struct if_dqinfo *);
+	int (*get_dqblk)(struct dqhash *, int, qid_t, struct if_dqblk *);
+	int (*set_dqblk)(struct dqhash *, int, qid_t, struct if_dqblk *);
+	int (*get_xstate)(struct dqhash *, struct fs_quota_stat *);
+	int (*set_xstate)(struct dqhash *, unsigned int, int);
+	int (*get_xquota)(struct dqhash *, int, qid_t, struct fs_disk_quota *);
+	int (*set_xquota)(struct dqhash *, int, qid_t, struct fs_disk_quota *);
 };
 
 struct quota_format_type {
@@ -288,19 +295,13 @@ struct quota_info {
 	struct quota_format_ops *ops[MAXQUOTAS];	/* Operations for each type */
 };
 
-/* Inline would be better but we need to dereference super_block which is not defined yet */
-#define mark_dquot_dirty(dquot) do {\
-	set_bit(DQF_ANY_DQUOT_DIRTY_B, &(sb_dqopt((dquot)->dq_sb)->info[(dquot)->dq_type].dqi_flags));\
-	set_bit(DQ_MOD_B, &(dquot)->dq_flags);\
-} while (0)
-
 #define dquot_dirty(dquot) test_bit(DQ_MOD_B, &(dquot)->dq_flags)
 
-#define sb_has_quota_enabled(sb, type) ((type)==USRQUOTA ? \
-	(sb_dqopt(sb)->flags & DQUOT_USR_ENABLED) : (sb_dqopt(sb)->flags & DQUOT_GRP_ENABLED))
+#define dqh_has_quota_enabled(hash, type) (dqhash_valid(hash) && ((type)==USRQUOTA ? \
+	(dqh_dqopt(hash)->flags & DQUOT_USR_ENABLED) : (dqh_dqopt(hash)->flags & DQUOT_GRP_ENABLED)))
 
-#define sb_any_quota_enabled(sb) (sb_has_quota_enabled(sb, USRQUOTA) | \
-				  sb_has_quota_enabled(sb, GRPQUOTA))
+#define dqh_any_quota_enabled(hash) (dqhash_valid(hash) && \
+	(dqh_has_quota_enabled(hash, USRQUOTA) || dqh_has_quota_enabled(hash, GRPQUOTA)))
 
 int register_quota_format(struct quota_format_type *fmt);
 void unregister_quota_format(struct quota_format_type *fmt);
@@ -316,6 +317,55 @@ struct quota_module_name {
 	{QFMT_VFS_V0, "quota_v2"},\
 	{0, NULL}}
 
+struct dqhash {
+	struct list_head dqh_list;	/* List of all quota hashes */
+	unsigned int dqh_id;		/* ID for hash */
+	atomic_t dqh_count;		/* Use count */
+	struct quota_info dqh_dqopt;	/* Diskquota specific options */
+	struct dquot_operations	*dqh_qop;
+	struct quotactl_ops *dqh_qcop;
+	struct super_block *dqh_sb;	/* super block */
+	struct list_head dqh_hash[NR_DQHASH];
+};
+
+#if defined(CONFIG_QUOTA)
+
+
+struct dqhash *new_dqhash(struct super_block *, unsigned int);
+void destroy_dqhash(struct dqhash *);
+struct dqhash *find_dqhash(unsigned int);
+
+static inline void dqhput(struct dqhash *hash)
+{
+	if (dqhash_valid(hash))
+		if (atomic_dec_and_test(&hash->dqh_count))
+			destroy_dqhash(hash);
+}
+
+static inline struct dqhash *dqhget(struct dqhash *hash)
+{
+	if (dqhash_valid(hash))
+		atomic_inc(&hash->dqh_count);
+	return hash;
+}
+
+static inline void mark_dquot_dirty(struct dquot *dq)
+{
+	dq->dq_flags |= DQ_MOD;
+	dqh_dqopt(dq->dq_dqh)->info[dq->dq_type].dqi_flags |= DQF_ANY_DQUOT_DIRTY;
+}
+
+#else /* CONFIG_QUOTA */
+
+#define new_dqhash(sb, dqdom)		(0)
+#define find_dqhash(dqdom)		(0)
+#define destroy_dqhash(hash)		do { } while(0)
+
+#define dqhput(hash)			do { } while(0)
+#define dqhget(hash)			(hash)
+
+#endif /* CONFIG_QUOTA */
+
 #else
 
 # /* nodep */ include <sys/cdefs.h>
diff -NurpP --minimal linux-2.6.5/include/linux/quotaops.h linux-2.6.5-vs1.9.0pre2/include/linux/quotaops.h
--- linux-2.6.5/include/linux/quotaops.h	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/quotaops.h	2004-04-05 00:55:19.000000000 +0200
@@ -15,6 +15,13 @@
 
 #include <linux/fs.h>
 
+// #define	DEBUG_HASHES
+// #define	DEBUG_EXTERN
+
+#ifdef dprintk
+#undef dprintk
+#endif
+
 #if defined(CONFIG_QUOTA)
 
 /*
@@ -33,6 +40,42 @@ extern void dquot_free_inode(const struc
 
 extern int  dquot_transfer(struct inode *inode, struct iattr *iattr);
 
+#ifdef DEBUG_HASHES
+#define dprintk(...)    printk(__VA_ARGS__)
+#else
+#define dprintk(...)
+#endif
+
+static __inline__ void vx_dq_modify(struct inode *inode, unsigned int xid)
+{
+	if (!(inode->i_sb->s_flags & MS_TAGXID))
+		return;
+	dprintk(" vx_dq_modify: %p #%d -> #%d\n", inode, inode->i_xid, xid);
+	inode->i_xid = xid;
+	mark_inode_dirty(inode);
+}
+
+static __inline__ void vx_dq_cond_modify(struct inode *inode, unsigned int xid)
+{
+	if (inode->i_xid != xid)
+		vx_dq_modify(inode, xid);
+}
+
+static __inline__ void vx_dq_unlink(struct inode *inode)
+{
+	if (inode->i_nlink == 0)
+		return;
+	/* inode from other context? */
+	if (inode->i_xid != current->xid)
+		return;
+	/* inode still referenced ... */
+	if (inode->i_xid == 0)
+		return;
+	/* transfer back to xid zero hash */
+	vx_dq_modify(inode, 0);
+}
+
+
 /*
  * Operations supported for diskquotas.
  */
@@ -42,26 +85,32 @@ extern struct quotactl_ops vfs_quotactl_
 #define sb_dquot_ops (&dquot_operations)
 #define sb_quotactl_ops (&vfs_quotactl_ops)
 
+#define CHECK_DQHASH(inode)			do { } while(0)
+
 static __inline__ void DQUOT_INIT(struct inode *inode)
 {
-	BUG_ON(!inode->i_sb);
-	if (sb_any_quota_enabled(inode->i_sb) && !IS_NOQUOTA(inode))
-		inode->i_sb->dq_op->initialize(inode, -1);
+	CHECK_DQHASH(inode);
+	if (!dqhash_valid(inode->i_dqh))
+		return;
+	BUG_ON(!inode->i_dqh);
+	if (dqh_any_quota_enabled(inode->i_dqh) && !IS_NOQUOTA(inode))
+		inode->i_dqh->dqh_qop->initialize(inode, -1);
 }
 
 static __inline__ void DQUOT_DROP(struct inode *inode)
 {
 	if (IS_QUOTAINIT(inode)) {
-		BUG_ON(!inode->i_sb);
-		inode->i_sb->dq_op->drop(inode);	/* Ops must be set when there's any quota... */
+		BUG_ON(!inode->i_dqh);
+		inode->i_dqh->dqh_qop->drop(inode);	/* Ops must be set when there's any quota... */
 	}
 }
 
 static __inline__ int DQUOT_PREALLOC_SPACE_NODIRTY(struct inode *inode, qsize_t nr)
 {
-	if (sb_any_quota_enabled(inode->i_sb)) {
+	CHECK_DQHASH(inode);
+	if (dqh_any_quota_enabled(inode->i_dqh)) {
 		/* Used space is updated in alloc_space() */
-		if (inode->i_sb->dq_op->alloc_space(inode, nr, 1) == NO_QUOTA)
+		if (inode->i_dqh->dqh_qop->alloc_space(inode, nr, 1) == NO_QUOTA)
 			return 1;
 	}
 	else {
@@ -82,9 +131,10 @@ static __inline__ int DQUOT_PREALLOC_SPA
 
 static __inline__ int DQUOT_ALLOC_SPACE_NODIRTY(struct inode *inode, qsize_t nr)
 {
-	if (sb_any_quota_enabled(inode->i_sb)) {
+	CHECK_DQHASH(inode);
+	if (dqh_any_quota_enabled(inode->i_dqh)) {
 		/* Used space is updated in alloc_space() */
-		if (inode->i_sb->dq_op->alloc_space(inode, nr, 0) == NO_QUOTA)
+		if (inode->i_dqh->dqh_qop->alloc_space(inode, nr, 0) == NO_QUOTA)
 			return 1;
 	}
 	else {
@@ -105,9 +155,10 @@ static __inline__ int DQUOT_ALLOC_SPACE(
 
 static __inline__ int DQUOT_ALLOC_INODE(struct inode *inode)
 {
-	if (sb_any_quota_enabled(inode->i_sb)) {
+	CHECK_DQHASH(inode);
+	if (dqh_any_quota_enabled(inode->i_dqh)) {
 		DQUOT_INIT(inode);
-		if (inode->i_sb->dq_op->alloc_inode(inode, 1) == NO_QUOTA)
+		if (inode->i_dqh->dqh_qop->alloc_inode(inode, 1) == NO_QUOTA)
 			return 1;
 	}
 	return 0;
@@ -115,8 +166,8 @@ static __inline__ int DQUOT_ALLOC_INODE(
 
 static __inline__ void DQUOT_FREE_SPACE_NODIRTY(struct inode *inode, qsize_t nr)
 {
-	if (sb_any_quota_enabled(inode->i_sb))
-		inode->i_sb->dq_op->free_space(inode, nr);
+	if (dqh_any_quota_enabled(inode->i_dqh))
+		inode->i_dqh->dqh_qop->free_space(inode, nr);
 	else {
 		spin_lock(&dq_data_lock);
 		inode_sub_bytes(inode, nr);
@@ -132,28 +183,28 @@ static __inline__ void DQUOT_FREE_SPACE(
 
 static __inline__ void DQUOT_FREE_INODE(struct inode *inode)
 {
-	if (sb_any_quota_enabled(inode->i_sb))
-		inode->i_sb->dq_op->free_inode(inode, 1);
+	if (dqh_any_quota_enabled(inode->i_dqh))
+		inode->i_dqh->dqh_qop->free_inode(inode, 1);
 }
 
 static __inline__ int DQUOT_TRANSFER(struct inode *inode, struct iattr *iattr)
 {
-	if (sb_any_quota_enabled(inode->i_sb) && !IS_NOQUOTA(inode)) {
+	if (dqh_any_quota_enabled(inode->i_dqh) && !IS_NOQUOTA(inode)) {
 		DQUOT_INIT(inode);
-		if (inode->i_sb->dq_op->transfer(inode, iattr) == NO_QUOTA)
+		if (inode->i_dqh->dqh_qop->transfer(inode, iattr) == NO_QUOTA)
 			return 1;
 	}
 	return 0;
 }
 
-#define DQUOT_SYNC(sb)	sync_dquots(sb, -1)
+#define DQUOT_SYNC(hash)	sync_dquots(hash, -1)
 
-static __inline__ int DQUOT_OFF(struct super_block *sb)
+static __inline__ int DQUOT_OFF(struct dqhash *hash)
 {
 	int ret = -ENOSYS;
 
-	if (sb->s_qcop && sb->s_qcop->quota_off)
-		ret = sb->s_qcop->quota_off(sb, -1);
+	if (hash->dqh_qcop && hash->dqh_qcop->quota_off)
+		ret = hash->dqh_qcop->quota_off(hash, -1);
 	return ret;
 }
 
@@ -169,9 +220,16 @@ static __inline__ int DQUOT_OFF(struct s
 #define DQUOT_DROP(inode)			do { } while(0)
 #define DQUOT_ALLOC_INODE(inode)		(0)
 #define DQUOT_FREE_INODE(inode)			do { } while(0)
-#define DQUOT_SYNC(sb)				do { } while(0)
-#define DQUOT_OFF(sb)				do { } while(0)
+#define DQUOT_SYNC(hash)			do { } while(0)
+#define DQUOT_OFF(hash)				do { } while(0)
 #define DQUOT_TRANSFER(inode, iattr)		(0)
+
+#define vx_dq_modify(inode, xid)		do { } while(0)
+#define vx_dq_cond_modify(inode, xid)		do { } while(0)
+#define vx_dq_unlink(inode)			do { } while(0)
+
+#define CHECK_DQHASH(inode)			do { } while(0)
+
 extern __inline__ int DQUOT_PREALLOC_SPACE_NODIRTY(struct inode *inode, qsize_t nr)
 {
 	inode_add_bytes(inode, nr);
diff -NurpP --minimal linux-2.6.5/include/linux/reiserfs_fs.h linux-2.6.5-vs1.9.0pre2/include/linux/reiserfs_fs.h
--- linux-2.6.5/include/linux/reiserfs_fs.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/reiserfs_fs.h	2004-04-05 00:55:13.000000000 +0200
@@ -888,8 +888,12 @@ struct stat_data_v1
 #define REISERFS_COMPR_FL     EXT2_COMPR_FL
 #define REISERFS_NOTAIL_FL    EXT2_NOTAIL_FL
 
+#define REISERFS_IUNLINK_FL   (EXT2_IUNLINK_FL >> 16)
+#define REISERFS_BARRIER_FL   (EXT2_BARRIER_FL >> 16)
+
 /* persistent flags that file inherits from the parent directory */
 #define REISERFS_INHERIT_MASK ( REISERFS_IMMUTABLE_FL |	\
+				REISERFS_IUNLINK_FL |	\
 				REISERFS_SYNC_FL |	\
 				REISERFS_NOATIME_FL |	\
 				REISERFS_NODUMP_FL |	\
diff -NurpP --minimal linux-2.6.5/include/linux/sched.h linux-2.6.5-vs1.9.0pre2/include/linux/sched.h
--- linux-2.6.5/include/linux/sched.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/sched.h	2004-04-05 00:55:18.000000000 +0200
@@ -102,6 +102,7 @@ extern unsigned long nr_iowait(void);
 #include <linux/timer.h>
 
 #include <asm/processor.h>
+#include <linux/vserver/context.h>
 
 #define TASK_RUNNING		0
 #define TASK_INTERRUPTIBLE	1
@@ -109,6 +110,7 @@ extern unsigned long nr_iowait(void);
 #define TASK_STOPPED		4
 #define TASK_ZOMBIE		8
 #define TASK_DEAD		16
+#define TASK_ONHOLD		32
 
 #define __set_task_state(tsk, state_value)		\
 	do { (tsk)->state = (state_value); } while (0)
@@ -218,6 +220,7 @@ struct mm_struct {
 
 	/* Architecture-specific MM context */
 	mm_context_t context;
+	struct vx_info *mm_vx_info;
 
 	/* coredumping support */
 	int core_waiters;
@@ -300,9 +303,10 @@ struct user_struct {
 	/* Hash table maintenance information */
 	struct list_head uidhash_list;
 	uid_t uid;
+	int vx_id;
 };
 
-extern struct user_struct *find_user(uid_t);
+extern struct user_struct *find_user(xid_t, uid_t);
 
 extern struct user_struct root_user;
 #define INIT_USER (&root_user)
@@ -470,6 +474,11 @@ struct task_struct {
 	
 	void *security;
 
+/* vserver data */
+	xid_t xid;
+	struct vx_info *vx_info;
+	struct ip_info *ip_info;
+
 /* Thread group tracking */
    	u32 parent_exec_id;
    	u32 self_exec_id;
@@ -589,7 +598,7 @@ extern void set_special_pids(pid_t sessi
 extern void __set_special_pids(pid_t session, pid_t pgrp);
 
 /* per-UID process charging. */
-extern struct user_struct * alloc_uid(uid_t);
+extern struct user_struct * alloc_uid(xid_t, uid_t);
 extern void free_uid(struct user_struct *);
 extern void switch_uid(struct user_struct *);
 
@@ -693,7 +702,7 @@ static inline int capable(int cap)
 /*
  * Routines for handling mm_structs
  */
-extern struct mm_struct * mm_alloc(void);
+extern struct mm_struct * mm_alloc(struct vx_info *);
 
 /* mmdrop drops the mm and the page tables */
 extern void FASTCALL(__mmdrop(struct mm_struct *));
diff -NurpP --minimal linux-2.6.5/include/linux/security.h linux-2.6.5-vs1.9.0pre2/include/linux/security.h
--- linux-2.6.5/include/linux/security.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/security.h	2004-04-05 00:55:18.000000000 +0200
@@ -1019,7 +1019,7 @@ struct security_operations {
 	int (*acct) (struct file * file);
 	int (*sysctl) (ctl_table * table, int op);
 	int (*capable) (struct task_struct * tsk, int cap);
-	int (*quotactl) (int cmds, int type, int id, struct super_block * sb);
+	int (*quotactl) (int cmds, int type, int id, dqhash * hash);
 	int (*quota_on) (struct file * f);
 	int (*syslog) (int type);
 	int (*vm_enough_memory) (long pages);
@@ -1262,9 +1262,9 @@ static inline int security_sysctl(ctl_ta
 }
 
 static inline int security_quotactl (int cmds, int type, int id,
-				     struct super_block *sb)
+				     struct dqhash *hash)
 {
-	return security_ops->quotactl (cmds, type, id, sb);
+	return security_ops->quotactl (cmds, type, id, hash);
 }
 
 static inline int security_quota_on (struct file * file)
@@ -1934,7 +1934,7 @@ static inline int security_sysctl(ctl_ta
 }
 
 static inline int security_quotactl (int cmds, int type, int id,
-				     struct super_block * sb)
+				     struct dqhash * hash)
 {
 	return 0;
 }
diff -NurpP --minimal linux-2.6.5/include/linux/sysctl.h linux-2.6.5-vs1.9.0pre2/include/linux/sysctl.h
--- linux-2.6.5/include/linux/sysctl.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/linux/sysctl.h	2004-04-05 00:55:16.000000000 +0200
@@ -131,6 +131,7 @@ enum
 	KERN_PRINTK_RATELIMIT_BURST=61,	/* int: tune printk ratelimiting */
 	KERN_PTY=62,		/* dir: pty driver */
 	KERN_NGROUPS_MAX=63,	/* int: NGROUPS_MAX */
+	KERN_VSHELPER=64,	/* string: path to vshelper policy agent */
 };
 
 
diff -NurpP --minimal linux-2.6.5/include/linux/types.h linux-2.6.5-vs1.9.0pre2/include/linux/types.h
--- linux-2.6.5/include/linux/types.h	2004-03-11 03:55:44.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/types.h	2004-04-05 00:55:13.000000000 +0200
@@ -37,6 +37,8 @@ typedef __kernel_uid32_t	uid_t;
 typedef __kernel_gid32_t	gid_t;
 typedef __kernel_uid16_t        uid16_t;
 typedef __kernel_gid16_t        gid16_t;
+typedef unsigned int		xid_t;
+typedef unsigned int		nid_t;
 
 #ifdef CONFIG_UID16
 /* This is defined by include/asm-{arch}/posix_types.h */
diff -NurpP --minimal linux-2.6.5/include/linux/vinline.h linux-2.6.5-vs1.9.0pre2/include/linux/vinline.h
--- linux-2.6.5/include/linux/vinline.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vinline.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,430 @@
+#ifndef _VX_INLINE_H
+#define _VX_INLINE_H
+
+
+// #define VX_DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#include "vserver/context.h"
+#include "vserver/network.h"
+#include "vserver/limit.h"
+#include "vserver/cvirt.h"
+
+#if defined(VX_DEBUG)
+#define vxdprintk(x...) printk("vxd: " x)
+#else
+#define vxdprintk(x...)
+#endif
+
+
+
+void free_vx_info(struct vx_info *);
+
+extern int proc_pid_vinfo(struct task_struct *, char *);
+
+
+#define get_vx_info(i)	__get_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ struct vx_info *__get_vx_info(struct vx_info *vxi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!vxi)
+		return NULL;
+	vxdprintk("get_vx_info(%p[#%d.%d])\t%s:%d\n", vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount),
+		_file, _line);
+	atomic_inc(&vxi->vx_refcount);
+	return vxi;
+}
+
+#define put_vx_info(i)	__put_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ void __put_vx_info(struct vx_info *vxi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!vxi)
+		return;
+	vxdprintk("put_vx_info(%p[#%d.%d])\t%s:%d\n", vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount),
+		_file, _line);
+	if (atomic_dec_and_lock(&vxi->vx_refcount, &vxlist_lock)) {
+		list_del(&vxi->vx_list);
+		spin_unlock(&vxlist_lock);
+		free_vx_info(vxi);
+	}
+}
+
+#define task_get_vx_info(i)	__task_get_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ struct vx_info *__task_get_vx_info(struct task_struct *p,
+	const char *_file, int _line)
+{
+	struct vx_info *vxi;
+	
+	task_lock(p);
+	vxi = __get_vx_info(p->vx_info, _file, _line);
+	task_unlock(p);
+	return vxi;
+}
+
+
+#define vx_verify_info(p,i)	\
+	__vx_verify_info((p)->vx_info,i,__FILE__,__LINE__)
+
+static __inline__ void __vx_verify_info(
+	struct vx_info *vxa, struct vx_info *vxb,
+	const char *_file, int _line)
+{
+	if (vxa == vxb)
+		return;
+	printk(KERN_ERR "vx bad assumption (%p==%p) at %s:%d\n",
+		vxa, vxb, _file, _line);
+}
+
+
+#define vx_task_xid(t)	((t)->xid)
+
+#define vx_current_xid() vx_task_xid(current)
+
+#define vx_check(c,m)	__vx_check(vx_current_xid(),c,m)
+
+#define vx_weak_check(c,m)	((m) ? vx_check(c,m) : 1)
+
+/*
+ * check current context for ADMIN/WATCH and
+ * optionally agains supplied argument
+ */
+static __inline__ int __vx_check(xid_t cid, xid_t id, unsigned int mode)
+{
+	if (mode & VX_ARG_MASK) {
+		if ((mode & VX_IDENT) &&
+			(id == cid))
+			return 1;
+	}
+	if (mode & VX_ATR_MASK) {
+		if ((mode & VX_DYNAMIC) &&
+			(id >= MIN_D_CONTEXT) &&
+			(id <= MAX_S_CONTEXT))
+			return 1;
+		if ((mode & VX_STATIC) &&
+			(id > 1) && (id < MIN_D_CONTEXT))
+			return 1;
+	}
+	return (((mode & VX_ADMIN) && (cid == 0)) ||
+		((mode & VX_WATCH) && (cid == 1)));
+}
+
+
+#define vx_current_flags() \
+	((current->vx_info) ? current->vx_info->vx_flags : 0)
+
+#define vx_flags(m,f)	__vx_flags(vx_current_flags(),m,f)
+
+#define __vx_flags(v,m,f)	(((v) & (m)) ^ (f))
+
+
+#define vx_current_ccaps() \
+	((current->vx_info) ? current->vx_info->vx_ccaps : 0)
+
+#define vx_ccaps(c)	(vx_current_ccaps() & (c))
+
+#define vx_current_bcaps() \
+	(((current->vx_info) && !vx_flags(VXF_STATE_SETUP, 0)) ? \
+	current->vx_info->vx_bcaps : cap_bset)
+
+void free_ip_info(struct ip_info *);
+
+#define get_ip_info(i)	__get_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ struct ip_info *__get_ip_info(struct ip_info *ipi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!ipi)
+		return NULL;
+	vxdprintk("get_ip_info(%p[%d])\t%s:%d\n", ipi,
+		atomic_read(&ipi->ip_refcount), _file, _line);
+	atomic_inc(&ipi->ip_refcount);
+	return ipi;
+}
+
+#define put_ip_info(i)	__put_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ void __put_ip_info(struct ip_info *ipi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!ipi)
+		return;
+	vxdprintk("put_ip_info(%p[%d])\t%s:%d\n", ipi,
+		atomic_read(&ipi->ip_refcount), _file, _line);
+	if (atomic_dec_and_lock(&ipi->ip_refcount, &iplist_lock)) {
+		list_del(&ipi->ip_list);
+		spin_unlock(&iplist_lock);
+		free_ip_info(ipi);
+	}
+}
+
+#define task_get_ip_info(i)	__task_get_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ struct ip_info *__task_get_ip_info(struct task_struct *p,
+	const char *_file, int _line)
+{
+	struct ip_info *ipi;
+	
+	task_lock(p);
+	ipi = __get_ip_info(p->ip_info, _file, _line);
+	task_unlock(p);
+	return ipi;
+}
+
+#define ip_verify_info(p,i)	\
+	__ip_verify_info((p)->ip_info,i,__FILE__,__LINE__)
+
+static __inline__ void __ip_verify_info(
+	struct ip_info *ipa, struct ip_info *ipb,
+	const char *_file, int _line)
+{
+	if (ipa == ipb)
+		return;
+	printk(KERN_ERR "ip bad assumption (%p==%p) at %s:%d\n",
+		ipa, ipb, _file, _line);
+}
+
+
+
+#define VX_DEBUG_ACC_RSS   0
+#define VX_DEBUG_ACC_VM    0
+#define VX_DEBUG_ACC_VML   0
+#define VX_DEBUG_ACC_FILE  0
+
+
+#define vx_acc_page(m, d, v, r) \
+	__vx_acc_page(&(m->v), m->mm_vx_info, r, d, __FILE__, __LINE__)
+
+static inline void __vx_acc_page(unsigned long *v, struct vx_info *vxi,
+                int res, int dir, char *file, int line)
+{
+        if (v) {
+                if (dir > 0)
+                        ++(*v);
+                else
+                        --(*v);
+        }
+        if (vxi) {
+                if (dir > 0)
+                        atomic_inc(&vxi->limit.res[res]);
+                else
+                        atomic_dec(&vxi->limit.res[res]);
+        }
+}
+
+
+#define vx_acc_pages(m, p, v, r) \
+	__vx_acc_pages(&(m->v), m->mm_vx_info, r, p, __FILE__, __LINE__)
+
+static inline void __vx_acc_pages(unsigned long *v, struct vx_info *vxi,
+                int res, int pages, char *file, int line)
+{
+        if ((pages > 1 || pages < -1) &&
+                ((res == RLIMIT_RSS && VX_DEBUG_ACC_RSS) ||
+                 (res == RLIMIT_AS && VX_DEBUG_ACC_VM) ||
+                 (res == RLIMIT_MEMLOCK && VX_DEBUG_ACC_VML)))
+                vxdprintk("vx_acc_pages  [%5d,%2d]: %5d += %5d in %s:%d\n",
+                        (vxi?vxi->vx_id:-1), res,
+                        (vxi?atomic_read(&vxi->limit.res[res]):0),
+			pages, file, line);
+        if (pages == 0)
+                return;
+        if (v)
+                *v += pages;
+        if (vxi)
+                atomic_add(pages, &vxi->limit.res[res]);
+}
+
+
+
+#define vx_acc_vmpage(m,d)     vx_acc_page(m, d, total_vm,  RLIMIT_AS)
+#define vx_acc_vmlpage(m,d)    vx_acc_page(m, d, locked_vm, RLIMIT_MEMLOCK)
+#define vx_acc_rsspage(m,d)    vx_acc_page(m, d, rss,	    RLIMIT_RSS)
+
+#define vx_acc_vmpages(m,p)    vx_acc_pages(m, p, total_vm,  RLIMIT_AS)
+#define vx_acc_vmlpages(m,p)   vx_acc_pages(m, p, locked_vm, RLIMIT_MEMLOCK)
+#define vx_acc_rsspages(m,p)   vx_acc_pages(m, p, rss,       RLIMIT_RSS)
+
+#define vx_pages_add(s,r,p)    __vx_acc_pages(0, s, r, p, __FILE__, __LINE__)
+#define vx_pages_sub(s,r,p)    __vx_pages_add(s, r, -(p))
+
+#define vx_vmpages_inc(m)      vx_acc_vmpage(m, 1)
+#define vx_vmpages_dec(m)      vx_acc_vmpage(m,-1)
+#define vx_vmpages_add(m,p)    vx_acc_vmpages(m, p)
+#define vx_vmpages_sub(m,p)    vx_acc_vmpages(m,-(p))
+
+#define vx_vmlocked_inc(m)     vx_acc_vmlpage(m, 1)
+#define vx_vmlocked_dec(m)     vx_acc_vmlpage(m,-1)
+#define vx_vmlocked_add(m,p)   vx_acc_vmlpages(m, p)
+#define vx_vmlocked_sub(m,p)   vx_acc_vmlpages(m,-(p))
+
+#define vx_rsspages_inc(m)     vx_acc_rsspage(m, 1)
+#define vx_rsspages_dec(m)     vx_acc_rsspage(m,-1)
+#define vx_rsspages_add(m,p)   vx_acc_rsspages(m, p)
+#define vx_rsspages_sub(m,p)   vx_acc_rsspages(m,-(p))
+
+
+
+#define vx_pages_avail(m, p, r) \
+        __vx_pages_avail((m)->mm_vx_info, (r), (p), __FILE__, __LINE__)
+
+static inline int __vx_pages_avail(struct vx_info *vxi,
+                int res, int pages, char *file, int line)
+{
+        if ((res == RLIMIT_RSS && VX_DEBUG_ACC_RSS) ||
+                (res == RLIMIT_AS && VX_DEBUG_ACC_VM) ||
+                (res == RLIMIT_MEMLOCK && VX_DEBUG_ACC_VML))
+                printk("vx_pages_avail[%5d,%2d]: %5ld > %5d + %5d in %s:%d\n",
+                        (vxi?vxi->vx_id:-1), res,
+			(vxi?vxi->limit.rlim[res]:1),
+                        (vxi?atomic_read(&vxi->limit.res[res]):0),
+			pages, file, line);
+        if (!vxi)
+                return 1;
+        if (vxi->limit.rlim[res] == RLIM_INFINITY)
+                return 1;
+        if (vxi->limit.rlim[res] < atomic_read(&vxi->limit.res[res]) + pages)
+                return 0;
+        return 1;
+}
+
+#define vx_vmpages_avail(m,p)  vx_pages_avail(m, p, RLIMIT_AS)
+#define vx_vmlocked_avail(m,p) vx_pages_avail(m, p, RLIMIT_MEMLOCK)
+#define vx_rsspages_avail(m,p) vx_pages_avail(m, p, RLIMIT_RSS)
+
+/* file limits */
+
+#define vx_acc_cres(v,d,r) \
+	__vx_acc_cres((v), (r), (d), __FILE__, __LINE__)
+
+static inline void __vx_acc_cres(struct vx_info *vxi,
+	int res, int dir, char *file, int line)
+{
+        if (vxi) {
+                if (dir > 0)
+                        atomic_inc(&vxi->limit.res[res]);
+                else
+                        atomic_dec(&vxi->limit.res[res]);
+        }
+}
+
+#define vx_files_inc(f)	vx_acc_cres(current->vx_info, 1, RLIMIT_NOFILE)
+#define vx_files_dec(f)	vx_acc_cres(current->vx_info,-1, RLIMIT_NOFILE)
+
+#define vx_cres_avail(v,n,r) \
+        __vx_cres_avail((v), (r), (n), __FILE__, __LINE__)
+
+static inline int __vx_cres_avail(struct vx_info *vxi,
+                int res, int num, char *file, int line)
+{
+        if (res == RLIMIT_NOFILE && VX_DEBUG_ACC_FILE)
+                printk("vx_cres_avail[%5d,%2d]: %5ld > %5d + %5d in %s:%d\n",
+                        (vxi?vxi->vx_id:-1), res,
+			(vxi?vxi->limit.rlim[res]:1),
+                        (vxi?atomic_read(&vxi->limit.res[res]):0),
+			num, file, line);
+        if (!vxi)
+                return 1;
+        if (vxi->limit.rlim[res] == RLIM_INFINITY)
+                return 1;
+        if (vxi->limit.rlim[res] < atomic_read(&vxi->limit.res[res]) + num)
+                return 0;
+        return 1;
+}
+
+#define vx_files_avail(n) \
+	vx_cres_avail(current->vx_info, (n), RLIMIT_NOFILE)
+
+/* socket limits */
+
+#define vx_sock_inc(f)	vx_acc_cres(current->vx_info, 1, VLIMIT_SOCK)
+#define vx_sock_dec(f)	vx_acc_cres(current->vx_info,-1, VLIMIT_SOCK)
+
+#define vx_sock_avail(n) \
+	vx_cres_avail(current->vx_info, (n), VLIMIT_SOCK)
+
+/* procfs ioctls */
+
+#define	FIOC_GETXFLG	_IOR('x', 5, long)
+#define	FIOC_SETXFLG	_IOW('x', 6, long)
+
+/* utsname virtualization */
+
+#define	vx_new_utsname()	((current->vx_info) ?	\
+	current->vx_info->cvirt.utsname : system_utsname)
+
+#define vx_new_uts(x)		((&vx_new_utsname())->x)
+
+/* generic flag merging */
+
+#define	vx_mask_flags(v,f,m)	(((v) & ~(m)) | ((f) & (m)))
+
+#define vx_merge_flags(v,f,m,n)	
+
+
+/* socket accounting */
+
+#include <linux/socket.h>
+
+static inline int vx_sock_type(int family)
+{
+	int type = 4;
+
+	if (family > 0 && family < 3)
+		type = family;
+	else if (family == PF_INET6)
+		type = 3;
+	return type;
+}
+
+#define vx_acc_sock(v,f,p,s) \
+	__vx_acc_sock((v), (f), (p), (s), __FILE__, __LINE__)
+
+static inline void __vx_acc_sock(struct vx_info *vxi,
+	int family, int pos, int size, char *file, int line)
+{
+        if (vxi) {
+		int type = vx_sock_type(family);
+
+		atomic_inc(&vxi->cvirt.sock[type][pos].count);
+		atomic_add(size, &vxi->cvirt.sock[type][pos].total);
+        }
+}
+
+#define vx_sock_recv(sk,s) \
+	vx_acc_sock((sk)->sk_vx_info, (sk)->sk_family, 0, (s))
+#define vx_sock_send(sk,s) \
+	vx_acc_sock((sk)->sk_vx_info, (sk)->sk_family, 1, (s))
+#define vx_sock_fail(sk,s) \
+	vx_acc_sock((sk)->sk_vx_info, (sk)->sk_family, 2, (s))
+
+
+/* pid faking stuff */
+
+
+static inline int vx_map_tgid(struct vx_info *vxi, int pid)
+{
+	if (vxi && __vx_flags(vxi->vx_flags, VXF_INFO_INIT, 0)) {
+		if (pid == vxi->vx_initpid)
+			return 1;
+	}
+	return pid;
+}
+
+static inline int vx_rmap_tgid(struct vx_info *vxi, int pid)
+{
+	if (vxi && __vx_flags(vxi->vx_flags, VXF_INFO_INIT, 0)) {
+		if ((pid == 1) && vxi->vx_initpid)
+			return vxi->vx_initpid;
+	}
+	return pid;
+}
+
+#endif
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/context.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/context.h
--- linux-2.6.5/include/linux/vserver/context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/context.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,174 @@
+#ifndef _VX_CONTEXT_H
+#define _VX_CONTEXT_H
+
+#include <linux/types.h>
+
+#define MAX_S_CONTEXT	65535	/* Arbitrary limit */
+#define MIN_D_CONTEXT	49152	/* dynamic contexts start here */
+
+#define VX_DYNAMIC_ID	((uint32_t)-1)		/* id for dynamic context */
+
+#ifdef	__KERNEL__
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+
+#define	_VX_INFO_DEF_
+#include "cvirt.h"
+#include "limit.h"
+#include "sched.h"
+#undef	_VX_INFO_DEF_
+
+struct vx_info {
+	struct list_head vx_list;		/* linked list of contexts */
+	xid_t vx_id;				/* context id */
+	atomic_t vx_refcount;			/* refcount */
+	struct vx_info *vx_parent;		/* parent context */
+
+	struct namespace *vx_namespace;		/* private namespace */
+	struct fs_struct *vx_fs;		/* private namespace fs */
+	uint64_t vx_flags;			/* VX_INFO_xxx */
+	uint64_t vx_bcaps;			/* bounding caps (system) */
+	uint64_t vx_ccaps;			/* context caps (vserver) */
+
+	pid_t vx_initpid;			/* PID of fake init process */
+
+	struct _vx_cvirt cvirt;			/* virtual/bias stuff */
+	struct _vx_limit limit;			/* vserver limits */
+	struct _vx_sched sched;			/* vserver scheduler */
+
+	char vx_name[65];			/* vserver name */
+};
+
+
+extern spinlock_t vxlist_lock;
+extern struct list_head vx_infos;
+
+
+#define	VX_ADMIN	0x0001
+#define	VX_WATCH	0x0002
+#define VX_DUMMY	0x0008
+
+#define	VX_IDENT	0x0010
+#define	VX_EQUIV	0x0020
+#define	VX_PARENT	0x0040
+#define	VX_CHILD	0x0080
+
+#define	VX_ARG_MASK	0x00F0
+
+#define	VX_DYNAMIC	0x0100
+#define	VX_STATIC	0x0200
+
+#define	VX_ATR_MASK	0x0F00
+
+
+void free_vx_info(struct vx_info *);
+
+extern struct vx_info *find_vx_info(int);
+extern struct vx_info *find_or_create_vx_info(int);
+extern int vx_info_id_valid(int);
+
+extern int vx_migrate_task(struct task_struct *, struct vx_info *);
+
+#endif	/* __KERNEL__ */
+
+#include "switch.h"
+
+/* vinfo commands */
+
+#define	VCMD_task_xid		VC_CMD(VINFO, 1, 0)
+#define	VCMD_task_nid		VC_CMD(VINFO, 2, 0)
+
+#ifdef	__KERNEL__
+extern int vc_task_xid(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+#define	VCMD_vx_info		VC_CMD(VINFO, 5, 0)
+#define	VCMD_nx_info		VC_CMD(VINFO, 6, 0)
+
+struct  vcmd_vx_info_v0 {
+	uint32_t xid;
+	uint32_t initpid;
+	/* more to come */	
+};
+
+#ifdef	__KERNEL__
+extern int vc_vx_info(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+#define VCMD_create_context	VC_CMD(VSETUP, 1, 0)
+#define VCMD_migrate_context	VC_CMD(PROCMIG, 1, 0)
+
+#ifdef	__KERNEL__
+extern int vc_create_context(uint32_t, void *);
+extern int vc_migrate_context(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+#define VCMD_get_flags		VC_CMD(FLAGS, 1, 0)
+#define VCMD_set_flags		VC_CMD(FLAGS, 2, 0)
+
+struct  vcmd_ctx_flags_v0 {
+	uint64_t flagword;
+	uint64_t mask;
+};
+
+#ifdef	__KERNEL__
+extern int vc_get_flags(uint32_t, void *);
+extern int vc_set_flags(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+#define VXF_INFO_LOCK		0x00000001
+#define VXF_INFO_SCHED		0x00000002
+#define VXF_INFO_NPROC		0x00000004
+#define VXF_INFO_PRIVATE	0x00000008
+
+#define VXF_INFO_INIT		0x00000010
+#define VXF_INFO_HIDE		0x00000020
+#define VXF_INFO_ULIMIT		0x00000040
+#define VXF_INFO_NSPACE		0x00000080
+
+#define	VXF_SCHED_HARD		0x00000100
+#define	VXF_SCHED_PRIO		0x00000200
+#define	VXF_SCHED_PAUSE		0x00000400
+
+#define VXF_VIRT_MEM		0x00010000
+#define VXF_VIRT_UPTIME		0x00020000
+#define VXF_VIRT_CPU		0x00040000
+
+#define VXF_HIDE_MOUNT		0x01000000
+#define VXF_HIDE_NETIF		0x02000000
+
+#define	VXF_STATE_SETUP		(1ULL<<32)
+#define	VXF_STATE_INIT		(1ULL<<33)
+
+
+#define	VXF_ONE_TIME		(0x0003ULL<<32)
+
+#define VCMD_get_ccaps		VC_CMD(FLAGS, 3, 0)
+#define VCMD_set_ccaps		VC_CMD(FLAGS, 4, 0)
+
+struct  vcmd_ctx_caps_v0 {
+	uint64_t bcaps;
+	uint64_t ccaps;
+	uint64_t cmask;
+};
+
+#ifdef	__KERNEL__
+extern int vc_get_ccaps(uint32_t, void *);
+extern int vc_set_ccaps(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+#define VXC_SET_UTSNAME		0x00000001
+#define VXC_SET_RLIMIT		0x00000002
+
+#define VXC_ICMP_PING		0x00000100
+
+#define VXC_SECURE_MOUNT	0x00010000
+
+
+#endif	/* _VX_CONTEXT_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/cvirt.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/cvirt.h
--- linux-2.6.5/include/linux/vserver/cvirt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/cvirt.h	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,107 @@
+#if	defined(__KERNEL__) && defined(_VX_INFO_DEF_)
+
+#include <linux/utsname.h>
+#include <linux/rwsem.h>
+#include <linux/jiffies.h>
+#include <linux/time.h>
+#include <asm/atomic.h>
+
+/* context sub struct */
+
+struct sock_acc {
+	atomic_t count;
+	atomic_t total;
+};
+
+struct _vx_cvirt {
+	int nr_threads;
+	int nr_running;
+	int max_threads;
+	unsigned long total_forks;
+
+	unsigned int bias_cswtch;
+	long bias_jiffies;
+	long bias_idle;
+	struct timespec bias_tp;
+
+	struct new_utsname utsname;
+
+	struct sock_acc sock[5][3];
+};
+
+
+static inline long vx_sock_count(struct _vx_cvirt *cvirt, int type, int pos)
+{
+	return atomic_read(&cvirt->sock[type][pos].count);
+}
+
+
+static inline long vx_sock_total(struct _vx_cvirt *cvirt, int type, int pos)
+{
+	return atomic_read(&cvirt->sock[type][pos].total);
+}
+
+
+static inline void vx_info_init_cvirt(struct _vx_cvirt *cvirt)
+{
+	int i,j;
+
+	cvirt->nr_threads = 1;
+	// new->virt.bias_cswtch = kstat.context_swtch;
+	cvirt->bias_jiffies = jiffies;
+	/* new->virt.bias_idle = init_tasks[0]->times.tms_utime +
+		init_tasks[0]->times.tms_stime;
+	*/
+	do_posix_clock_monotonic_gettime(&cvirt->bias_tp);
+
+	down_read(&uts_sem);
+	cvirt->utsname = system_utsname;
+	up_read(&uts_sem);
+
+	for (i=0; i<5; i++) {
+		for (j=0; j<3; j++) {
+			atomic_set(&cvirt->sock[i][j].count, 0);
+			atomic_set(&cvirt->sock[i][j].total, 0);
+		}
+	}
+}
+
+static inline int vx_info_proc_cvirt(struct _vx_cvirt *cvirt, char *buffer)
+{
+	int i,j, length = 0;
+	static char *type[] = { "UNSPEC", "UNIX", "INET", "INET6", "OTHER" };
+
+	for (i=0; i<5; i++) {
+		length += sprintf(buffer + length,
+			"%s:", type[i]);
+		for (j=0; j<3; j++) {
+			length += sprintf(buffer + length,
+				"\t%12lu/%-12lu"
+				,vx_sock_count(cvirt, i, j)
+				,vx_sock_total(cvirt, i, j)
+				);
+		}	
+		buffer[length++] = '\n';
+	}
+	return length;
+}
+
+#else	/* _VX_INFO_DEF_ */
+#ifndef _VX_CVIRT_H
+#define _VX_CVIRT_H
+
+#include "switch.h"
+
+/*  cvirt vserver commands */
+
+
+#ifdef	__KERNEL__
+
+struct timespec;
+
+void vx_vsi_uptime(struct timespec *uptime);
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _VX_CVIRT_H */
+#endif
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/inode.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/inode.h
--- linux-2.6.5/include/linux/vserver/inode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/inode.h	2004-04-05 00:55:16.000000000 +0200
@@ -0,0 +1,67 @@
+#ifndef _VX_INODE_H
+#define _VX_INODE_H
+
+#include "switch.h"
+
+/*  inode vserver commands */
+
+#define VCMD_get_iattr_v0	VC_CMD(INODE, 1, 0)
+#define VCMD_set_iattr_v0	VC_CMD(INODE, 2, 0)
+
+#define VCMD_get_iattr		VC_CMD(INODE, 1, 1)
+#define VCMD_set_iattr		VC_CMD(INODE, 2, 1)
+
+struct  vcmd_ctx_iattr_v0 {
+	/* device handle in id */
+	uint64_t ino;
+	uint32_t xid;
+	uint32_t flags;
+	uint32_t mask;
+};
+
+struct  vcmd_ctx_iattr_v1 {
+	const char __user *name;
+	uint32_t xid;
+	uint32_t flags;
+	uint32_t mask;
+};
+
+
+#define IATTR_XID	0x01000000
+
+#define IATTR_ADMIN	0x00000001
+#define IATTR_WATCH	0x00000002
+#define IATTR_HIDE	0x00000004
+#define IATTR_FLAGS	0x00000007
+
+#define IATTR_BARRIER	0x00010000
+#define	IATTR_IUNLINK	0x00020000
+#define	IATTR_IMMUTABLE	0x00040000
+
+
+#ifdef	CONFIG_PROC_SECURE
+#define	IATTR_PROC_DEFAULT	( IATTR_ADMIN | IATTR_HIDE )
+#define	IATTR_PROC_SYMLINK	( IATTR_ADMIN )
+#else
+#define	IATTR_PROC_DEFAULT	( IATTR_ADMIN )
+#define	IATTR_PROC_SYMLINK	( IATTR_ADMIN )
+#endif
+
+#ifdef	__KERNEL__
+
+#define vx_hide_check(c,m)      (((m) & IATTR_HIDE) ? vx_check(c,m) : 1)
+
+extern int vc_get_iattr_v0(uint32_t, void *);
+extern int vc_set_iattr_v0(uint32_t, void *);
+
+extern int vc_get_iattr(uint32_t, void *);
+extern int vc_set_iattr(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+/* inode ioctls */
+
+#define	FIOC_GETXFLG	_IOR('x', 5, long)
+#define	FIOC_SETXFLG	_IOW('x', 6, long)
+
+#endif	/* _VX_LEGACY_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/legacy.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/legacy.h
--- linux-2.6.5/include/linux/vserver/legacy.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/legacy.h	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,52 @@
+#ifndef _VX_LEGACY_H
+#define _VX_LEGACY_H
+
+#include "switch.h"
+#include "network.h"
+
+/*  compatibiliy vserver commands */
+
+#define VCMD_new_s_context	VC_CMD(COMPAT, 1, 1)
+#define VCMD_set_ipv4root	VC_CMD(COMPAT, 2, 3)
+
+/*  compatibiliy vserver arguments */
+
+struct  vcmd_new_s_context_v1 {
+	uint32_t remove_cap;
+	uint32_t flags;
+};
+
+struct  vcmd_set_ipv4root_v3 {
+	/* number of pairs in id */
+	uint32_t broadcast;
+	struct {
+		uint32_t ip;
+		uint32_t mask;
+	} ip_mask_pair[NB_IPV4ROOT];
+};
+
+
+#define VX_INFO_LOCK		1	/* Can't request a new vx_id */
+#define VX_INFO_NPROC		4	/* Limit number of processes in a context */
+#define VX_INFO_PRIVATE		8	/* Noone can join this security context */
+#define VX_INFO_INIT		16	/* This process wants to become the */
+					/* logical process 1 of the security */
+					/* context */
+#define VX_INFO_HIDEINFO	32	/* Hide some information in /proc */
+#define VX_INFO_ULIMIT		64	/* Use ulimit of the current process */
+					/* to become the global limits */
+					/* of the context */
+#define VX_INFO_NAMESPACE	128	/* save private namespace */
+
+	
+#define NB_S_CONTEXT	16
+
+#define NB_IPV4ROOT	16
+
+
+#ifdef	__KERNEL__
+extern int vc_new_s_context(uint32_t, void *);
+extern int vc_set_ipv4root(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+#endif	/* _VX_LEGACY_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/limit.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/limit.h
--- linux-2.6.5/include/linux/vserver/limit.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/limit.h	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,94 @@
+#if	defined(__KERNEL__) && defined(_VX_INFO_DEF_)
+
+#include <asm/atomic.h>
+#include <asm/resource.h>
+
+/* context sub struct */
+
+#define	NUM_RLIMITS	20
+
+#define	VLIMIT_SOCK	16
+
+
+struct _vx_limit {
+	atomic_t ticks;
+
+	unsigned long rlim[NUM_RLIMITS];	/* Per context limit */
+	atomic_t res[NUM_RLIMITS];		/* Current value */
+};
+
+static inline void vx_info_init_limit(struct _vx_limit *limit)
+{
+	int lim;
+
+	for (lim=0; lim<NUM_RLIMITS; lim++) {
+		limit->rlim[lim] = RLIM_INFINITY;
+		atomic_set(&limit->res[lim], 0);
+	}
+}
+
+static inline int vx_info_proc_limit(struct _vx_limit *limit, char *buffer)
+{
+	return sprintf(buffer,
+		"PROC:\t%8d/%ld\n"
+		"VM:\t%8d/%ld\n"
+		"VML:\t%8d/%ld\n"		
+		"RSS:\t%8d/%ld\n"
+		"FILES:\t%8d/%ld\n"
+		,atomic_read(&limit->res[RLIMIT_NPROC])
+		,limit->rlim[RLIMIT_NPROC]
+		,atomic_read(&limit->res[RLIMIT_AS])
+		,limit->rlim[RLIMIT_AS]
+		,atomic_read(&limit->res[RLIMIT_MEMLOCK])
+		,limit->rlim[RLIMIT_MEMLOCK]
+		,atomic_read(&limit->res[RLIMIT_RSS])
+		,limit->rlim[RLIMIT_RSS]
+		,atomic_read(&limit->res[RLIMIT_NOFILE])
+		,limit->rlim[RLIMIT_NOFILE]
+		);
+}
+
+#else	/* _VX_INFO_DEF_ */
+#ifndef _VX_LIMIT_H
+#define _VX_LIMIT_H
+
+#include "switch.h"
+
+/*  rlimit vserver commands */
+
+#define VCMD_get_rlimit		VC_CMD(RLIMIT, 1, 0)
+#define VCMD_set_rlimit		VC_CMD(RLIMIT, 2, 0)
+#define VCMD_get_rlimit_mask	VC_CMD(RLIMIT, 3, 0)
+
+struct  vcmd_ctx_rlimit_v0 {
+	uint32_t id;
+	uint64_t minimum;
+	uint64_t softlimit;
+	uint64_t maximum;
+};
+
+struct  vcmd_ctx_rlimit_mask_v0 {
+	uint32_t minimum;
+	uint32_t softlimit;
+	uint32_t maximum;
+};
+
+#define CRLIM_UNSET		(0ULL)
+#define CRLIM_INFINITY		(~0ULL)
+#define CRLIM_KEEP		(~1ULL)
+
+#ifdef	__KERNEL__
+extern int vc_get_rlimit(uint32_t, void *);
+extern int vc_set_rlimit(uint32_t, void *);
+extern int vc_get_rlimit_mask(uint32_t, void *);
+
+struct sysinfo;
+
+void vx_vsi_meminfo(struct sysinfo *);
+void vx_vsi_swapinfo(struct sysinfo *);
+
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _VX_LIMIT_H */
+#endif
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/namespace.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/namespace.h
--- linux-2.6.5/include/linux/vserver/namespace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/namespace.h	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,52 @@
+#ifndef _VX_NAMESPACE_H
+#define _VX_NAMESPACE_H
+
+#include <linux/types.h>
+
+	
+/* virtual host info names */
+
+#define	VCMD_vx_set_vhi_name	VC_CMD(VHOST, 1, 0)
+#define	VCMD_vx_get_vhi_name	VC_CMD(VHOST, 2, 0)
+
+struct  vcmd_vx_vhi_name_v0 {
+	uint32_t field;
+	char name[65];
+};
+
+
+enum vx_vhi_name_field {
+	VHIN_CONTEXT=0,
+	VHIN_SYSNAME,
+	VHIN_NODENAME,
+	VHIN_RELEASE,
+	VHIN_VERSION,
+	VHIN_MACHINE,
+	VHIN_DOMAINNAME,
+};
+
+
+#ifdef	__KERNEL__
+extern int vc_set_vhi_name(uint32_t, void *);
+extern int vc_get_vhi_name(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+
+#define	VCMD_enter_namespace	VC_CMD(PROCALT, 1, 0)
+#define	VCMD_cleanup_namespace	VC_CMD(PROCALT, 2, 0)
+#define	VCMD_set_namespace	VC_CMD(PROCALT, 3, 0)
+
+#ifdef	__KERNEL__
+
+struct vx_info;
+struct namespace;
+struct fs_struct;
+
+extern int vx_set_namespace(struct vx_info *, struct namespace *, struct fs_struct *);
+
+extern int vc_enter_namespace(uint32_t, void *);
+extern int vc_cleanup_namespace(uint32_t, void *);
+extern int vc_set_namespace(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+#endif	/* _VX_NAMESPACE_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/network.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/network.h
--- linux-2.6.5/include/linux/vserver/network.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/network.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,44 @@
+#ifndef _VX_NETWORK_H
+#define _VX_NETWORK_H
+
+
+#define NB_IPV4ROOT	16
+
+#ifdef	__KERNEL__
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/utsname.h>
+#include <asm/resource.h>
+#include <asm/atomic.h>
+
+
+struct ip_info {
+	struct list_head ip_list;	/* linked list of ipinfos */
+	nid_t ip_id;			/* vnet id */
+	atomic_t ip_refcount;
+	int nbipv4;
+	__u32 ipv4[NB_IPV4ROOT];	/* Process can only bind to these IPs */
+					/* The first one is used to connect */
+					/* and for bind any service */
+					/* The other must be used explicity */
+	__u32 mask[NB_IPV4ROOT];	/* Netmask for each ipv4 */
+					/* Used to select the proper source */
+					/* address for sockets */
+	__u32 v4_bcast;			/* Broadcast address to receive UDP  */
+};
+
+
+extern spinlock_t iplist_lock;
+extern struct list_head ip_infos;
+
+
+void free_ip_info(struct ip_info *);
+struct ip_info *create_ip_info(void);
+
+extern struct ip_info *find_ip_info(int);
+extern int ip_info_id_valid(int);
+
+
+#endif	/* __KERNEL__ */
+#endif	/* _VX_NETWORK_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/sched.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/sched.h
--- linux-2.6.5/include/linux/vserver/sched.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/sched.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,134 @@
+#if	defined(__KERNEL__) && defined(_VX_INFO_DEF_)
+
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <asm/atomic.h>
+#include <asm/param.h>
+#include <asm/cpumask.h>
+
+/* context sub struct */
+
+struct _vx_sched {
+	spinlock_t tokens_lock; /* lock for this structure */
+
+	int fill_rate;		/* Fill rate: add X tokens... */
+	int interval;		/* Divisor:   per Y jiffies   */
+	atomic_t tokens;	/* number of CPU tokens in this context */
+	int tokens_min;		/* Limit:     minimum for unhold */
+	int tokens_max;		/* Limit:     no more than N tokens */
+	uint32_t jiffies;	/* add an integral multiple of Y to this */
+
+	uint64_t ticks;		/* token tick events */
+	cpumask_t cpus_allowed;	/* cpu mask for context */
+};
+
+static inline void vx_info_init_sched(struct _vx_sched *sched)
+{
+        /* scheduling; hard code starting values as constants */
+        sched->fill_rate	= 1;
+        sched->interval		= 4;
+        sched->tokens_min	= HZ >> 4;
+        sched->tokens_max	= HZ >> 1;
+        sched->jiffies		= jiffies;
+        sched->tokens_lock	= SPIN_LOCK_UNLOCKED;
+
+        atomic_set(&sched->tokens, HZ >> 2);
+	sched->cpus_allowed	= CPU_MASK_ALL;
+}
+
+static inline int vx_info_proc_sched(struct _vx_sched *sched, char *buffer)
+{
+	return sprintf(buffer,
+		"Ticks:\t%16lld\n"
+		"Token:\t\t%8d\n"
+		"FillRate:\t%8d\n"
+		"Interval:\t%8d\n"		
+		"TokensMin:\t%8d\n"
+		"TokensMax:\t%8d\n"
+		,sched->ticks
+		,atomic_read(&sched->tokens)
+		,sched->fill_rate
+		,sched->interval
+		,sched->tokens_min
+		,sched->tokens_max
+		);
+}
+
+
+#else	/* _VX_INFO_DEF_ */
+#ifndef _VX_SCHED_H
+#define _VX_SCHED_H
+
+#include "switch.h"
+
+/*  sched vserver commands */
+
+#define VCMD_set_sched_v1	VC_CMD(SYSTEST, 1, 1)
+
+struct  vcmd_set_sched_v1 {
+	int32_t fill_rate;
+	int32_t period;
+	int32_t fill_level;
+	int32_t bucket_size;
+};
+
+#define VCMD_set_sched		VC_CMD(SCHED, 1, 2)
+
+struct  vcmd_set_sched_v2 {
+	int32_t fill_rate;
+	int32_t interval;
+	int32_t tokens;
+	int32_t tokens_min;
+	int32_t tokens_max;
+	uint64_t cpu_mask;
+};
+
+#define SCHED_KEEP		(-2)
+
+#ifdef	__KERNEL__
+
+extern int vc_set_sched_v1(uint32_t, void *);
+extern int vc_set_sched(uint32_t, void *);
+
+
+#define VAVAVOOM_RATIO		50
+
+#include "context.h"
+
+
+/* scheduling stuff */
+
+int effective_vavavoom(struct task_struct *, int);
+
+int vx_tokens_recalc(struct vx_info *);
+
+/* new stuff ;) */
+
+static inline int vx_tokens_avail(struct vx_info *vxi)
+{
+	return atomic_read(&vxi->sched.tokens);
+}
+
+static inline void vx_consume_token(struct vx_info *vxi)
+{
+	atomic_dec(&vxi->sched.tokens);
+}
+
+static inline int vx_need_resched(struct task_struct *p, struct vx_info *vxi)
+{
+	p->time_slice--;
+	if (vxi) {
+		int tokens;
+		if ((tokens = vx_tokens_avail(vxi)) > 0)
+			vx_consume_token(vxi);
+
+		return ((p->time_slice == 0) || (tokens < 1));
+	} else
+		return (p->time_slice == 0);
+}
+
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _VX_SCHED_H */
+#endif
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/signal.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/signal.h
--- linux-2.6.5/include/linux/vserver/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/signal.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,19 @@
+#ifndef _VX_SIGNAL_H
+#define _VX_SIGNAL_H
+
+#include "switch.h"
+
+/*  context signalling */
+
+#define VCMD_ctx_kill		VC_CMD(PROCTRL, 1, 0)
+
+struct  vcmd_ctx_kill_v0 {
+	int32_t pid;
+	int32_t sig;
+};
+
+#ifdef	__KERNEL__
+extern int vc_ctx_kill(uint32_t, void *);
+
+#endif	/* __KERNEL__ */
+#endif	/* _VX_SIGNAL_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/switch.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/switch.h
--- linux-2.6.5/include/linux/vserver/switch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/switch.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,88 @@
+#ifndef _VX_SWITCH_H
+#define _VX_SWITCH_H
+
+#include <linux/types.h>
+
+#define VC_CATEGORY(c)		(((c) >> 24) & 0x3F)
+#define VC_COMMAND(c)		(((c) >> 16) & 0xFF)
+#define VC_VERSION(c)		((c) & 0xFFF)
+
+#define VC_CMD(c,i,v)		((((VC_CAT_ ## c) & 0x3F) << 24) \
+				| (((i) & 0xFF) << 16) | ((v) & 0xFFF))
+
+/*
+
+  Syscall Matrix V2.5
+
+         |VERSION|CREATE |MODIFY |MIGRATE|CONTROL|EXPERIM| |SPECIAL|SPECIAL|
+         |STATS  |DESTROY|ALTER  |CHANGE |LIMIT  |TEST   | |       |       |
+         |INFO   |SETUP  |       |MOVE   |       |       | |       |       |
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  SYSTEM |VERSION|       |       |       |       |       | |DEVICES|       |
+  HOST   |     00|     01|     02|     03|     04|     05| |     06|     07|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  CPU    |       |       |PROCALT|PROCMIG|PROCTRL|       | |SCHED. |       |
+  PROCESS|     08|     09|     10|     11|     12|     13| |     14|     15|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  MEMORY |       |       |       |       |       |       | |SWAP   |       |
+         |     16|     17|     18|     19|     20|     21| |     22|     23|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  NETWORK|       |       |       |       |       |       | |SERIAL |       |
+         |     24|     25|     26|     27|     28|     29| |     30|     31|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  DISK   |       |       |       |       |       |       | |INODE  |       |
+  VFS    |     32|     33|     34|     35|     36|     37| |     38|     39|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  OTHER  |       |       |       |       |       |       | |VINFO  |       |
+         |     40|     41|     42|     43|     44|     45| |     46|     47|
+  =======+=======+=======+=======+=======+=======+=======+ +=======+=======+
+  SPECIAL|       |       |       |       |FLAGS  |       | |       |       |
+         |     48|     49|     50|     51|     52|     53| |     54|     55|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  SPECIAL|       |       |       |       |RLIMIT |SYSCALL| |       |COMPAT |
+         |     56|     57|     58|     59|     60|TEST 61| |     62|     63|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+
+*/
+
+#define VC_CAT_VERSION		0
+
+#define VC_CAT_VSETUP		1
+#define	VC_CAT_VHOST		2
+	
+#define	VC_CAT_PROCALT		10
+#define	VC_CAT_PROCMIG		11
+#define VC_CAT_PROCTRL		12
+
+#define VC_CAT_SCHED		14
+#define VC_CAT_INODE		38
+
+#define	VC_CAT_VINFO		46
+
+#define VC_CAT_FLAGS		52
+#define VC_CAT_RLIMIT		60
+
+#define VC_CAT_SYSTEST		61
+#define VC_CAT_COMPAT		63
+	
+/*  interface version */
+
+#define VCI_VERSION		0x00010014
+
+
+/*  query version */
+
+#define VCMD_get_version	VC_CMD(VERSION, 0, 0)
+
+
+#ifdef	__KERNEL__
+
+#include <linux/errno.h>
+
+#define	ENOTSUP		-EOPNOTSUPP
+
+#else	/* __KERNEL__ */
+#define	__user
+#endif	/* __KERNEL__ */
+
+#endif	/* _VX_SWITCH_H */
diff -NurpP --minimal linux-2.6.5/include/linux/vserver/xid.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver/xid.h
--- linux-2.6.5/include/linux/vserver/xid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver/xid.h	2004-04-05 00:55:19.000000000 +0200
@@ -0,0 +1,64 @@
+#ifndef _LINUX_VXID_H_
+#define _LINUX_VXID_H_
+
+#ifdef CONFIG_INOXID_NONE
+
+#define	INOXID_UID(uid, gid)		(uid)
+#define	INOXID_GID(uid, gid)		(gid)
+#define	INOXID_XID(uid, gid, xid)	(0)
+
+#define	XIDINO_UID(uid, xid)		(uid)
+#define	XIDINO_GID(gid, xid)		(gid)
+
+#define	MAX_UID		0xFFFFFFFF
+#define	MAX_GID		0xFFFFFFFF
+
+#endif
+
+#ifdef CONFIG_INOXID_GID16
+
+#define	INOXID_UID(uid, gid)		(uid)
+#define	INOXID_GID(uid, gid)		((gid) & 0xFFFF)
+#define	INOXID_XID(uid, gid, xid)	(((gid) >> 16) & 0xFFFF)
+
+#define	XIDINO_UID(uid, xid)		(uid)
+#define	XIDINO_GID(gid, xid)		(((gid) & 0xFFFF) | ((xid) << 16))
+
+#define	MAX_UID		0xFFFFFFFF
+#define	MAX_GID		0x0000FFFF
+
+#endif
+
+#ifdef CONFIG_INOXID_GID24
+
+#define	INOXID_UID(uid, gid)		((uid) & 0xFFFFFF)
+#define	INOXID_GID(uid, gid)		((gid) & 0xFFFFFF)
+#define	INOXID_XID(uid, gid, xid)	((((uid) >> 16) & 0xFF00) | (((gid) >> 24) & 0xFF))
+
+#define	XIDINO_UID(uid, xid)		(((uid) & 0xFFFFFF) | (((xid) & 0xFF00) << 16))
+#define	XIDINO_GID(gid, xid)		(((gid) & 0xFFFFFF) | (((xid) & 0x00FF) << 24))
+
+#define	MAX_UID		0x00FFFFFF
+#define	MAX_GID		0x00FFFFFF
+
+#endif
+
+#ifdef CONFIG_INOXID_GID32
+
+#define	INOXID_UID(uid, gid)		(uid)
+#define	INOXID_GID(uid, gid)		(gid)
+#define	INOXID_XID(uid, gid, xid)	(xid)
+
+#define	XIDINO_UID(uid, xid)		(uid)
+#define	XIDINO_GID(gid, xid)		(gid)
+
+#define	MAX_UID		0xFFFFFFFF
+#define	MAX_GID		0xFFFFFFFF
+
+#endif
+
+#define	FIOC_GETXID	_IOR('x', 1, long)
+#define	FIOC_SETXID	_IOW('x', 2, long)
+#define	FIOC_SETXIDJ	_IOW('x', 3, long)
+
+#endif
diff -NurpP --minimal linux-2.6.5/include/linux/vserver.h linux-2.6.5-vs1.9.0pre2/include/linux/vserver.h
--- linux-2.6.5/include/linux/vserver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/linux/vserver.h	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _LINUX_VSERVER_H
+#define _LINUX_VSERVER_H
+
+#include <linux/vserver/context.h>
+#include <linux/vserver/network.h>
+#include <linux/vinline.h>
+
+#endif
diff -NurpP --minimal linux-2.6.5/include/net/route.h linux-2.6.5-vs1.9.0pre2/include/net/route.h
--- linux-2.6.5/include/net/route.h	2004-03-11 03:55:20.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/net/route.h	2004-04-05 00:55:13.000000000 +0200
@@ -33,6 +33,7 @@
 #include <linux/route.h>
 #include <linux/ip.h>
 #include <linux/cache.h>
+#include <linux/vinline.h>
 
 #ifndef __KERNEL__
 #warning This file is not supposed to be used outside of kernel.
@@ -146,6 +147,59 @@ static inline char rt_tos2priority(u8 to
 	return ip_tos2prio[IPTOS_TOS(tos)>>1];
 }
 
+#define IPI_LOOPBACK	0x0100007f
+
+static inline int ip_find_src(struct ip_info *ipi, struct rtable **rp, struct flowi *fl)
+{
+	int err;
+	int i, n = ipi->nbipv4;
+	u32 ipv4root = ipi->ipv4[0];
+
+	if (ipv4root == 0)
+		return 0;
+
+	if (fl->fl4_src == 0) {
+		if (n > 1) {
+			u32 foundsrc;
+
+			err = __ip_route_output_key(rp, fl);
+			if (err) {
+				fl->fl4_src = ipv4root;
+				err = __ip_route_output_key(rp, fl);
+			}
+			if (err)
+				return err;
+
+			foundsrc = (*rp)->rt_src;
+			ip_rt_put(*rp);
+
+			for (i=0; i<n; i++){
+				u32 mask = ipi->mask[i];
+				u32 ipv4 = ipi->ipv4[i];
+				u32 net4 = ipv4 & mask;
+
+				if (foundsrc == ipv4) {
+					fl->fl4_src = ipv4;
+					break;
+				}
+				if (!fl->fl4_src && (foundsrc & mask) == net4)
+					fl->fl4_src = ipv4;
+			}
+		}
+		if (fl->fl4_src == 0)
+			fl->fl4_src = (fl->fl4_dst == IPI_LOOPBACK)
+				? IPI_LOOPBACK : ipv4root;
+	} else {
+		for (i=0; i<n; i++) {
+			if (ipi->ipv4[i] == fl->fl4_src)
+				break;
+		}
+		if (i == n)
+			return -EPERM;
+	}
+	return 0;
+}
+
 static inline int ip_route_connect(struct rtable **rp, u32 dst,
 				   u32 src, u32 tos, int oif, u8 protocol,
 				   u16 sport, u16 dport, struct sock *sk)
@@ -160,7 +214,22 @@ static inline int ip_route_connect(struc
 					 .dport = dport } } };
 
 	int err;
-	if (!dst || !src) {
+	struct ip_info *ip_info = current->ip_info;
+
+	if (sk)
+		ip_info = sk->sk_ip_info;
+	vxdprintk("ip_route_connect(%p) %p,%p;%lx\n",
+		sk, ip_info, sk->sk_socket,
+		(sk->sk_socket?sk->sk_socket->flags:0));
+
+	if (ip_info) {
+		err = ip_find_src(ip_info, rp, &fl);
+		if (err)
+			return err;
+		if (fl.fl4_dst == IPI_LOOPBACK && !vx_check(0, VX_ADMIN))
+			fl.fl4_dst = ip_info->ipv4[0];
+	}	
+	if (!fl.fl4_dst || !fl.fl4_src) {
 		err = __ip_route_output_key(rp, &fl);
 		if (err)
 			return err;
diff -NurpP --minimal linux-2.6.5/include/net/scm.h linux-2.6.5-vs1.9.0pre2/include/net/scm.h
--- linux-2.6.5/include/net/scm.h	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/include/net/scm.h	2004-04-05 00:55:18.000000000 +0200
@@ -51,13 +51,13 @@ static __inline__ void scm_recv(struct s
 {
 	if (!msg->msg_control)
 	{
-		if (sock->passcred || scm->fp)
+		if (test_bit(SOCK_PASS_CRED, &sock->flags) || scm->fp)
 			msg->msg_flags |= MSG_CTRUNC;
 		scm_destroy(scm);
 		return;
 	}
 
-	if (sock->passcred)
+	if (test_bit(SOCK_PASS_CRED, &sock->flags))
 		put_cmsg(msg, SOL_SOCKET, SCM_CREDENTIALS, sizeof(scm->creds), &scm->creds);
 
 	if (!scm->fp)
diff -NurpP --minimal linux-2.6.5/include/net/sock.h linux-2.6.5-vs1.9.0pre2/include/net/sock.h
--- linux-2.6.5/include/net/sock.h	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/net/sock.h	2004-04-05 00:55:18.000000000 +0200
@@ -50,6 +50,7 @@
 #include <linux/security.h>
 
 #include <linux/filter.h>
+#include <linux/vinline.h>
 
 #include <asm/atomic.h>
 #include <net/dst.h>
@@ -109,6 +110,9 @@ struct sock_common {
 	struct hlist_node	skc_node;
 	struct hlist_node	skc_bind_node;
 	atomic_t		skc_refcnt;
+	xid_t			skc_xid;
+	struct vx_info		*skc_vx_info;
+	struct ip_info		*skc_ip_info;
 };
 
 /**
@@ -186,6 +190,9 @@ struct sock {
 #define sk_node			__sk_common.skc_node
 #define sk_bind_node		__sk_common.skc_bind_node
 #define sk_refcnt		__sk_common.skc_refcnt
+#define sk_xid			__sk_common.skc_xid
+#define sk_vx_info		__sk_common.skc_vx_info
+#define sk_ip_info		__sk_common.skc_ip_info
 	volatile unsigned char	sk_zapped;
 	unsigned char		sk_shutdown;
 	unsigned char		sk_use_write_queue;
diff -NurpP --minimal linux-2.6.5/include/net/tcp.h linux-2.6.5-vs1.9.0pre2/include/net/tcp.h
--- linux-2.6.5/include/net/tcp.h	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/include/net/tcp.h	2004-04-05 00:55:13.000000000 +0200
@@ -195,6 +195,8 @@ struct tcp_tw_bucket {
 #define tw_node			__tw_common.skc_node
 #define tw_bind_node		__tw_common.skc_bind_node
 #define tw_refcnt		__tw_common.skc_refcnt
+#define tw_xid			__tw_common.skc_xid
+#define tw_ip_info		__tw_common.skc_ip_info
 	volatile unsigned char	tw_substate;
 	unsigned char		tw_rcv_wscale;
 	__u16			tw_sport;
diff -NurpP --minimal linux-2.6.5/kernel/Makefile linux-2.6.5-vs1.9.0pre2/kernel/Makefile
--- linux-2.6.5/kernel/Makefile	2004-03-11 03:55:23.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/Makefile	2004-04-05 00:55:13.000000000 +0200
@@ -9,6 +9,11 @@ obj-y     = sched.o fork.o exec_domain.o
 	    rcupdate.o intermodule.o extable.o params.o posix-timers.o \
 	    kthread.o
 
+# mod-subdirs := vserver
+
+subdir-y  += vserver
+obj-y	  += vserver/vserver.o
+
 obj-$(CONFIG_FUTEX) += futex.o
 obj-$(CONFIG_GENERIC_ISA_DMA) += dma.o
 obj-$(CONFIG_SMP) += cpu.o
diff -NurpP --minimal linux-2.6.5/kernel/exit.c linux-2.6.5-vs1.9.0pre2/kernel/exit.c
--- linux-2.6.5/kernel/exit.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/kernel/exit.c	2004-04-05 00:55:13.000000000 +0200
@@ -35,6 +35,10 @@ int getrusage(struct task_struct *, int,
 static void __unhash_process(struct task_struct *p)
 {
 	nr_threads--;
+	if (p->vx_info) {
+		p->vx_info->cvirt.nr_threads--;
+		atomic_dec(&p->vx_info->limit.res[RLIMIT_NPROC]);
+	}
 	detach_pid(p, PIDTYPE_PID);
 	detach_pid(p, PIDTYPE_TGID);
 	if (thread_group_leader(p)) {
@@ -235,6 +239,7 @@ void reparent_to_init(void)
 	ptrace_unlink(current);
 	/* Reparent to init */
 	REMOVE_LINKS(current);
+	/* FIXME handle vchild_reaper/initpid */
 	current->parent = child_reaper;
 	current->real_parent = child_reaper;
 	SET_LINKS(current);
@@ -585,6 +590,7 @@ static inline void forget_original_paren
 	struct task_struct *p, *reaper = father;
 	struct list_head *_p, *_n;
 
+	/* FIXME handle vchild_reaper/initpid */
 	reaper = father->group_leader;
 	if (reaper == father)
 		reaper = child_reaper;
diff -NurpP --minimal linux-2.6.5/kernel/fork.c linux-2.6.5-vs1.9.0pre2/kernel/fork.c
--- linux-2.6.5/kernel/fork.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/fork.c	2004-04-05 00:55:18.000000000 +0200
@@ -86,6 +86,8 @@ void __put_task_struct(struct task_struc
 	WARN_ON(tsk == current);
 
 	security_task_free(tsk);
+	put_vx_info(tsk->vx_info);
+	put_ip_info(tsk->ip_info);
 	free_uid(tsk->user);
 	put_group_info(tsk->group_info);
 	free_task(tsk);
@@ -386,8 +388,9 @@ int mmlist_nr;
 #define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))
 
 #include <linux/init_task.h>
+#include <linux/vinline.h>
 
-static struct mm_struct * mm_init(struct mm_struct * mm)
+static struct mm_struct * mm_init(struct mm_struct * mm, struct vx_info *vxi)
 {
 	atomic_set(&mm->mm_users, 1);
 	atomic_set(&mm->mm_count, 1);
@@ -396,6 +399,7 @@ static struct mm_struct * mm_init(struct
 	mm->page_table_lock = SPIN_LOCK_UNLOCKED;
 	mm->ioctx_list_lock = RW_LOCK_UNLOCKED;
 	mm->ioctx_list = NULL;
+	mm->mm_vx_info = get_vx_info(vxi);
 	mm->default_kioctx = (struct kioctx)INIT_KIOCTX(mm->default_kioctx, *mm);
 	mm->free_area_cache = TASK_UNMAPPED_BASE;
 
@@ -410,14 +414,14 @@ static struct mm_struct * mm_init(struct
 /*
  * Allocate and initialize an mm_struct.
  */
-struct mm_struct * mm_alloc(void)
+struct mm_struct * mm_alloc(struct vx_info *vxi)
 {
 	struct mm_struct * mm;
 
 	mm = allocate_mm();
 	if (mm) {
 		memset(mm, 0, sizeof(*mm));
-		return mm_init(mm);
+		return mm_init(mm, vxi);
 	}
 	return NULL;
 }
@@ -432,6 +436,7 @@ void fastcall __mmdrop(struct mm_struct 
 	BUG_ON(mm == &init_mm);
 	mm_free_pgd(mm);
 	destroy_context(mm);
+	put_vx_info(mm->mm_vx_info);
 	free_mm(mm);
 }
 
@@ -547,7 +552,7 @@ static int copy_mm(unsigned long clone_f
 
 	/* Copy the current MM stuff.. */
 	memcpy(mm, oldmm, sizeof(*mm));
-	if (!mm_init(mm))
+	if (!mm_init(mm, current->vx_info))
 		goto fail_nomem;
 
 	if (init_new_context(tsk,mm))
@@ -851,6 +856,7 @@ struct task_struct *copy_process(unsigne
 {
 	int retval;
 	struct task_struct *p = NULL;
+	struct vx_info *vxi;
 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return ERR_PTR(-EINVAL);
@@ -879,7 +885,22 @@ struct task_struct *copy_process(unsigne
 	if (!p)
 		goto fork_out;
 
+	vxi = get_vx_info(p->vx_info);
+	get_ip_info(p->ip_info);
+
+	/* check vserver memory */
+	if (p->mm && !(clone_flags & CLONE_VM)) {
+		if (vx_vmpages_avail(p->mm, p->mm->total_vm))
+			vx_pages_add(p->mm->mm_vx_info, RLIMIT_AS, p->mm->total_vm);
+		else
+			goto bad_fork_free;
+	}
+
 	retval = -EAGAIN;
+	if (vxi && (atomic_read(&vxi->limit.res[RLIMIT_NPROC])
+		>= vxi->limit.rlim[RLIMIT_NPROC]))
+		goto bad_fork_free;
+
 	if (atomic_read(&p->user->processes) >=
 			p->rlim[RLIMIT_NPROC].rlim_cur) {
 		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&
@@ -1064,6 +1085,10 @@ struct task_struct *copy_process(unsigne
 		link_pid(p, p->pids + PIDTYPE_TGID, &p->group_leader->pids[PIDTYPE_TGID].pid);
 
 	nr_threads++;
+	if (vxi) {
+		vxi->cvirt.nr_threads++;
+		atomic_inc(&vxi->limit.res[RLIMIT_NPROC]);
+	}
 	write_unlock_irq(&tasklist_lock);
 	retval = 0;
 
@@ -1100,6 +1125,8 @@ bad_fork_cleanup_count:
 	atomic_dec(&p->user->processes);
 	free_uid(p->user);
 bad_fork_free:
+	put_ip_info(current->ip_info);
+	put_vx_info(vxi);
 	free_task(p);
 	goto fork_out;
 }
diff -NurpP --minimal linux-2.6.5/kernel/pid.c linux-2.6.5-vs1.9.0pre2/kernel/pid.c
--- linux-2.6.5/kernel/pid.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/pid.c	2004-04-05 00:55:18.000000000 +0200
@@ -224,7 +224,8 @@ void fastcall detach_pid(task_t *task, e
 
 task_t *find_task_by_pid(int nr)
 {
-	struct pid *pid = find_pid(PIDTYPE_PID, nr);
+	struct pid *pid = find_pid(PIDTYPE_PID,
+		vx_rmap_tgid(current->vx_info, nr));
 
 	if (!pid)
 		return NULL;
diff -NurpP --minimal linux-2.6.5/kernel/sched.c linux-2.6.5-vs1.9.0pre2/kernel/sched.c
--- linux-2.6.5/kernel/sched.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/kernel/sched.c	2004-04-05 00:55:13.000000000 +0200
@@ -39,6 +39,8 @@
 #include <linux/cpu.h>
 #include <linux/percpu.h>
 #include <linux/kthread.h>
+#include <linux/vserver/sched.h>
+#include <linux/vinline.h>
 
 #ifdef CONFIG_NUMA
 #define cpu_to_node_mask(cpu) node_to_cpumask(cpu_to_node(cpu))
@@ -214,6 +216,8 @@ struct runqueue {
 #endif
 	task_t *migration_thread;
 	struct list_head migration_queue;
+	struct list_head hold_queue;
+	int idle_tokens;
 
 	atomic_t nr_iowait;
 };
@@ -366,6 +370,9 @@ static int effective_prio(task_t *p)
 	bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;
 
 	prio = p->static_prio - bonus;
+	if (p->vx_info && __vx_flags(p->vx_info->vx_flags, VXF_SCHED_PRIO, 0))
+		prio += effective_vavavoom(p, MAX_USER_PRIO);
+
 	if (prio < MAX_RT_PRIO)
 		prio = MAX_RT_PRIO;
 	if (prio > MAX_PRIO-1)
@@ -1480,6 +1487,7 @@ void scheduler_tick(int user_ticks, int 
 	struct cpu_usage_stat *cpustat = &kstat_this_cpu.cpustat;
 	runqueue_t *rq = this_rq();
 	task_t *p = current;
+	struct vx_info *vxi = p->vx_info;
 
 	rq->timestamp_last_tick = sched_clock();
 
@@ -1496,6 +1504,9 @@ void scheduler_tick(int user_ticks, int 
 	}
 
 	if (p == rq->idle) {
+		if (!--rq->idle_tokens && !list_empty(&rq->hold_queue))
+			set_need_resched();	
+
 		if (atomic_read(&rq->nr_iowait) > 0)
 			cpustat->iowait += sys_ticks;
 		else
@@ -1538,7 +1549,7 @@ void scheduler_tick(int user_ticks, int 
 		}
 		goto out_unlock;
 	}
-	if (!--p->time_slice) {
+	if (vx_need_resched(p, vxi)) {
 		dequeue_task(p, rq->active);
 		set_tsk_need_resched(p);
 		p->prio = effective_prio(p);
@@ -1601,7 +1612,8 @@ asmlinkage void schedule(void)
 	struct list_head *queue;
 	unsigned long long now;
 	unsigned long run_time;
-	int idx;
+	struct vx_info *vxi;
+	int idx, maxidle = -HZ;
 
 	/*
 	 * Test if we are atomic.  Since do_exit() needs to call into
@@ -1651,6 +1663,36 @@ need_resched:
 			deactivate_task(prev, rq);
 	}
 
+	if (!list_empty(&rq->hold_queue)) {
+		struct list_head *l, *n;
+		int ret;
+
+		vxi = NULL;
+		list_for_each_safe(l, n, &rq->hold_queue) {
+			next = list_entry(l, task_t, run_list);
+			if (vxi == next->vx_info)
+				continue;
+
+			vxi = next->vx_info;
+			ret = vx_tokens_recalc(vxi);
+			// tokens = vx_tokens_avail(next);
+
+		//	printk("maxidle=%d, ret=%d\n", maxidle, ret);
+			if (ret > 0) {
+				list_del(&next->run_list);
+				next->state &= ~TASK_ONHOLD;
+				recalc_task_prio(next, now);
+				__activate_task(next, rq);
+				// printk(" unhold %p\n", next);
+				break;
+			}
+			if ((ret < 0) && (maxidle < ret))
+				maxidle = ret;
+		}	
+	}
+	rq->idle_tokens = -maxidle;
+
+pick_next:
 	if (unlikely(!rq->nr_running)) {
 #ifdef CONFIG_SMP
 		load_balance(rq, 1, cpu_to_node_mask(smp_processor_id()));
@@ -1678,6 +1720,21 @@ need_resched:
 	queue = array->queue + idx;
 	next = list_entry(queue->next, task_t, run_list);
 
+	vxi = next->vx_info;
+	if (vxi && __vx_flags(vxi->vx_flags,
+		VXF_SCHED_PAUSE|VXF_SCHED_HARD, 0)) {
+		int ret = vx_tokens_recalc(vxi);
+
+		if (unlikely(ret <= 0)) {
+			if (ret && (rq->idle_tokens > -ret))
+				rq->idle_tokens = -ret;
+			deactivate_task(next, rq);
+			list_add_tail(&next->run_list, &rq->hold_queue);
+			next->state |= TASK_ONHOLD;			
+			goto pick_next;
+		}
+	}
+
 	if (!rt_task(next) && next->activated > 0) {
 		unsigned long long delta = now - next->timestamp;
 
@@ -2944,6 +3001,7 @@ void __init sched_init(void)
 
 		spin_lock_init(&rq->lock);
 		INIT_LIST_HEAD(&rq->migration_queue);
+		INIT_LIST_HEAD(&rq->hold_queue);
 		atomic_set(&rq->nr_iowait, 0);
 		nr_running_init(rq);
 
diff -NurpP --minimal linux-2.6.5/kernel/signal.c linux-2.6.5-vs1.9.0pre2/kernel/signal.c
--- linux-2.6.5/kernel/signal.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/kernel/signal.c	2004-04-05 00:55:13.000000000 +0200
@@ -1031,6 +1031,9 @@ int group_send_sig_info(int sig, struct 
 	unsigned long flags;
 	int ret;
 
+	if (!vx_check(vx_task_xid(p), VX_ADMIN|VX_WATCH|VX_IDENT))
+		return -ESRCH;
+
 	ret = check_kill_permission(sig, info, p);
 	if (!ret && sig && p->sighand) {
 		spin_lock_irqsave(&p->sighand->siglock, flags);
diff -NurpP --minimal linux-2.6.5/kernel/sys.c linux-2.6.5-vs1.9.0pre2/kernel/sys.c
--- linux-2.6.5/kernel/sys.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/sys.c	2004-04-05 00:55:18.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/mman.h>
 #include <linux/smp_lock.h>
 #include <linux/notifier.h>
+#include <linux/kmod.h>
 #include <linux/reboot.h>
 #include <linux/prctl.h>
 #include <linux/init.h>
@@ -328,7 +329,7 @@ asmlinkage long sys_setpriority(int whic
 			if (!who)
 				user = current->user;
 			else
-				user = find_user(who);
+				user = find_user(vx_current_xid(), who);
 
 			if (!user)
 				goto out_unlock;
@@ -387,7 +388,7 @@ asmlinkage long sys_getpriority(int whic
 			if (!who)
 				user = current->user;
 			else
-				user = find_user(who);
+				user = find_user(vx_current_xid(), who);
 
 			if (!user)
 				goto out_unlock;
@@ -407,6 +408,72 @@ out_unlock:
 	return retval;
 }
 
+/*
+ *      vshelper path is set via /proc/sys
+ *      invoked by vserver sys_reboot(), with
+ *      the following arguments
+ *
+ *      argv [0] = vshelper_path;
+ *      argv [1] = action: "restart", "halt", "poweroff", ...
+ *      argv [2] = context identifier
+ *      argv [3] = additional argument (restart2)
+ *
+ *      envp [*] = type-specific parameters
+ */
+char vshelper_path[255] = "/sbin/vshelper";
+
+long vs_reboot(unsigned int cmd, void * arg)
+{
+	char id_buf[8], cmd_buf[32];
+	char uid_buf[32], pid_buf[32];
+	char buffer[256];
+
+	char *argv[] = {vshelper_path, NULL, id_buf, NULL, 0};
+	char *envp[] = {"HOME=/", "TERM=linux",
+			"PATH=/sbin:/usr/sbin:/bin:/usr/bin",
+			uid_buf, pid_buf, cmd_buf, 0};
+
+	snprintf(id_buf, sizeof(id_buf)-1, "%d", vx_current_xid());
+
+	snprintf(cmd_buf, sizeof(cmd_buf)-1, "VS_CMD=%08x", cmd);
+	snprintf(uid_buf, sizeof(uid_buf)-1, "VS_UID=%d", current->uid);
+	snprintf(pid_buf, sizeof(pid_buf)-1, "VS_PID=%d", current->pid);
+
+	switch (cmd) {
+	case LINUX_REBOOT_CMD_RESTART:
+		argv[1] = "restart";
+		break;	
+
+	case LINUX_REBOOT_CMD_HALT:
+		argv[1] = "halt";
+		break;	
+
+	case LINUX_REBOOT_CMD_POWER_OFF:
+		argv[1] = "poweroff";
+		break;	
+
+	case LINUX_REBOOT_CMD_SW_SUSPEND:
+		argv[1] = "swsusp";
+		break;	
+
+	case LINUX_REBOOT_CMD_RESTART2:
+		if (strncpy_from_user(&buffer[0], (char *)arg, sizeof(buffer) - 1) < 0)
+			return -EFAULT;
+		argv[3] = buffer;
+	default:
+		argv[1] = "restart2";
+		break;	
+	}
+
+	/* maybe we should wait ? */
+	if (call_usermodehelper(*argv, argv, envp, 0)) {
+		printk( KERN_WARNING
+			"vs_reboot(): failed to exec (%s %s %s %s)\n",
+			vshelper_path, argv[1], argv[2], argv[3]);
+		return -EPERM;
+	}
+	return 0;
+}
 
 /*
  * Reboot system call: for obvious reasons only root may call it,
@@ -432,6 +499,9 @@ asmlinkage long sys_reboot(int magic1, i
 	                magic2 != LINUX_REBOOT_MAGIC2C))
 		return -EINVAL;
 
+	if (!vx_check(0, VX_ADMIN|VX_WATCH))
+		return vs_reboot(cmd, arg);
+
 	lock_kernel();
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
@@ -626,7 +696,7 @@ static int set_user(uid_t new_ruid, int 
 {
 	struct user_struct *new_user;
 
-	new_user = alloc_uid(new_ruid);
+	new_user = alloc_uid(vx_current_xid(), new_ruid);
 	if (!new_user)
 		return -EAGAIN;
 
@@ -1365,7 +1435,7 @@ asmlinkage long sys_newuname(struct new_
 	int errno = 0;
 
 	down_read(&uts_sem);
-	if (copy_to_user(name,&system_utsname,sizeof *name))
+	if (copy_to_user(name, &vx_new_utsname(), sizeof *name))
 		errno = -EFAULT;
 	up_read(&uts_sem);
 	return errno;
@@ -1376,15 +1446,17 @@ asmlinkage long sys_sethostname(char __u
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) && !vx_ccaps(VXC_SET_UTSNAME))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.nodename, tmp, len);
-		system_utsname.nodename[len] = 0;
+		char *ptr = vx_new_uts(nodename);
+
+		memcpy(ptr, tmp, len);
+		ptr[len] = 0;
 		errno = 0;
 	}
 	up_write(&uts_sem);
@@ -1394,15 +1466,17 @@ asmlinkage long sys_sethostname(char __u
 asmlinkage long sys_gethostname(char __user *name, int len)
 {
 	int i, errno;
+	char *ptr;
 
 	if (len < 0)
 		return -EINVAL;
 	down_read(&uts_sem);
-	i = 1 + strlen(system_utsname.nodename);
+	ptr = vx_new_uts(nodename);
+	i = 1 + strlen(ptr);
 	if (i > len)
 		i = len;
 	errno = 0;
-	if (copy_to_user(name, system_utsname.nodename, i))
+	if (copy_to_user(name, ptr, i))
 		errno = -EFAULT;
 	up_read(&uts_sem);
 	return errno;
@@ -1417,7 +1491,7 @@ asmlinkage long sys_setdomainname(char _
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) && !vx_ccaps(VXC_SET_UTSNAME))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
@@ -1425,8 +1499,10 @@ asmlinkage long sys_setdomainname(char _
 	down_write(&uts_sem);
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.domainname, tmp, len);
-		system_utsname.domainname[len] = 0;
+		char *ptr = vx_new_uts(domainname);
+
+		memcpy(ptr, tmp, len);
+		ptr[len] = 0;
 		errno = 0;
 	}
 	up_write(&uts_sem);
@@ -1478,7 +1554,7 @@ asmlinkage long sys_setrlimit(unsigned i
 	old_rlim = current->rlim + resource;
 	if (((new_rlim.rlim_cur > old_rlim->rlim_max) ||
 	     (new_rlim.rlim_max > old_rlim->rlim_max)) &&
-	    !capable(CAP_SYS_RESOURCE))
+	    !capable(CAP_SYS_RESOURCE) && vx_ccaps(VXC_SET_RLIMIT))
 		return -EPERM;
 	if (resource == RLIMIT_NOFILE) {
 		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
diff -NurpP --minimal linux-2.6.5/kernel/sysctl.c linux-2.6.5-vs1.9.0pre2/kernel/sysctl.c
--- linux-2.6.5/kernel/sysctl.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/kernel/sysctl.c	2004-04-05 00:55:16.000000000 +0200
@@ -77,6 +77,7 @@ extern char modprobe_path[];
 #ifdef CONFIG_HOTPLUG
 extern char hotplug_path[];
 #endif
+extern char vshelper_path[];
 #ifdef CONFIG_CHR_DEV_SG
 extern int sg_big_buff;
 #endif
@@ -398,6 +399,15 @@ static ctl_table kern_table[] = {
 		.strategy	= &sysctl_string,
 	},
 #endif
+	{
+		.ctl_name	= KERN_VSHELPER,
+		.procname	= "vshelper",
+		.data		= &vshelper_path,
+		.maxlen		= 256,
+		.mode		= 0644,
+		.proc_handler	= &proc_dostring,
+		.strategy	= &sysctl_string,
+	},
 #ifdef CONFIG_CHR_DEV_SG
 	{
 		.ctl_name	= KERN_SG_BIG_BUFF,
diff -NurpP --minimal linux-2.6.5/kernel/timer.c linux-2.6.5-vs1.9.0pre2/kernel/timer.c
--- linux-2.6.5/kernel/timer.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/kernel/timer.c	2004-04-05 00:55:18.000000000 +0200
@@ -31,6 +31,8 @@
 #include <linux/time.h>
 #include <linux/jiffies.h>
 #include <linux/cpu.h>
+#include <linux/vserver/sched.h>
+#include <linux/vserver/cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/div64.h>
@@ -892,7 +894,7 @@ asmlinkage unsigned long sys_alarm(unsig
  */
 asmlinkage long sys_getpid(void)
 {
-	return current->tgid;
+	return vx_map_tgid(current->vx_info, current->tgid);
 }
 
 /*
@@ -936,7 +938,7 @@ asmlinkage long sys_getppid(void)
 #endif
 		break;
 	}
-	return pid;
+	return vx_map_tgid(current->vx_info, pid);
 }
 
 asmlinkage long sys_getuid(void)
@@ -1145,6 +1147,8 @@ asmlinkage long sys_sysinfo(struct sysin
 			tp.tv_nsec = tp.tv_nsec - NSEC_PER_SEC;
 			tp.tv_sec++;
 		}
+		if (vx_flags(VXF_VIRT_UPTIME, 0))
+			vx_vsi_uptime(&tp);
 		val.uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);
 
 		val.loads[0] = avenrun[0] << (SI_LOAD_SHIFT - FSHIFT);
@@ -1154,6 +1158,9 @@ asmlinkage long sys_sysinfo(struct sysin
 		val.procs = nr_threads;
 	} while (read_seqretry(&xtime_lock, seq));
 
+/*	if (vx_flags(VXF_VIRT_CPU, 0))
+		vx_vsi_cpu(val);
+*/
 	si_meminfo(&val);
 	si_swapinfo(&val);
 
diff -NurpP --minimal linux-2.6.5/kernel/user.c linux-2.6.5-vs1.9.0pre2/kernel/user.c
--- linux-2.6.5/kernel/user.c	2004-03-11 03:55:25.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/user.c	2004-04-05 00:55:13.000000000 +0200
@@ -20,8 +20,8 @@
 #define UIDHASH_BITS		8
 #define UIDHASH_SZ		(1 << UIDHASH_BITS)
 #define UIDHASH_MASK		(UIDHASH_SZ - 1)
-#define __uidhashfn(uid)	(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)
-#define uidhashentry(uid)	(uidhash_table + __uidhashfn((uid)))
+#define __uidhashfn(xid,uid)	((((uid) >> UIDHASH_BITS) + ((uid)^(xid))) & UIDHASH_MASK)
+#define uidhashentry(xid,uid)	(uidhash_table + __uidhashfn((xid),(uid)))
 
 static kmem_cache_t *uid_cachep;
 static struct list_head uidhash_table[UIDHASH_SZ];
@@ -46,7 +46,7 @@ static inline void uid_hash_remove(struc
 	list_del(&up->uidhash_list);
 }
 
-static inline struct user_struct *uid_hash_find(uid_t uid, struct list_head *hashent)
+static inline struct user_struct *uid_hash_find(xid_t xid, uid_t uid, struct list_head *hashent)
 {
 	struct list_head *up;
 
@@ -55,7 +55,7 @@ static inline struct user_struct *uid_ha
 
 		user = list_entry(up, struct user_struct, uidhash_list);
 
-		if(user->uid == uid) {
+		if(user->uid == uid && user->vx_id == xid) {
 			atomic_inc(&user->__count);
 			return user;
 		}
@@ -64,9 +64,9 @@ static inline struct user_struct *uid_ha
 	return NULL;
 }
 
-struct user_struct *find_user(uid_t uid)
+struct user_struct *find_user(xid_t xid, uid_t uid)
 {
-	return uid_hash_find(uid, uidhashentry(uid));
+	return uid_hash_find(xid, uid, uidhashentry(xid, uid));
 }
 
 void free_uid(struct user_struct *up)
@@ -78,13 +78,13 @@ void free_uid(struct user_struct *up)
 	}
 }
 
-struct user_struct * alloc_uid(uid_t uid)
+struct user_struct * alloc_uid(xid_t xid, uid_t uid)
 {
-	struct list_head *hashent = uidhashentry(uid);
+	struct list_head *hashent = uidhashentry(xid, uid);
 	struct user_struct *up;
 
 	spin_lock(&uidhash_lock);
-	up = uid_hash_find(uid, hashent);
+	up = uid_hash_find(xid, uid, hashent);
 	spin_unlock(&uidhash_lock);
 
 	if (!up) {
@@ -94,6 +94,7 @@ struct user_struct * alloc_uid(uid_t uid
 		if (!new)
 			return NULL;
 		new->uid = uid;
+		new->vx_id = xid;
 		atomic_set(&new->__count, 1);
 		atomic_set(&new->processes, 0);
 		atomic_set(&new->files, 0);
@@ -103,7 +104,7 @@ struct user_struct * alloc_uid(uid_t uid
 		 * on adding the same user already..
 		 */
 		spin_lock(&uidhash_lock);
-		up = uid_hash_find(uid, hashent);
+		up = uid_hash_find(xid, uid, hashent);
 		if (up) {
 			kmem_cache_free(uid_cachep, new);
 		} else {
@@ -148,7 +149,7 @@ static int __init uid_cache_init(void)
 
 	/* Insert the root user immediately (init already runs as root) */
 	spin_lock(&uidhash_lock);
-	uid_hash_insert(&root_user, uidhashentry(0));
+	uid_hash_insert(&root_user, uidhashentry(0,0));
 	spin_unlock(&uidhash_lock);
 
 	return 0;
diff -NurpP --minimal linux-2.6.5/kernel/vserver/Kconfig linux-2.6.5-vs1.9.0pre2/kernel/vserver/Kconfig
--- linux-2.6.5/kernel/vserver/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/Kconfig	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,64 @@
+#
+# Linux VServer configuration
+#
+
+menu "Linux VServer"
+
+config	VSERVER_LEGACY
+	bool	"Enable Legacy Kernel API"
+	default y
+	help
+	  This enables the legacy API used in vs1.xx, which allows
+	  to use older tools (for migration purposes).
+
+config	PROC_SECURE
+	bool	"Enable Proc Security"
+	depends on PROC_FS
+	default y
+	help
+	  Hide proc entries by default for xid>1
+
+choice
+	prompt	"Persistent Inode Context Tagging"
+	default	INOXID_GID24
+	help
+	  This adds persistent context information to filesystems
+	  mounted with the tagxid option. Tagging is a requirement
+	  for per context disk limits and per context quota.
+
+
+config	INOXID_NONE
+	bool	"Disabled"
+	help
+	  no context information is store for inodes
+
+config	INOXID_GID16
+	bool	"UID32/GID16"
+	help
+	  reduces GID to 16 bit, but leaves UID at 32 bit.
+
+config	INOXID_GID24
+	bool	"UID24/GID24"
+	help
+	  uses the upper 8bit from UID and GID for XID tagging
+	  which leaves 24bit for UID/GID each, which should be
+	  more than sufficient for normal use.
+
+config	INOXID_GID32
+	bool	"UID32/GID32"
+	help
+	  this uses otherwise reserved inode fields in the on
+	  disk representation, which limits the use to a few
+	  filesystems (currently ext2 and ext3)
+
+config	INOXID_MAGIC
+	bool	"Runtime"
+	help
+	  inodes are tagged when first accessed, this doesn't
+	  require any persistant information, but might give
+	  funny results for mixed access.
+
+endchoice
+
+endmenu
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/Makefile linux-2.6.5-vs1.9.0pre2/kernel/vserver/Makefile
--- linux-2.6.5/kernel/vserver/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/Makefile	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# Makefile for the Linux vserver routines.
+#
+
+
+obj-y		+= vserver.o
+
+vserver-y	:= switch.o context.o namespace.o sched.o network.o inode.o \
+		   limit.o cvirt.o signal.o
+
+vserver-$(CONFIG_VSERVER_LEGACY) += legacy.o
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/context.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/context.c
--- linux-2.6.5/kernel/vserver/context.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/context.c	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,489 @@
+/*
+ *  linux/kernel/vserver/context.c
+ *
+ *  Virtual Server: Context Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  context helper
+ *  V0.02  vx_ctx_kill syscall command
+ *  V0.03  replaced context_info calls
+ *  V0.04  redesign of struct (de)alloc
+ *  V0.05  rlimit basic implementation
+ *  V0.06  task_xid and info commands
+ *  V0.07  context flags and caps
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/legacy.h>
+#include <linux/vinline.h>
+#include <linux/kernel_stat.h>
+#include <linux/namespace.h>
+
+#include <asm/errno.h>
+
+
+/*  system functions */
+
+
+LIST_HEAD(vx_infos);
+
+spinlock_t vxlist_lock
+	__cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ *	struct vx_info allocation and deallocation
+ */
+
+static struct vx_info *alloc_vx_info(int id)
+{
+	struct vx_info *new = NULL;
+	
+	vxdprintk("alloc_vx_info(%d)\n", id);
+	/* would this benefit from a slab cache? */
+	new = kmalloc(sizeof(struct vx_info), GFP_KERNEL);
+	if (!new)
+		return 0;
+
+	memset (new, 0, sizeof(struct vx_info));
+	new->vx_id = id;
+	INIT_LIST_HEAD(&new->vx_list);
+	/* rest of init goes here */
+	
+	vx_info_init_cvirt(&new->cvirt);
+	vx_info_init_limit(&new->limit);
+	vx_info_init_sched(&new->sched);
+
+	new->vx_flags = VXF_STATE_SETUP|VXF_STATE_INIT;
+	new->vx_bcaps = CAP_INIT_EFF_SET;
+	new->vx_ccaps = 0;
+
+	vxdprintk("alloc_vx_info(%d) = %p\n", id, new);
+	return new;
+}
+
+void free_vx_info(struct vx_info *vxi)
+{
+	vxdprintk("free_vx_info(%p)\n", vxi);
+	if (vxi->vx_namespace)
+		put_namespace(vxi->vx_namespace);
+	if (vxi->vx_fs)
+		put_fs_struct(vxi->vx_fs);
+	kfree(vxi);
+}
+
+
+/*
+ *	struct vx_info search by id
+ *	assumes vxlist_lock is held
+ */
+
+static __inline__ struct vx_info *__find_vx_info(int id)
+{
+	struct vx_info *vxi;
+
+	list_for_each_entry(vxi, &vx_infos, vx_list)
+		if (vxi->vx_id == id)
+			return vxi;
+	return 0;
+}
+
+
+/*
+ *	struct vx_info ref stuff
+ */
+
+struct vx_info *find_vx_info(int id)
+{
+	struct vx_info *vxi;
+	
+	if (id < 0) {
+		vxi = current->vx_info;
+		get_vx_info(vxi);
+	} else {
+		spin_lock(&vxlist_lock);
+		if ((vxi = __find_vx_info(id)))
+			get_vx_info(vxi);
+		spin_unlock(&vxlist_lock);
+	}
+	return vxi;
+}
+
+/*
+ *	verify that id is a valid xid
+ */
+
+int vx_info_id_valid(int id)
+{
+	int valid;
+
+	spin_lock(&vxlist_lock);
+	valid = (__find_vx_info(id) != NULL);
+	spin_unlock(&vxlist_lock);
+	return valid;
+}
+
+
+/*
+ *	dynamic context id ...
+ */
+
+static __inline__ xid_t __vx_dynamic_id(void)
+{
+	static xid_t seq = MAX_S_CONTEXT;
+	xid_t barrier = seq;
+	
+	do {
+		if (++seq > MAX_S_CONTEXT)
+			seq = MIN_D_CONTEXT;
+		if (!__find_vx_info(seq))
+			return seq;
+	} while (barrier != seq);
+	return 0;
+}
+
+static struct vx_info * __foc_vx_info(int id, int *err)
+{
+	struct vx_info *new, *vxi = NULL;
+	
+	vxdprintk("foc_vx_info(%d)\n", id);
+	if (!(new = alloc_vx_info(id))) {
+		*err = -ENOMEM;
+		return NULL;
+	}
+
+	spin_lock(&vxlist_lock);
+
+	/* dynamic context requested */
+	if (id == VX_DYNAMIC_ID) {
+		id = __vx_dynamic_id();
+		if (!id) {
+			printk(KERN_ERR "no dynamic context available.\n");
+			goto out_unlock;
+		}
+		new->vx_id = id;
+	}
+	/* existing context requested */
+	else if ((vxi = __find_vx_info(id))) {
+		/* context in setup is not available */
+		if (vxi->vx_flags & VXF_STATE_SETUP) {
+			vxdprintk("foc_vx_info(%d) = %p (not available)\n", id, vxi);
+			vxi = NULL;
+			*err = -EBUSY;
+		} else {
+			vxdprintk("foc_vx_info(%d) = %p (found)\n", id, vxi);
+			get_vx_info(vxi);
+			*err = 0;
+		}
+		goto out_unlock;
+	}
+
+	/* new context requested */
+	vxdprintk("foc_vx_info(%d) = %p (new)\n", id, new);
+	atomic_set(&new->vx_refcount, 1);
+	list_add(&new->vx_list, &vx_infos);
+	vxi = new, new = NULL;
+	*err = 1;
+
+out_unlock:
+	spin_unlock(&vxlist_lock);
+	if (new)
+		free_vx_info(new);
+	return vxi;
+}
+
+
+struct vx_info *find_or_create_vx_info(int id)
+{
+	int err;
+
+	return __foc_vx_info(id, &err);
+}
+
+
+int vx_migrate_user(struct task_struct *p, struct vx_info *vxi)
+{
+	struct user_struct *new_user, *old_user;
+	
+	if (!p || !vxi)
+		BUG();
+	new_user = alloc_uid(vxi->vx_id, p->uid);
+	if (!new_user)
+		return -ENOMEM;
+
+	old_user = p->user;
+	if (new_user != old_user) {
+		atomic_inc(&new_user->processes);
+		atomic_dec(&old_user->processes);
+		p->user = new_user;
+	}
+	free_uid(old_user);
+	return 0;
+}
+
+void vx_mask_bcaps(struct task_struct *p)
+{
+	struct vx_info *vxi = p->vx_info;
+
+	p->cap_effective &= vxi->vx_bcaps;
+	p->cap_inheritable &= vxi->vx_bcaps;
+	p->cap_permitted &= vxi->vx_bcaps;
+}
+
+/*
+ *	migrate task to new context
+ *	gets vxi, puts old_vxi on change
+ */
+
+int vx_migrate_task(struct task_struct *p, struct vx_info *vxi)
+{
+	struct vx_info *old_vxi = task_get_vx_info(p);
+	int ret = 0;
+	
+	if (!p || !vxi)
+		BUG();
+
+	vxdprintk("vx_migrate_task(%p,%p[#%d.%d)\n", p, vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount));
+	if (old_vxi == vxi)
+		goto out;
+
+	if (!(ret = vx_migrate_user(p, vxi))) {
+		spin_lock(&p->alloc_lock);
+		if (old_vxi) {
+			old_vxi->cvirt.nr_threads--;
+			atomic_dec(&old_vxi->limit.res[RLIMIT_NPROC]);
+		}		
+		vxi->cvirt.nr_threads++;
+		atomic_inc(&vxi->limit.res[RLIMIT_NPROC]);
+		p->vx_info = get_vx_info(vxi);
+		p->xid = vxi->vx_id;
+		vx_mask_bcaps(p);
+		if (old_vxi)
+			put_vx_info(old_vxi);
+		spin_unlock(&p->alloc_lock);
+	}
+out:
+	put_vx_info(old_vxi);
+	return ret;
+}
+
+int vx_set_init(struct vx_info *vxi, struct task_struct *p)
+{
+	if (!vxi)
+		return -EINVAL;
+        if (vxi->vx_initpid)
+                return -EPERM;
+
+        vxi->vx_initpid = p->tgid;
+	return 0;
+}
+
+
+
+/* taks xid and vx_info functions */
+
+#include <asm/uaccess.h>
+
+
+int vc_task_xid(uint32_t id, void *data)
+{
+        xid_t xid;
+
+        if (id) {
+                struct task_struct *tsk;
+
+                if (!vx_check(0, VX_ADMIN|VX_WATCH))
+                        return -EPERM;
+
+                read_lock(&tasklist_lock);
+                tsk = find_task_by_pid(id);
+                xid = (tsk) ? tsk->xid : -ESRCH;
+                read_unlock(&tasklist_lock);
+        }
+        else
+                xid = current->xid;
+        return xid;
+}
+
+
+int vc_vx_info(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_vx_info_v0 vc_data;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	vc_data.xid = vxi->vx_id;
+	vc_data.initpid = vxi->vx_initpid;
+	put_vx_info(vxi);
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+	return 0;
+}
+
+
+/* context functions */
+
+int vc_create_context(uint32_t xid, void *data)
+{
+        // int ret = -ENOMEM;
+	struct vx_info *new_vxi;
+	int ret;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if ((xid >= MIN_D_CONTEXT) && (xid != VX_DYNAMIC_ID))
+		return -EINVAL;
+
+	if (xid < 1)
+		return -EINVAL;
+
+	new_vxi = __foc_vx_info(xid, &ret);
+	if (!new_vxi)
+		return ret;
+	if (!(new_vxi->vx_flags & VXF_STATE_SETUP)) {
+		ret = -EEXIST;
+		goto out_put;
+	}
+
+	ret = new_vxi->vx_id;
+	vx_migrate_task(current, new_vxi);
+out_put:
+	put_vx_info(new_vxi);
+	return ret;
+}
+
+
+int vc_migrate_context(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+	vx_migrate_task(current, vxi);
+	put_vx_info(vxi);
+	return 0;
+}
+
+
+int vc_get_flags(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_flags_v0 vc_data;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	vc_data.flagword = vxi->vx_flags;
+
+	// vc_data.mask = ~0UL;
+	/* special STATE flag handling */
+	vc_data.mask = vx_mask_flags(~0UL, vxi->vx_flags, VXF_ONE_TIME);
+
+	put_vx_info(vxi);
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+	return 0;
+}
+
+int vc_set_flags(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_flags_v0 vc_data;
+	uint64_t mask, trigger;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	/* special STATE flag handling */
+	mask = vx_mask_flags(vc_data.mask, vxi->vx_flags, VXF_ONE_TIME);
+	trigger = (mask & vxi->vx_flags) ^ (mask & vc_data.flagword);
+	if (trigger & VXF_STATE_SETUP)
+		vx_mask_bcaps(current);
+	if (trigger & VXF_STATE_INIT)
+		if (vxi == current->vx_info)
+			vx_set_init(vxi, current);
+
+	vxi->vx_flags = vx_mask_flags(vxi->vx_flags,
+		vc_data.flagword, vc_data.mask);
+	put_vx_info(vxi);
+	return 0;
+}
+
+int vc_get_ccaps(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_caps_v0 vc_data;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	vc_data.bcaps = vxi->vx_bcaps;
+	vc_data.ccaps = vxi->vx_ccaps;
+	vc_data.cmask = ~0UL;
+	put_vx_info(vxi);
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+	return 0;
+}
+
+int vc_set_ccaps(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_caps_v0 vc_data;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	vxi->vx_bcaps &= vc_data.bcaps;
+	vxi->vx_ccaps = vx_mask_flags(vxi->vx_ccaps,
+		vc_data.ccaps, vc_data.cmask);
+	put_vx_info(vxi);
+	return 0;
+}
+
+#include <linux/module.h>
+
+EXPORT_SYMBOL_GPL(free_vx_info);
+EXPORT_SYMBOL_GPL(vxlist_lock);
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/cvirt.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/cvirt.c
--- linux-2.6.5/kernel/vserver/cvirt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/cvirt.c	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ *  linux/kernel/vserver/cvirt.c
+ *
+ *  Virtual Server: Context Virtualization
+ *
+ *  Copyright (C) 2004  Herbert Ptzl
+ *
+ *  V0.01  broken out from limit.c
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/vserver/cvirt.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/switch.h>
+#include <linux/vinline.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+void vx_vsi_uptime(struct timespec *uptime)
+{
+	struct vx_info *vxi = current->vx_info;
+
+	set_normalized_timespec(uptime,
+		uptime->tv_sec - vxi->cvirt.bias_tp.tv_sec,
+		uptime->tv_nsec - vxi->cvirt.bias_tp.tv_nsec);
+	return;
+}
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/inode.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/inode.c
--- linux-2.6.5/kernel/vserver/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/inode.c	2004-04-05 00:55:16.000000000 +0200
@@ -0,0 +1,245 @@
+/*
+ *  linux/kernel/vserver/inode.c
+ *
+ *  Virtual Server: File System Support
+ *
+ *  Copyright (C) 2004  Herbert Ptzl
+ *
+ *  V0.01  separated from vcontext V0.05
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/vinline.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/namei.h>
+#include <linux/vserver/inode.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+static int __vc_get_iattr(struct inode *in, uint32_t *xid, uint32_t *flags, uint32_t *mask)
+{
+	if (!in || !in->i_sb)
+		return -ESRCH;
+
+	*flags = IATTR_XID
+		| (IS_BARRIER(in) ? IATTR_BARRIER : 0)
+		| (IS_IUNLINK(in) ? IATTR_IUNLINK : 0)
+		| (IS_IMMUTABLE(in) ? IATTR_IMMUTABLE : 0);	
+	*mask = IATTR_BARRIER | IATTR_IUNLINK | IATTR_IMMUTABLE;
+
+	if (in->i_sb->s_flags & MS_TAGXID) {
+		*xid = in->i_xid;
+		*mask |= IATTR_XID;
+	}
+
+	if (in->i_sb->s_magic == PROC_SUPER_MAGIC) {
+		struct proc_dir_entry *entry = PROC_I(in)->pde;
+		
+		// check for specific inodes ?
+		if (entry)
+			*mask |= IATTR_FLAGS;
+		if (entry)
+			*flags |= (entry->vx_flags & IATTR_FLAGS);	
+		else
+			*flags |= (PROC_I(in)->vx_flags & IATTR_FLAGS);
+	}
+	return 0;
+}
+
+int vc_get_iattr_v0(uint32_t dev, void *data)
+{
+	struct super_block *sb;
+	struct inode *in;
+	struct vcmd_ctx_iattr_v0 vc_data;
+	int ret;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	ret = -ESRCH;
+	sb = user_get_super(new_decode_dev(dev));
+	if (!sb)
+		goto out;
+	in = iget(sb, vc_data.ino);
+	if (!in)
+		goto out_drop_sb;
+	
+	ret = __vc_get_iattr(in, &vc_data.xid, &vc_data.flags, &vc_data.mask);
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		ret = -EFAULT;
+	iput(in);
+out_drop_sb:
+        drop_super(sb);
+out:
+	return ret;
+}
+
+int vc_get_iattr(uint32_t id, void *data)
+{
+	struct nameidata nd;
+	struct vcmd_ctx_iattr_v1 vc_data;
+	int ret;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	ret = user_path_walk_link(vc_data.name, &nd);
+	if (!ret) {
+		ret = __vc_get_iattr(nd.dentry->d_inode,
+			&vc_data.xid, &vc_data.flags, &vc_data.mask);
+		path_release(&nd);
+	}
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		ret = -EFAULT;
+	return ret;
+}
+
+static int __vc_set_iattr(struct inode *in, uint32_t *xid, uint32_t *flags, uint32_t *mask)
+{
+	int is_proc = 0;
+
+	if (!in || !in->i_sb)
+		return -ESRCH;
+
+	is_proc = (in->i_sb->s_magic == PROC_SUPER_MAGIC);
+	if ((*mask & IATTR_FLAGS) && !is_proc)
+		return -EINVAL;
+	if ((*mask & IATTR_XID) && !(in->i_sb->s_flags & MS_TAGXID))
+		return -EINVAL;
+
+	down(&in->i_sem);
+	if (*mask & IATTR_XID)
+		in->i_xid = *xid;
+
+	if (*mask & IATTR_FLAGS) {
+		struct proc_dir_entry *entry = PROC_I(in)->pde;
+		unsigned int iflags = PROC_I(in)->vx_flags;
+
+		iflags = (iflags & ~(*mask & IATTR_FLAGS))
+			| (*flags & IATTR_FLAGS);
+		PROC_I(in)->vx_flags = iflags;
+		if (entry)
+			entry->vx_flags = iflags;
+	}
+	
+	if (*mask & IATTR_BARRIER)
+		in->i_flags = (in->i_flags & ~S_BARRIER)
+			| ((*flags & IATTR_BARRIER) ? S_BARRIER : 0);
+	if (*mask & IATTR_IUNLINK)
+		in->i_flags = (in->i_flags & ~S_IUNLINK)
+			| ((*flags & IATTR_IUNLINK) ? S_IUNLINK : 0);
+	if (*mask & IATTR_IMMUTABLE)
+		in->i_flags = (in->i_flags & ~S_IMMUTABLE)
+			| ((*flags & IATTR_IMMUTABLE) ? S_IMMUTABLE : 0);
+	mark_inode_dirty(in);
+	up(&in->i_sem);
+	return 0;
+}
+
+int vc_set_iattr_v0(uint32_t dev, void *data)
+{
+	struct super_block *sb;
+	struct inode *in;
+	struct vcmd_ctx_iattr_v0 vc_data;
+	int ret;
+
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_LINUX_IMMUTABLE))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	ret = -ESRCH;
+	sb = user_get_super(new_decode_dev(dev));
+	if (!sb)
+		goto out;
+
+	in = iget(sb, vc_data.ino);
+	if (!in)
+		goto out_drop_sb;
+
+	ret = __vc_set_iattr(in, &vc_data.xid, &vc_data.flags, &vc_data.mask);
+	iput(in);
+out_drop_sb:
+        drop_super(sb);
+out:
+	return ret;
+}
+
+int vc_set_iattr(uint32_t id, void *data)
+{
+	struct nameidata nd;
+	struct vcmd_ctx_iattr_v1 vc_data;
+	int ret;
+
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_LINUX_IMMUTABLE))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	ret = user_path_walk_link(vc_data.name, &nd);
+	if (!ret) {
+		ret = __vc_set_iattr(nd.dentry->d_inode,
+			&vc_data.xid, &vc_data.flags, &vc_data.mask);
+		path_release(&nd);
+	}
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		ret = -EFAULT;
+	return ret;
+}
+
+
+#include <linux/proc_fs.h>
+
+int vx_proc_ioctl(struct inode * inode, struct file * filp,
+	unsigned int cmd, unsigned long arg)
+{
+	struct proc_dir_entry *entry;
+	int error = 0;
+	int flags;
+
+	if (inode->i_ino < PROC_DYNAMIC_FIRST ||
+		inode->i_ino >= PROC_DYNAMIC_FIRST+PROC_NDYNAMIC)
+		return -ENOTTY;
+
+	entry = PROC_I(inode)->pde;
+
+	switch(cmd) {
+	case FIOC_GETXFLG: {
+		/* fixme: if stealth, return -ENOTTY */
+		error = -EPERM;
+		flags = entry->vx_flags;
+		if (capable(CAP_CONTEXT))
+			error = put_user(flags, (int *) arg);
+		break;
+	}
+	case FIOC_SETXFLG: {
+		/* fixme: if stealth, return -ENOTTY */
+		error = -EPERM;
+		if (!capable(CAP_CONTEXT))
+			break;
+		error = -EROFS;
+		if (IS_RDONLY(inode))
+			break;
+		error = -EFAULT;
+		if (get_user(flags, (int *) arg))
+			break;
+		error = 0;
+		entry->vx_flags = flags;
+		break;
+	}
+	default:
+		return -ENOTTY;
+	}
+	return error;
+}
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/legacy.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/legacy.c
--- linux-2.6.5/kernel/vserver/legacy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/legacy.c	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ *  linux/kernel/vserver/legacy.c
+ *
+ *  Virtual Server: Legacy Funtions
+ *
+ *  Copyright (C) 2001-2003  Jacques Gelinas
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  broken out from vcontext.c V0.05
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/vserver/legacy.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/namespace.h>
+#include <linux/vinline.h>
+#include <linux/sched.h>
+#include <linux/namespace.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+
+static int vx_set_initpid(struct vx_info *vxi, int pid)
+{
+	if (vxi->vx_initpid)
+		return -EPERM;
+
+	vxi->vx_initpid = pid;
+	return 0;
+}
+
+int vc_new_s_context(uint32_t ctx, void *data)
+{
+	int ret = -ENOMEM;
+	struct vcmd_new_s_context_v1 vc_data;
+	struct vx_info *new_vxi;
+
+	if (copy_from_user(&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	/* legacy hack, will be removed soon */
+	if (ctx == -2) {
+		/* assign flags and initpid */
+		if (!current->vx_info)
+			return -EINVAL;
+		ret = 0;
+		if (vc_data.flags & VX_INFO_INIT)
+			ret = vx_set_initpid(current->vx_info, current->tgid);
+		if (ret == 0) {
+			/* We keep the same vx_id, but lower the capabilities */
+			current->vx_info->vx_bcaps &= (~vc_data.remove_cap);
+			// current->cap_bset &= (~vc_data.remove_cap);
+			ret = vx_current_xid();
+			current->vx_info->vx_flags |= vc_data.flags;
+		}
+		return ret;
+	}
+	
+	if (!vx_check(0, VX_ADMIN) ||
+		!capable(CAP_SYS_ADMIN) ||
+		(current->vx_info &&
+		(current->vx_info->vx_flags & VX_INFO_LOCK)))
+		return -EPERM;
+
+	if (((ctx > MAX_S_CONTEXT) && (ctx != VX_DYNAMIC_ID)) ||
+		(ctx == 0))
+		return -EINVAL;
+		
+	if ((ctx == VX_DYNAMIC_ID) || (ctx < MIN_D_CONTEXT))
+		new_vxi = find_or_create_vx_info(ctx);
+	else
+		new_vxi = find_vx_info(ctx);
+		
+	if (!new_vxi)
+		return -EINVAL;
+	new_vxi->vx_flags &= ~(VXF_STATE_SETUP|VXF_STATE_INIT);
+	
+	ret = vx_migrate_task(current, new_vxi);
+	if (ret == 0) {
+		current->vx_info->vx_bcaps &= (~vc_data.remove_cap);
+		// current->cap_bset &= (~vc_data.remove_cap);
+		new_vxi->vx_flags |= vc_data.flags;
+		if (vc_data.flags & VX_INFO_INIT)
+			vx_set_initpid(new_vxi, current->tgid);
+		if (vc_data.flags & VX_INFO_NAMESPACE)
+			vx_set_namespace(new_vxi,
+				current->namespace, current->fs);
+		if (vc_data.flags & VX_INFO_NPROC)
+			new_vxi->limit.rlim[RLIMIT_NPROC] =
+				current->rlim[RLIMIT_NPROC].rlim_max;
+		ret = new_vxi->vx_id;
+	}
+	put_vx_info(new_vxi);
+	return ret;
+}
+
+
+
+/*  set ipv4 root (syscall) */
+
+int vc_set_ipv4root(uint32_t nbip, void *data)
+{
+	int i, err = -EPERM;
+	struct vcmd_set_ipv4root_v3 vc_data;
+	struct ip_info *new_ipi, *ipi = current->ip_info;
+
+	if (nbip < 0 || nbip > NB_IPV4ROOT)
+		return -EINVAL;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	if (!ipi || ipi->ipv4[0] == 0 || capable(CAP_NET_ADMIN))
+		// We are allowed to change everything
+		err = 0;
+	else if (ipi) {
+		int found = 0;
+		
+		// We are allowed to select a subset of the currently
+		// installed IP numbers. No new one allowed
+		// We can't change the broadcast address though
+		for (i=0; i<nbip; i++) {
+			int j;
+			__u32 ipip = vc_data.ip_mask_pair[i].ip;
+			for (j=0; j<ipi->nbipv4; j++) {
+				if (ipip == ipi->ipv4[j]) {
+					found++;
+					break;
+				}
+			}
+		}
+		if ((found == nbip) &&
+			(vc_data.broadcast == ipi->v4_bcast))
+			err = 0;
+	}
+	if (err)
+		return err;
+
+	new_ipi = create_ip_info();
+	if (!new_ipi)
+		return -EINVAL;
+
+	new_ipi->nbipv4 = nbip;
+	for (i=0; i<nbip; i++) {
+		new_ipi->ipv4[i] = vc_data.ip_mask_pair[i].ip;
+		new_ipi->mask[i] = vc_data.ip_mask_pair[i].mask;
+	}
+	new_ipi->v4_bcast = vc_data.broadcast;
+	current->ip_info = new_ipi;
+	put_ip_info(ipi);
+	return 0;
+}
+
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/limit.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/limit.c
--- linux-2.6.5/kernel/vserver/limit.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/limit.c	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,149 @@
+/*
+ *  linux/kernel/vserver/limit.c
+ *
+ *  Virtual Server: Context Limits
+ *
+ *  Copyright (C) 2004  Herbert Ptzl
+ *
+ *  V0.01  broken out from vcontext V0.05
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/vserver/limit.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/switch.h>
+#include <linux/vinline.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+static int is_valid_rlimit(int id)
+{
+	int valid = 0;
+
+	switch (id) {
+		case RLIMIT_NPROC:
+		case RLIMIT_AS:
+		case RLIMIT_RSS:
+		case RLIMIT_MEMLOCK:
+		case RLIMIT_NOFILE:
+			valid = 1;
+			break;
+	}
+	return valid;
+}
+
+static inline uint64_t vc_get_rlim(struct vx_info *vxi, int id)
+{
+	unsigned long limit;
+
+	limit = vxi->limit.rlim[id];
+	if (limit == RLIM_INFINITY)
+		return CRLIM_INFINITY;
+	return limit;	
+}
+
+int vc_get_rlimit(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_rlimit_v0 vc_data;
+
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	if (!is_valid_rlimit(vc_data.id))
+		return -ENOTSUPP;
+		
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	vc_data.maximum = vc_get_rlim(vxi, vc_data.id);
+	vc_data.minimum = CRLIM_UNSET;
+	vc_data.softlimit = CRLIM_UNSET;
+	put_vx_info(vxi);
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+	return 0;
+}
+
+int vc_set_rlimit(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_rlimit_v0 vc_data;
+
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	if (!is_valid_rlimit(vc_data.id))
+		return -ENOTSUPP;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	if (vc_data.maximum != CRLIM_KEEP)
+		vxi->limit.rlim[vc_data.id] = vc_data.maximum;
+	printk("setting [%d] = %d\n", vc_data.id, (int)vc_data.maximum);
+	put_vx_info(vxi);
+
+	return 0;
+}
+
+int vc_get_rlimit_mask(uint32_t id, void *data)
+{
+	static struct vcmd_ctx_rlimit_mask_v0 mask = {
+			/* minimum */
+		0
+		,	/* softlimit */
+		0
+		,	/* maximum */
+		(1 << RLIMIT_NPROC) |
+		(1 << RLIMIT_NOFILE) |
+		(1 << RLIMIT_MEMLOCK) |
+		(1 << RLIMIT_AS) |
+		(1 << RLIMIT_RSS)
+		};
+
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+	if (copy_to_user(data, &mask, sizeof(mask)))
+                return -EFAULT;
+	return 0;
+}
+
+
+void vx_vsi_meminfo(struct sysinfo *val)
+{
+	struct vx_info *vxi = current->vx_info;
+	unsigned long v;
+
+	v = vxi->limit.rlim[RLIMIT_RSS];
+	if (v != RLIM_INFINITY)
+		val->totalram = min(val->totalram, v);
+	v = atomic_read(&vxi->limit.res[RLIMIT_RSS]);
+	val->freeram = (v < val->totalram) ? val->totalram - v : 0;
+	val->bufferram = 0;
+        val->totalhigh = 0;
+        val->freehigh = 0;
+	return;
+}
+
+void vx_vsi_swapinfo(struct sysinfo *val)
+{
+	struct vx_info *vxi = current->vx_info;
+	unsigned long w,v;
+
+	v = vxi->limit.rlim[RLIMIT_RSS];
+	w = vxi->limit.rlim[RLIMIT_AS];
+	if (w != RLIM_INFINITY)
+		val->totalswap = min(val->totalswap, w -
+		((v != RLIM_INFINITY) ? v : 0));
+	w = atomic_read(&vxi->limit.res[RLIMIT_AS]);
+	val->freeswap = (w < val->totalswap) ? val->totalswap - w : 0;
+	return;
+}
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/namespace.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/namespace.c
--- linux-2.6.5/kernel/vserver/namespace.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/namespace.c	2004-04-05 00:55:18.000000000 +0200
@@ -0,0 +1,164 @@
+/*
+ *  linux/kernel/vserver/namespace.c
+ *
+ *  Virtual Server: Context Namespace Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  broken out from context.c 0.07
+ *  V0.02  added task locking for namespace
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/utsname.h>
+#include <linux/vserver/namespace.h>
+#include <linux/vinline.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+/* virtual host info names */
+
+static char * vx_vhi_name(struct vx_info *vxi, int id)
+{
+	switch (id) {
+		case VHIN_CONTEXT:
+			return vxi->vx_name;
+		case VHIN_SYSNAME:
+			return vxi->cvirt.utsname.sysname;
+		case VHIN_NODENAME:
+			return vxi->cvirt.utsname.nodename;
+		case VHIN_RELEASE:
+			return vxi->cvirt.utsname.release;
+		case VHIN_VERSION:
+			return vxi->cvirt.utsname.version;
+		case VHIN_MACHINE:
+			return vxi->cvirt.utsname.machine;
+		case VHIN_DOMAINNAME:
+			return vxi->cvirt.utsname.domainname;
+		default:
+			return NULL;
+	}
+	return NULL;
+}
+
+int vc_set_vhi_name(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_vx_vhi_name_v0 vc_data;
+	char *name;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+	
+	name = vx_vhi_name(vxi, vc_data.field);
+	if (name)
+		memcpy(name, vc_data.name, 65);
+	put_vx_info(vxi);
+	return (name ? 0 : -EFAULT);
+}
+
+int vc_get_vhi_name(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_vx_vhi_name_v0 vc_data;
+	char *name;
+
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	name = vx_vhi_name(vxi, vc_data.field);
+	if (!name)
+		goto out_put;
+			
+	memcpy(vc_data.name, name, 65);
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+out_put:
+	put_vx_info(vxi);
+	return (name ? 0 : -EFAULT);
+}
+
+/* namespace functions */
+
+#include <linux/namespace.h>
+
+int vx_set_namespace(struct vx_info *vxi, struct namespace *ns, struct fs_struct *fs)
+{
+	if (vxi->vx_namespace)
+		return -EPERM;
+
+	get_namespace(ns);
+	vxi->vx_namespace = ns;
+	vxi->vx_fs = copy_fs_struct(fs);
+	return 0;
+}
+
+int vc_enter_namespace(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct fs_struct *old_fs;
+	struct namespace *old_ns;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	if (!vxi->vx_namespace) {
+		put_vx_info(vxi);
+		return -EINVAL;	
+	}
+
+	task_lock(current);
+	old_ns = current->namespace;
+	old_fs = current->fs;
+	get_namespace(vxi->vx_namespace);
+	current->namespace = vxi->vx_namespace;	
+	current->fs = copy_fs_struct(vxi->vx_fs);
+	task_unlock(current);
+
+	put_namespace(old_ns);
+	put_fs_struct(old_fs);
+	put_vx_info(vxi);
+	return 0;
+}
+
+int vc_cleanup_namespace(uint32_t id, void *data)
+{
+	spin_lock(&dcache_lock);
+	umount_unused(current->namespace->root, current->fs);
+	spin_unlock(&dcache_lock);
+	return 0;
+}
+
+int vc_set_namespace(uint32_t id, void *data)
+{
+	int ret;
+
+	if (vx_check(0, VX_ADMIN|VX_WATCH))
+		return -ENOSYS;
+
+	task_lock(current);
+	ret = vx_set_namespace(current->vx_info,
+		current->namespace, current->fs);	
+	task_unlock(current);
+	return ret;
+}
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/network.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/network.c
--- linux-2.6.5/kernel/vserver/network.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/network.c	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,134 @@
+/*
+ *  linux/kernel/vserver/network.c
+ *
+ *  Virtual Server: Network Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  broken out from vcontext V0.05
+ *  V0.05  rlimit basic implementation
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <linux/vserver/network.h>
+#include <linux/vinline.h>
+
+#include <asm/errno.h>
+
+
+LIST_HEAD(ip_infos);
+
+spinlock_t iplist_lock
+	__cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ *	struct ip_info allocation and deallocation
+ */
+
+static struct ip_info *alloc_ip_info(void)
+{
+	struct ip_info *new = NULL;
+	
+	vxdprintk("alloc_ip_info()\n");
+	/* would this benefit from a slab cache? */
+	new = kmalloc(sizeof(struct ip_info), GFP_KERNEL);
+	if (!new)
+		return 0;
+	
+	memset (new, 0, sizeof(struct ip_info));
+	/* rest of init goes here */
+	
+	vxdprintk("alloc_ip_info() = %p\n", new);
+	return new;
+}
+
+// extern int ip_proc_destroy(struct ip_info *);
+
+void free_ip_info(struct ip_info *ipi)
+{
+	vxdprintk("free_ip_info(%p)\n", ipi);
+//	ip_proc_destroy(ipi);
+	kfree(ipi);
+}
+
+struct ip_info *create_ip_info(void)
+{
+	struct ip_info *new;
+	static int gnid = 1;
+	
+	vxdprintk("create_ip_info()\n");
+	if (!(new = alloc_ip_info()))
+		return 0;
+
+	spin_lock(&iplist_lock);
+
+	/* new ip info */
+	atomic_set(&new->ip_refcount, 1);
+	new->ip_id = gnid++;
+	list_add(&new->ip_list, &ip_infos);
+//	ip_proc_create(new);
+
+	spin_unlock(&iplist_lock);
+	return new;
+}
+
+
+/*
+ *	struct ip_info search by id
+ *	assumes iplist_lock is held
+ */
+
+static __inline__ struct ip_info *__find_ip_info(int id)
+{
+	struct ip_info *ipi;
+
+	list_for_each_entry(ipi, &ip_infos, ip_list)
+		if (ipi->ip_id == id)
+			return ipi;
+	return 0;
+}
+
+
+/*
+ *	struct ip_info ref stuff
+ */
+
+struct ip_info *find_ip_info(int id)
+{
+	struct ip_info *ipi;
+	
+	if (id < 0) {
+		ipi = current->ip_info;
+		get_ip_info(ipi);
+	} else {
+		spin_lock(&iplist_lock);
+		if ((ipi = __find_ip_info(id)))
+			get_ip_info(ipi);
+		spin_unlock(&iplist_lock);
+	}
+	return ipi;
+}
+
+/*
+ *      verify that id is a valid nid
+ */
+
+int ip_info_id_valid(int id)
+{
+	int valid;
+	
+	spin_lock(&iplist_lock);
+	valid = (__find_ip_info(id) != NULL);
+	spin_unlock(&iplist_lock);
+	return valid;
+}
+
+
+#include <linux/module.h>
+
+EXPORT_SYMBOL_GPL(free_ip_info);
+EXPORT_SYMBOL_GPL(iplist_lock);
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/sched.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/sched.c
--- linux-2.6.5/kernel/vserver/sched.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/sched.c	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,200 @@
+/*
+ *  linux/kernel/vserver/sched.c
+ *
+ *  Virtual Server: Scheduler Support
+ *
+ *  Copyright (C) 2004  Herbert Ptzl
+ *
+ *  V0.01  adapted Sam Vilains version to 2.6.3
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/vinline.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/sched.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+/*
+ * recalculate the context's scheduling tokens
+ *
+ * ret > 0 : number of tokens available
+ * ret = 0 : context is paused
+ * ret < 0 : number of jiffies until new tokens arrive
+ *
+ */
+int vx_tokens_recalc(struct vx_info *vxi)
+{
+	long delta, tokens = 0;
+
+	if (__vx_flags(vxi->vx_flags, VXF_SCHED_PAUSE, 0))
+		/* we are paused */
+		return 0;
+
+	delta = jiffies - vxi->sched.jiffies;
+
+	if (delta >= vxi->sched.interval) {
+		/* lockdown scheduler info */
+		spin_lock(&vxi->sched.tokens_lock);
+
+		/* calc integral token part */
+		delta = jiffies - vxi->sched.jiffies;
+		tokens = delta / vxi->sched.interval;
+		delta = tokens * vxi->sched.interval;
+		tokens *= vxi->sched.fill_rate;
+
+		atomic_add(tokens, &vxi->sched.tokens);
+		vxi->sched.jiffies += delta;
+		tokens = atomic_read(&vxi->sched.tokens);
+	
+		if (tokens > vxi->sched.tokens_max) {
+			tokens = vxi->sched.tokens_max;
+			atomic_set(&vxi->sched.tokens, tokens);
+		}
+		spin_unlock(&vxi->sched.tokens_lock);
+	} else {
+		/* no new tokens */
+		if ((tokens = vx_tokens_avail(vxi)) < vxi->sched.tokens_min) {
+			/* enough tokens will be available in */
+			if (vxi->sched.tokens_min == 0)
+				return delta - vxi->sched.interval;
+			return delta - vxi->sched.interval *
+				vxi->sched.tokens_min / vxi->sched.fill_rate;
+		}
+	}
+	/* we have some tokens left */
+	return tokens;
+}
+
+/*
+ * effective_prio - return the priority that is based on the static
+ * priority but is modified by bonuses/penalties.
+ *
+ * We scale the actual sleep average [0 .... MAX_SLEEP_AVG]
+ * into a -4 ... 0 ... +4 bonus/penalty range.
+ *
+ * Additionally, we scale another amount based on the number of
+ * CPU tokens currently held by the context, if the process is
+ * part of a context (and the appropriate SCHED flag is set).
+ * This ranges from -5 ... 0 ... +15, quadratically.
+ *
+ * So, the total bonus is -9 .. 0 .. +19
+ * We use ~50% of the full 0...39 priority range so that:
+ *
+ * 1) nice +19 interactive tasks do not preempt nice 0 CPU hogs.
+ * 2) nice -20 CPU hogs do not get preempted by nice 0 tasks.
+ *    unless that context is far exceeding its CPU allocation.
+ *
+ * Both properties are important to certain workloads.
+ */
+int effective_vavavoom(task_t *p, int max_prio)
+{
+	struct vx_info *vxi = p->vx_info;
+	int vavavoom, max;
+
+	/* lots of tokens = lots of vavavoom
+	 *      no tokens = no vavavoom      */
+	if ((vavavoom = atomic_read(&vxi->sched.tokens)) >= 0) {
+		max = vxi->sched.tokens_max;
+		vavavoom = max - vavavoom;
+		max = max * max;
+		vavavoom = max_prio * VAVAVOOM_RATIO / 100
+			* (vavavoom*vavavoom - (max >> 2)) / max;
+		/*  alternative, geometric mapping
+		vavavoom = -( MAX_USER_PRIO*VAVAVOOM_RATIO/100 * vavavoom
+			/ vxi->sched.tokens_max -
+			MAX_USER_PRIO*VAVAVOOM_RATIO/100/2); */
+	} else
+		vavavoom = 0;
+	/* vavavoom = ( MAX_USER_PRIO*VAVAVOOM_RATIO/100*tokens_left(p) -
+		MAX_USER_PRIO*VAVAVOOM_RATIO/100/2); */
+
+	return vavavoom;
+}
+
+
+int vc_set_sched_v1(uint32_t ctx, void *data)
+{
+	struct vcmd_set_sched_v1 vc_data;
+	struct vx_info *s;
+
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	s = find_vx_info(ctx);
+	if (!s)
+		return -EINVAL;
+
+	spin_lock(&s->sched.tokens_lock);
+
+	if (vc_data.fill_rate > -1)
+		s->sched.fill_rate = vc_data.fill_rate;
+	if (vc_data.period > -1)
+		s->sched.interval = vc_data.period;
+	if (vc_data.fill_level > -1)
+		atomic_set(&s->sched.tokens, vc_data.fill_level);
+	if (vc_data.bucket_size > -1)
+		s->sched.tokens_max = vc_data.bucket_size;
+
+	/* Sanity check the resultant values */
+	if (s->sched.fill_rate == 0)
+		s->sched.fill_rate = 1;
+	if (s->sched.interval == 0)
+		s->sched.interval = HZ;
+	if (s->sched.tokens_max == 0)
+		s->sched.tokens_max = 1;
+	if (atomic_read(&s->sched.tokens) > s->sched.tokens_max)
+		atomic_set(&s->sched.tokens, s->sched.tokens_max);
+
+	spin_unlock(&s->sched.tokens_lock);
+	put_vx_info(s);
+
+	return 0;
+}
+
+int vc_set_sched(uint32_t xid, void *data)
+{
+	struct vcmd_set_sched_v2 vc_data;
+	struct vx_info *vxi;
+
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	vxi = find_vx_info(xid);
+	if (!vxi)
+		return -EINVAL;
+
+	spin_lock(&vxi->sched.tokens_lock);
+
+	if (vc_data.interval != SCHED_KEEP)
+		vxi->sched.interval = vc_data.interval;
+	if (vc_data.fill_rate != SCHED_KEEP)
+		vxi->sched.fill_rate = vc_data.fill_rate;
+	if (vc_data.tokens_min != SCHED_KEEP)
+		vxi->sched.tokens_min = vc_data.tokens_min;
+	if (vc_data.tokens_max != SCHED_KEEP)
+		vxi->sched.tokens_max = vc_data.tokens_max;
+	if (vc_data.tokens != SCHED_KEEP)
+		atomic_set(&vxi->sched.tokens, vc_data.tokens);
+
+	/* Sanity check the resultant values */
+	if (vxi->sched.fill_rate <= 0)
+		vxi->sched.fill_rate = 1;
+	if (vxi->sched.interval <= 0)
+		vxi->sched.interval = HZ;
+	if (vxi->sched.tokens_max == 0)
+		vxi->sched.tokens_max = 1;
+	if (atomic_read(&vxi->sched.tokens) > vxi->sched.tokens_max)
+		atomic_set(&vxi->sched.tokens, vxi->sched.tokens_max);
+	if (vxi->sched.tokens_min > vxi->sched.tokens_max)
+		vxi->sched.tokens_min = vxi->sched.tokens_max;
+
+	spin_unlock(&vxi->sched.tokens_lock);
+	put_vx_info(vxi);
+	return 0;
+}
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/signal.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/signal.c
--- linux-2.6.5/kernel/vserver/signal.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/signal.c	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,85 @@
+/*
+ *  linux/kernel/vserver/signal.c
+ *
+ *  Virtual Server: Signal Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  broken out from vcontext V0.05
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/sched.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+#include <linux/vinline.h>
+#include <linux/vserver/signal.h>
+
+
+int vc_ctx_kill(uint32_t id, void *data)
+{
+	int retval, count=0;
+	struct vcmd_ctx_kill_v0 vc_data;
+	struct siginfo info;
+	struct task_struct *p;
+	struct vx_info *vxi;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	info.si_signo = vc_data.sig;
+	info.si_errno = 0;
+	info.si_code = SI_USER;
+	info.si_pid = current->pid;
+	info.si_uid = current->uid;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	retval = -ESRCH;
+	read_lock(&tasklist_lock);
+	switch (vc_data.pid) {
+	case -1:
+	case  0:
+		for_each_process(p) {
+			int err = 0;
+
+			if (vx_task_xid(p) != id || p->pid <= 1 ||
+				(vc_data.pid && vxi->vx_initpid == p->pid) ||
+				!thread_group_leader(p))
+				continue;
+
+			err = send_sig_info(vc_data.sig, &info, p);
+			++count;
+			if (err != -EPERM)
+				retval = err;
+		}
+		break;
+		
+	default:
+	p = find_task_by_pid(vc_data.pid);
+		if (p) {
+			if (!thread_group_leader(p)) {
+				struct task_struct *tg;
+			
+				tg = find_task_by_pid(p->tgid);
+				if (tg)
+					p = tg;
+			}
+			if ((id == -1) || (vx_task_xid(p) == id))
+				retval = send_sig_info(vc_data.sig, &info, p);
+		}
+		break;
+	}
+	read_unlock(&tasklist_lock);
+	put_vx_info(vxi);
+	return retval;
+}
+
+
diff -NurpP --minimal linux-2.6.5/kernel/vserver/switch.c linux-2.6.5-vs1.9.0pre2/kernel/vserver/switch.c
--- linux-2.6.5/kernel/vserver/switch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/kernel/vserver/switch.c	2004-04-05 00:55:13.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ *  linux/kernel/vserver/switch.c
+ *
+ *  Virtual Server: Syscall Switch
+ *
+ *  Copyright (C) 2003-2004  Herbert Ptzl
+ *
+ *  V0.01  syscall switch
+ *  V0.02  added signal to context
+ *  V0.03  added rlimit functions
+ *  V0.04  added iattr, task/xid functions
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/errno.h>
+
+#include <linux/vserver/switch.h>
+#include <linux/vinline.h>
+
+
+static inline int
+vc_get_version(uint32_t id)
+{
+	return VCI_VERSION;
+}
+
+
+#include <linux/vserver/legacy.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/network.h>
+#include <linux/vserver/namespace.h>
+#include <linux/vserver/sched.h>
+#include <linux/vserver/limit.h>
+#include <linux/vserver/inode.h>
+#include <linux/vserver/signal.h>
+
+extern asmlinkage long
+sys_vserver(uint32_t cmd, uint32_t id, void *data)
+{
+	switch (cmd) {
+	case VCMD_get_version:
+		return vc_get_version(id);
+
+#ifdef	CONFIG_VSERVER_LEGACY		
+	case VCMD_new_s_context:
+		return vc_new_s_context(id, data);
+	case VCMD_set_ipv4root:
+		return vc_set_ipv4root(id, data);
+#endif
+
+	case VCMD_task_xid:
+		return vc_task_xid(id, data);
+	case VCMD_vx_info:
+		return vc_vx_info(id, data);
+
+	case VCMD_set_namespace:
+		return vc_set_namespace(id, data);
+	case VCMD_cleanup_namespace:
+		return vc_cleanup_namespace(id, data);
+	}
+
+	/* those are allowed while in setup too */
+	if (!vx_check(0, VX_ADMIN|VX_WATCH) &&
+		!vx_flags(VXF_STATE_SETUP,0))
+		return -EPERM;
+
+	switch (cmd) {
+	case VCMD_get_rlimit:
+		return vc_get_rlimit(id, data);
+	case VCMD_set_rlimit:
+		return vc_set_rlimit(id, data);
+	case VCMD_get_rlimit_mask:
+		return vc_get_rlimit_mask(id, data);
+		
+	case VCMD_vx_get_vhi_name:
+		return vc_get_vhi_name(id, data);
+	case VCMD_vx_set_vhi_name:
+		return vc_set_vhi_name(id, data);
+
+	case VCMD_set_flags:
+		return vc_set_flags(id, data);
+	case VCMD_get_flags:
+		return vc_get_flags(id, data);
+
+	case VCMD_set_ccaps:
+		return vc_set_ccaps(id, data);
+	case VCMD_get_ccaps:
+		return vc_get_ccaps(id, data);
+
+	case VCMD_set_sched:
+		return vc_set_sched(id, data);
+	}
+
+	/* below here only with VX_ADMIN */
+	if (!vx_check(0, VX_ADMIN|VX_WATCH))
+		return -EPERM;
+
+	switch (cmd) {
+	case VCMD_ctx_kill:
+		return vc_ctx_kill(id, data);
+
+	case VCMD_get_iattr_v0:
+		return vc_get_iattr_v0(id, data);
+	case VCMD_set_iattr_v0:
+		return vc_set_iattr_v0(id, data);
+	case VCMD_get_iattr:
+		return vc_get_iattr(id, data);
+	case VCMD_set_iattr:
+		return vc_set_iattr(id, data);
+
+	case VCMD_enter_namespace:
+		return vc_enter_namespace(id, data);
+	case VCMD_create_context:
+		return vc_create_context(id, data);
+	case VCMD_migrate_context:
+		return vc_migrate_context(id, data);
+
+	}
+	return -ENOSYS;
+}
+
diff -NurpP --minimal linux-2.6.5/mm/fremap.c linux-2.6.5-vs1.9.0pre2/mm/fremap.c
--- linux-2.6.5/mm/fremap.c	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/mm/fremap.c	2004-04-05 00:55:18.000000000 +0200
@@ -38,7 +38,8 @@ static inline void zap_pte(struct mm_str
 					set_page_dirty(page);
 				page_remove_rmap(page, ptep);
 				page_cache_release(page);
-				mm->rss--;
+				// mm->rss--;
+				vx_rsspages_dec(mm);
 			}
 		}
 	} else {
@@ -78,7 +79,8 @@ int install_page(struct mm_struct *mm, s
 
 	zap_pte(mm, vma, addr, pte);
 
-	mm->rss++;
+	// mm->rss++;
+	vx_rsspages_inc(mm);
 	flush_icache_page(vma, page);
 	set_pte(pte, mk_pte(page, prot));
 	pte_chain = page_add_rmap(page, pte, pte_chain);
diff -NurpP --minimal linux-2.6.5/mm/memory.c linux-2.6.5-vs1.9.0pre2/mm/memory.c
--- linux-2.6.5/mm/memory.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/mm/memory.c	2004-04-05 00:55:18.000000000 +0200
@@ -328,7 +328,8 @@ skip_copy_pte_range:
 					pte = pte_mkclean(pte);
 				pte = pte_mkold(pte);
 				get_page(page);
-				dst->rss++;
+				// dst->rss++;
+				vx_rsspages_inc(dst);
 
 				set_pte(dst_pte, pte);
 				pte_chain = page_add_rmap(page, dst_pte,
@@ -1068,7 +1069,8 @@ static int do_wp_page(struct mm_struct *
 	page_table = pte_offset_map(pmd, address);
 	if (pte_same(*page_table, pte)) {
 		if (PageReserved(old_page))
-			++mm->rss;
+			// ++mm->rss;
+			vx_rsspages_inc(mm);
 		page_remove_rmap(old_page, page_table);
 		break_cow(vma, new_page, address, page_table);
 		pte_chain = page_add_rmap(new_page, page_table, pte_chain);
@@ -1302,7 +1304,8 @@ static int do_swap_page(struct mm_struct
 	if (vm_swap_full())
 		remove_exclusive_swap_page(page);
 
-	mm->rss++;
+	// mm->rss++;
+	vx_rsspages_inc(mm);
 	pte = mk_pte(page, vma->vm_page_prot);
 	if (write_access && can_share_swap_page(page))
 		pte = maybe_mkwrite(pte_mkdirty(pte), vma);
@@ -1371,7 +1374,8 @@ do_anonymous_page(struct mm_struct *mm, 
 			ret = VM_FAULT_MINOR;
 			goto out;
 		}
-		mm->rss++;
+		// mm->rss++;
+		vx_rsspages_inc(mm);
 		entry = maybe_mkwrite(pte_mkdirty(mk_pte(page,
 							 vma->vm_page_prot)),
 				      vma);
@@ -1486,7 +1490,8 @@ retry:
 	/* Only go through if we didn't race with anybody else... */
 	if (pte_none(*page_table)) {
 		if (!PageReserved(new_page))
-			++mm->rss;
+			// ++mm->rss;
+			vx_rsspages_inc(mm);
 		flush_icache_page(vma, new_page);
 		entry = mk_pte(new_page, vma->vm_page_prot);
 		if (write_access)
diff -NurpP --minimal linux-2.6.5/mm/mlock.c linux-2.6.5-vs1.9.0pre2/mm/mlock.c
--- linux-2.6.5/mm/mlock.c	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/mm/mlock.c	2004-04-05 00:55:18.000000000 +0200
@@ -174,6 +174,7 @@ asmlinkage long sys_mlockall(int flags)
 	lock_limit >>= PAGE_SHIFT;
 
 	ret = -ENOMEM;
+	/* check vserver lock limits? */
 	if (current->mm->total_vm <= lock_limit)
 		ret = do_mlockall(flags);
 out:
diff -NurpP --minimal linux-2.6.5/mm/mmap.c linux-2.6.5-vs1.9.0pre2/mm/mmap.c
--- linux-2.6.5/mm/mmap.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/mm/mmap.c	2004-04-05 00:55:18.000000000 +0200
@@ -614,6 +614,10 @@ munmap_back:
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
 
+	/* check context space, maybe only Private writable mapping? */
+	if (!vx_vmpages_avail(mm, len >> PAGE_SHIFT))
+		return -ENOMEM;
+
 	if (accountable && (!(flags & MAP_NORESERVE) ||
 			sysctl_overcommit_memory > 1)) {
 		if (vm_flags & VM_SHARED) {
@@ -708,9 +712,11 @@ munmap_back:
 		kmem_cache_free(vm_area_cachep, vma);
 	}
 out:	
-	mm->total_vm += len >> PAGE_SHIFT;
+	// mm->total_vm += len >> PAGE_SHIFT;
+	vx_vmpages_add(mm, len >> PAGE_SHIFT);
 	if (vm_flags & VM_LOCKED) {
-		mm->locked_vm += len >> PAGE_SHIFT;
+		// mm->locked_vm += len >> PAGE_SHIFT;
+		vx_vmlocked_add(mm, len >> PAGE_SHIFT);
 		make_pages_present(addr, addr + len);
 	}
 	if (flags & MAP_POPULATE) {
@@ -947,10 +953,14 @@ int expand_stack(struct vm_area_struct *
 		vm_unacct_memory(grow);
 		return -ENOMEM;
 	}
+	/* check vserver limits */
+
 	vma->vm_end = address;
-	vma->vm_mm->total_vm += grow;
+	// vma->vm_mm->total_vm += grow;
+	vx_vmpages_add(vma->vm_mm, grow);
 	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
+		// vma->vm_mm->locked_vm += grow;
+		vx_vmlocked_add(vma->vm_mm, grow);
 	spin_unlock(&vma->vm_mm->page_table_lock);
 	return 0;
 }
@@ -1001,11 +1011,14 @@ int expand_stack(struct vm_area_struct *
 		vm_unacct_memory(grow);
 		return -ENOMEM;
 	}
+	/* check vserver limits */
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
-	vma->vm_mm->total_vm += grow;
+	// vma->vm_mm->total_vm += grow;
+	vx_vmpages_add(vma->vm_mm, grow);
 	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
+		// vma->vm_mm->locked_vm += grow;
+		vx_vmlocked_add(vma->vm_mm, grow);
 	spin_unlock(&vma->vm_mm->page_table_lock);
 	return 0;
 }
@@ -1108,9 +1121,12 @@ static void unmap_vma(struct mm_struct *
 {
 	size_t len = area->vm_end - area->vm_start;
 
-	area->vm_mm->total_vm -= len >> PAGE_SHIFT;
+	// area->vm_mm->total_vm -= len >> PAGE_SHIFT;
+	vx_vmpages_sub(area->vm_mm, len >> PAGE_SHIFT);
+	
 	if (area->vm_flags & VM_LOCKED)
-		area->vm_mm->locked_vm -= len >> PAGE_SHIFT;
+		// area->vm_mm->locked_vm -= len >> PAGE_SHIFT;
+		vx_vmlocked_sub(area->vm_mm, len >> PAGE_SHIFT);
 	/*
 	 * Is this a new hole at the lowest possible address?
 	 */
@@ -1365,6 +1381,7 @@ unsigned long do_brk(unsigned long addr,
 		locked += len;
 		if (locked > current->rlim[RLIMIT_MEMLOCK].rlim_cur)
 			return -EAGAIN;
+		/* vserver checks */
 	}
 
 	/*
@@ -1419,9 +1436,11 @@ unsigned long do_brk(unsigned long addr,
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 
 out:
-	mm->total_vm += len >> PAGE_SHIFT;
+	// mm->total_vm += len >> PAGE_SHIFT;
+	vx_vmpages_add(mm, len >> PAGE_SHIFT);
 	if (flags & VM_LOCKED) {
-		mm->locked_vm += len >> PAGE_SHIFT;
+		// mm->locked_vm += len >> PAGE_SHIFT;
+		vx_vmlocked_add(mm, len >> PAGE_SHIFT);
 		make_pages_present(addr, addr + len);
 	}
 	return addr;
@@ -1455,9 +1474,12 @@ void exit_mmap(struct mm_struct *mm)
 	vma = mm->mmap;
 	mm->mmap = mm->mmap_cache = NULL;
 	mm->mm_rb = RB_ROOT;
-	mm->rss = 0;
-	mm->total_vm = 0;
-	mm->locked_vm = 0;
+	// mm->rss = 0;
+	vx_rsspages_sub(mm, mm->rss);
+	// mm->total_vm = 0;
+	vx_vmpages_sub(mm, mm->total_vm);
+	// mm->locked_vm = 0;
+	vx_vmlocked_sub(mm, mm->locked_vm);
 
 	spin_unlock(&mm->page_table_lock);
 
diff -NurpP --minimal linux-2.6.5/mm/mremap.c linux-2.6.5-vs1.9.0pre2/mm/mremap.c
--- linux-2.6.5/mm/mremap.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/mm/mremap.c	2004-04-05 00:55:18.000000000 +0200
@@ -282,9 +282,11 @@ static unsigned long move_vma(struct vm_
 				vma->vm_next->vm_flags |= VM_ACCOUNT;
 		}
 
-		current->mm->total_vm += new_len >> PAGE_SHIFT;
+		// current->mm->total_vm += new_len >> PAGE_SHIFT;
+		vx_vmpages_add(current->mm, new_len >> PAGE_SHIFT);
 		if (vm_locked) {
-			current->mm->locked_vm += new_len >> PAGE_SHIFT;
+			// current->mm->locked_vm += new_len >> PAGE_SHIFT;
+			vx_vmlocked_add(current->mm, new_len >> PAGE_SHIFT);
 			if (new_len > old_len)
 				make_pages_present(new_addr + old_len,
 						   new_addr + new_len);
@@ -397,6 +399,9 @@ unsigned long do_mremap(unsigned long ad
 	if ((current->mm->total_vm << PAGE_SHIFT) + (new_len - old_len)
 	    > current->rlim[RLIMIT_AS].rlim_cur)
 		goto out;
+	/* check context space, maybe only Private writable mapping? */
+	if (!vx_vmpages_avail(current->mm, (new_len - old_len) >> PAGE_SHIFT))
+		goto out;
 
 	if (vma->vm_flags & VM_ACCOUNT) {
 		charged = (new_len - old_len) >> PAGE_SHIFT;
@@ -419,9 +424,11 @@ unsigned long do_mremap(unsigned long ad
 			spin_lock(&vma->vm_mm->page_table_lock);
 			vma->vm_end = addr + new_len;
 			spin_unlock(&vma->vm_mm->page_table_lock);
-			current->mm->total_vm += pages;
+			// current->mm->total_vm += pages;
+			vx_vmpages_add(current->mm, pages);
 			if (vma->vm_flags & VM_LOCKED) {
-				current->mm->locked_vm += pages;
+				// current->mm->locked_vm += pages;
+				vx_vmlocked_add(current->mm, pages);
 				make_pages_present(addr + old_len,
 						   addr + new_len);
 			}
diff -NurpP --minimal linux-2.6.5/mm/oom_kill.c linux-2.6.5-vs1.9.0pre2/mm/oom_kill.c
--- linux-2.6.5/mm/oom_kill.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/mm/oom_kill.c	2004-04-05 00:55:18.000000000 +0200
@@ -54,6 +54,7 @@ static int badness(struct task_struct *p
 	 * The memory size of the process is the basis for the badness.
 	 */
 	points = p->mm->total_vm;
+	/* add vserver badness ;) */
 
 	/*
 	 * CPU time is in seconds and run time is in minutes. There is no
diff -NurpP --minimal linux-2.6.5/mm/page_alloc.c linux-2.6.5-vs1.9.0pre2/mm/page_alloc.c
--- linux-2.6.5/mm/page_alloc.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/mm/page_alloc.c	2004-04-05 00:55:18.000000000 +0200
@@ -975,6 +975,8 @@ void si_meminfo(struct sysinfo *val)
 	val->freehigh = 0;
 #endif
 	val->mem_unit = PAGE_SIZE;
+	if (vx_flags(VXF_VIRT_MEM, 0))
+		vx_vsi_meminfo(val);
 }
 
 EXPORT_SYMBOL(si_meminfo);
diff -NurpP --minimal linux-2.6.5/mm/rmap.c linux-2.6.5-vs1.9.0pre2/mm/rmap.c
--- linux-2.6.5/mm/rmap.c	2004-04-04 18:03:13.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/mm/rmap.c	2004-04-05 00:55:18.000000000 +0200
@@ -361,7 +361,8 @@ static int fastcall try_to_unmap_one(str
 	if (pte_dirty(pte))
 		set_page_dirty(page);
 
-	mm->rss--;
+	// mm->rss--;
+	vx_rsspages_dec(mm);
 	page_cache_release(page);
 	ret = SWAP_SUCCESS;
 
diff -NurpP --minimal linux-2.6.5/mm/swapfile.c linux-2.6.5-vs1.9.0pre2/mm/swapfile.c
--- linux-2.6.5/mm/swapfile.c	2004-04-04 18:03:14.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/mm/swapfile.c	2004-04-05 00:55:18.000000000 +0200
@@ -387,7 +387,8 @@ static void
 unuse_pte(struct vm_area_struct *vma, unsigned long address, pte_t *dir,
 	swp_entry_t entry, struct page *page, struct pte_chain **pte_chainp)
 {
-	vma->vm_mm->rss++;
+	// vma->vm_mm->rss++;
+	vx_rsspages_inc(vma->vm_mm);
 	get_page(page);
 	set_pte(dir, pte_mkold(mk_pte(page, vma->vm_page_prot)));
 	*pte_chainp = page_add_rmap(page, dir, *pte_chainp);
@@ -1513,6 +1514,8 @@ void si_swapinfo(struct sysinfo *val)
 	val->freeswap = nr_swap_pages + nr_to_be_unused;
 	val->totalswap = total_swap_pages + nr_to_be_unused;
 	swap_list_unlock();
+        if (vx_flags(VXF_VIRT_MEM, 0))
+                vx_vsi_swapinfo(val);
 }
 
 /*
diff -NurpP --minimal linux-2.6.5/net/core/dev.c linux-2.6.5-vs1.9.0pre2/net/core/dev.c
--- linux-2.6.5/net/core/dev.c	2004-04-04 18:03:14.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/net/core/dev.c	2004-04-05 00:55:18.000000000 +0200
@@ -1353,6 +1353,7 @@ int dev_queue_xmit(struct sk_buff *skb)
 			preempt_enable();
 
 			if (!netif_queue_stopped(dev)) {
+				/* account outgoing here */
 				if (netdev_nit)
 					dev_queue_xmit_nit(skb, dev);
 
@@ -1891,6 +1892,28 @@ int register_gifconf(unsigned int family
 	return 0;
 }
 
+int dev_in_ip_info(struct net_device *dev, struct ip_info *ipi)
+{
+	struct in_device *in_dev = __in_dev_get(dev);
+	struct in_ifaddr **ifap = NULL;
+	struct in_ifaddr *ifa = NULL;
+	int i, nbip;
+
+	if (!ipi)
+		return 1;
+	if (!in_dev)
+		return 0;
+
+	nbip = ipi->nbipv4;
+	for (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;
+		ifap = &ifa->ifa_next) {
+		for (i=0; i<nbip; i++)
+			if (ipi->ipv4[i] == ifa->ifa_address)
+				return 1;	
+	}
+	return 0;
+}
+
 
 /*
  *	Map an interface index to its name (SIOCGIFNAME)
@@ -1961,6 +1984,8 @@ static int dev_ifconf(char *arg)
 
 	total = 0;
 	for (dev = dev_base; dev; dev = dev->next) {
+		if (!dev_in_ip_info(dev, current->ip_info))
+			continue;
 		for (i = 0; i < NPROTO; i++) {
 			if (gifconf_list[i]) {
 				int done;
@@ -2021,6 +2046,10 @@ void dev_seq_stop(struct seq_file *seq, 
 
 static void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)
 {
+	struct ip_info *ipi = current->ip_info;
+
+	if (!dev_in_ip_info(dev, ipi))
+		return;
 	if (dev->get_stats) {
 		struct net_device_stats *stats = dev->get_stats(dev);
 
diff -NurpP --minimal linux-2.6.5/net/core/sock.c linux-2.6.5-vs1.9.0pre2/net/core/sock.c
--- linux-2.6.5/net/core/sock.c	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/core/sock.c	2004-04-05 00:55:18.000000000 +0200
@@ -323,7 +323,10 @@ int sock_setsockopt(struct socket *sock,
 			break;
 
 		case SO_PASSCRED:
-			sock->passcred = valbool;
+			if (valbool)
+				set_bit(SOCK_PASS_CRED, &sock->flags);
+			else
+				clear_bit(SOCK_PASS_CRED, &sock->flags);
 			break;
 
 		case SO_TIMESTAMP:
@@ -544,7 +547,7 @@ int sock_getsockopt(struct socket *sock,
 			break; 
 
 		case SO_PASSCRED:
-			v.val = sock->passcred;
+			v.val = test_bit(SOCK_PASS_CRED, &sock->flags)?1:0;
 			break;
 
 		case SO_PEERCRED:
diff -NurpP --minimal linux-2.6.5/net/ipv4/af_inet.c linux-2.6.5-vs1.9.0pre2/net/ipv4/af_inet.c
--- linux-2.6.5/net/ipv4/af_inet.c	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/af_inet.c	2004-04-05 00:55:18.000000000 +0200
@@ -158,6 +158,9 @@ void inet_sock_destruct(struct sock *sk)
 
 	if (inet->opt)
 		kfree(inet->opt);
+	
+	BUG_ON(sk->sk_ip_info);
+	BUG_ON(sk->sk_vx_info);
 	dst_release(sk->sk_dst_cache);
 #ifdef INET_REFCNT_DEBUG
 	atomic_dec(&inet_sock_nr);
@@ -397,6 +400,10 @@ static int inet_create(struct socket *so
 	sk->sk_family	   = PF_INET;
 	sk->sk_protocol	   = protocol;
 	sk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;
+	
+	sk->sk_xid = vx_current_xid();
+	sk->sk_vx_info = get_vx_info(current->vx_info);
+	sk->sk_ip_info = get_ip_info(current->ip_info);
 
 	inet->uc_ttl	= -1;
 	inet->mc_loop	= 1;
@@ -421,8 +428,13 @@ static int inet_create(struct socket *so
 
 	if (sk->sk_prot->init) {
 		err = sk->sk_prot->init(sk);
-		if (err)
-			inet_sock_release(sk);
+		if (err) {
+/*			sk->sk_vx_info = NULL;
+			put_vx_info(current->vx_info);
+			sk->sk_ip_info = NULL;
+			put_ip_info(current->ip_info);
+*/			inet_sock_release(sk);
+		}
 	}
 out:
 	return err;
@@ -443,11 +455,22 @@ int inet_release(struct socket *sock)
 	struct sock *sk = sock->sk;
 
 	if (sk) {
+		struct vx_info *vxi;
+		struct ip_info *ipi;
 		long timeout;
 
 		/* Applications forget to leave groups before exiting */
 		ip_mc_drop_socket(sk);
 
+		if ((vxi = sk->sk_vx_info)) {
+			sk->sk_vx_info = NULL;
+			put_vx_info(vxi);
+		}	
+		if ((ipi = sk->sk_ip_info)) {
+			sk->sk_ip_info = NULL;
+			put_ip_info(ipi);
+		}	
+
 		/* If linger is set, we don't return until the close
 		 * is complete.  Otherwise we return immediately. The
 		 * actually closing is done the same either way.
@@ -476,6 +499,10 @@ int inet_bind(struct socket *sock, struc
 	unsigned short snum;
 	int chk_addr_ret;
 	int err;
+	__u32 s_addr;	/* Address used for validation */
+	__u32 s_addr1;
+	__u32 s_addr2 = 0xffffffffl;	/* Optional address of the socket */
+	struct ip_info *ip_info;
 
 	/* If the socket has its own bind function then use it. (RAW) */
 	if (sk->sk_prot->bind) {
@@ -486,7 +513,39 @@ int inet_bind(struct socket *sock, struc
 	if (addr_len < sizeof(struct sockaddr_in))
 		goto out;
 
-	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	s_addr = s_addr1 = addr->sin_addr.s_addr;
+	ip_info = sk->sk_ip_info;
+	vxdprintk("inet_bind(%p) %p,%p;%lx\n",
+		sk, ip_info, sk->sk_socket,
+		(sk->sk_socket?sk->sk_socket->flags:0));
+	if (ip_info) {
+		__u32 v4_bcast = ip_info->v4_bcast;
+		__u32 ipv4root = ip_info->ipv4[0];
+		int nbipv4 = ip_info->nbipv4;
+		if (s_addr == 0) {
+			s_addr = ipv4root;
+			if (nbipv4 > 1)
+				s_addr1 = 0;
+			else {
+				s_addr1 = ipv4root;
+				ip_info = NULL;
+			}
+			s_addr2 = v4_bcast;
+		} else if (s_addr == 0x0100007f) {
+			s_addr = s_addr1 = ipv4root;
+			ip_info = NULL;
+		} else if (s_addr != v4_bcast) {
+			int i;
+			for (i=0; i<nbipv4; i++) {
+				if (s_addr == ip_info->ipv4[i])
+					break;
+			}
+			if (i == nbipv4)
+				return -EADDRNOTAVAIL;
+			ip_info = NULL;
+		}
+	}
+	chk_addr_ret = inet_addr_type(s_addr);
 
 	/* Not specified by any standard per-se, however it breaks too
 	 * many applications when removed.  It is unfortunate since
@@ -498,7 +557,7 @@ int inet_bind(struct socket *sock, struc
 	err = -EADDRNOTAVAIL;
 	if (!sysctl_ip_nonlocal_bind &&
 	    !inet->freebind &&
-	    addr->sin_addr.s_addr != INADDR_ANY &&
+	    s_addr != INADDR_ANY &&
 	    chk_addr_ret != RTN_LOCAL &&
 	    chk_addr_ret != RTN_MULTICAST &&
 	    chk_addr_ret != RTN_BROADCAST)
@@ -523,13 +582,25 @@ int inet_bind(struct socket *sock, struc
 	if (sk->sk_state != TCP_CLOSE || inet->num)
 		goto out_release_sock;
 
-	inet->rcv_saddr = inet->saddr = addr->sin_addr.s_addr;
+	inet->rcv_saddr = inet->saddr = s_addr1;
+	inet->rcv_saddr2 = s_addr2;
+/*	do we need that?
+	if (sk->sk_socket &&
+		(!test_bit(SOCK_USER_SOCKET, &sk->sk_socket->flags))) {
+		sk->sk_ip_info = NULL
+		put_ip_info(ip_info);
+		ip_info = NULL;
+	}
+*/
+
 	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
 		inet->saddr = 0;  /* Use device */
 
 	/* Make sure we are allowed to bind here. */
 	if (sk->sk_prot->get_port(sk, snum)) {
 		inet->saddr = inet->rcv_saddr = 0;
+		sk->sk_ip_info = NULL;
+		put_ip_info(ip_info);
 		err = -EADDRINUSE;
 		goto out_release_sock;
 	}
diff -NurpP --minimal linux-2.6.5/net/ipv4/devinet.c linux-2.6.5-vs1.9.0pre2/net/ipv4/devinet.c
--- linux-2.6.5/net/ipv4/devinet.c	2004-04-04 18:03:14.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/devinet.c	2004-04-05 00:55:13.000000000 +0200
@@ -488,6 +488,33 @@ static __inline__ int inet_abc_len(u32 a
   	return rc;
 }
 
+/*
+	Check that a device is not member of the ipv4root assigned to the process
+	Return true if this is the case
+
+	If the process is not bound to specific IP, then it returns 0 (all
+	interface are fine).
+*/
+static int devinet_notiproot (struct in_ifaddr *ifa)
+{
+	int ret = 0;
+	struct ip_info *ipi;
+
+	if ((ipi = current->ip_info)) {
+		int i;
+		int nbip = ipi->nbipv4;
+		__u32 addr = ifa->ifa_local;
+		ret = 1;
+		for (i=0; i<nbip; i++) {
+			if(ipi->ipv4[i] == addr) {
+				ret = 0;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
 
 int devinet_ioctl(unsigned int cmd, void *arg)
 {
@@ -595,6 +622,8 @@ int devinet_ioctl(unsigned int cmd, void
 	ret = -EADDRNOTAVAIL;
 	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)
 		goto done;
+	if (ifa != NULL && devinet_notiproot(ifa))
+		goto done;
 
 	switch(cmd) {
 	case SIOCGIFADDR:	/* Get interface address */
@@ -724,6 +753,8 @@ static int inet_gifconf(struct net_devic
 		goto out;
 
 	for (; ifa; ifa = ifa->ifa_next) {
+		if (devinet_notiproot(ifa))
+			continue;
 		if (!buf) {
 			done += sizeof(ifr);
 			continue;
@@ -1059,6 +1090,8 @@ static int inet_dump_ifaddr(struct sk_bu
 		read_lock(&in_dev->lock);
 		for (ifa = in_dev->ifa_list, ip_idx = 0; ifa;
 		     ifa = ifa->ifa_next, ip_idx++) {
+			if (devinet_notiproot(ifa))
+				continue;
 			if (ip_idx < s_ip_idx)
 				continue;
 			if (inet_fill_ifaddr(skb, ifa, NETLINK_CB(cb->skb).pid,
diff -NurpP --minimal linux-2.6.5/net/ipv4/fib_hash.c linux-2.6.5-vs1.9.0pre2/net/ipv4/fib_hash.c
--- linux-2.6.5/net/ipv4/fib_hash.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/fib_hash.c	2004-04-05 00:55:18.000000000 +0200
@@ -1010,6 +1010,8 @@ static unsigned fib_flag_trans(int type,
 	return flags;
 }
 
+extern int dev_in_ip_info(struct net_device *, struct ip_info *);
+
 /* 
  *	This outputs /proc/net/route.
  *
@@ -1039,7 +1041,7 @@ static int fib_seq_show(struct seq_file 
 	mask	= FZ_MASK(iter->zone);
 	flags	= fib_flag_trans(f->fn_type, f->fn_state & FN_S_ZOMBIE,
 				 mask, fi);
-	if (fi)
+	if (fi && dev_in_ip_info(fi->fib_dev, current->ip_info))
 		snprintf(bf, sizeof(bf),
 			 "%s\t%08X\t%08X\t%04X\t%d\t%u\t%d\t%08X\t%d\t%u\t%u",
 			 fi->fib_dev ? fi->fib_dev->name : "*", prefix,
diff -NurpP --minimal linux-2.6.5/net/ipv4/raw.c linux-2.6.5-vs1.9.0pre2/net/ipv4/raw.c
--- linux-2.6.5/net/ipv4/raw.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/raw.c	2004-04-05 00:55:13.000000000 +0200
@@ -102,6 +102,38 @@ static void raw_v4_unhash(struct sock *s
 	write_unlock_bh(&raw_v4_lock);
 }
 
+
+/*
+	Check if an address is in the list
+*/
+static inline int raw_addr_in_list (
+	u32 rcv_saddr1,
+	u32 rcv_saddr2,
+	u32 loc_addr,
+	struct ip_info *ip_info)
+{
+	int ret = 0;
+	if (loc_addr != 0 &&
+		(rcv_saddr1 == loc_addr || rcv_saddr2 == loc_addr))
+		ret = 1;
+	else if (rcv_saddr1 == 0) {
+		/* Accept any address or only the one in the list */
+		if (ip_info == NULL)
+			ret = 1;
+		else {
+			int n = ip_info->nbipv4;
+			int i;
+			for (i=0; i<n; i++) {
+				if (ip_info->ipv4[i] == loc_addr) {
+					ret = 1;
+					break;
+				}
+			}
+		}
+	}
+	return ret;
+}
+
 struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
 			     unsigned long raddr, unsigned long laddr,
 			     int dif)
@@ -113,7 +145,8 @@ struct sock *__raw_v4_lookup(struct sock
 
 		if (inet->num == num 					&&
 		    !(inet->daddr && inet->daddr != raddr) 		&&
-		    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
+		    raw_addr_in_list(inet->rcv_saddr, inet->rcv_saddr2,
+			laddr, sk->sk_ip_info) &&
 		    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
 			goto found; /* gotcha */
 	}
@@ -687,7 +720,8 @@ static struct sock *raw_get_first(struct
 		struct hlist_node *node;
 
 		sk_for_each(sk, node, &raw_v4_htable[state->bucket])
-			if (sk->sk_family == PF_INET)
+			if (sk->sk_family == PF_INET &&
+				vx_check(sk->sk_xid, VX_WATCH|VX_IDENT))
 				goto found;
 	}
 	sk = NULL;
diff -NurpP --minimal linux-2.6.5/net/ipv4/tcp_ipv4.c linux-2.6.5-vs1.9.0pre2/net/ipv4/tcp_ipv4.c
--- linux-2.6.5/net/ipv4/tcp_ipv4.c	2004-04-04 18:03:14.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/tcp_ipv4.c	2004-04-05 00:55:13.000000000 +0200
@@ -179,9 +179,64 @@ void tcp_bind_hash(struct sock *sk, stru
 	tcp_sk(sk)->bind_hash = tb;
 }
 
+/*
+	Return 1 if addr match the socket IP list
+	or the socket is INADDR_ANY
+*/
+static inline int tcp_in_list (struct sock *sk, u32 addr)
+{
+	struct ip_info *ip_info = sk->sk_ip_info;
+
+	vxdprintk("tcp_in_list(%p) %p,%p;%lx\n",
+		sk, ip_info, sk->sk_socket,
+		(sk->sk_socket?sk->sk_socket->flags:0));
+
+	if (ip_info) {
+		int n = ip_info->nbipv4;
+		int i;
+
+		for (i=0; i<n; i++)
+			if (ip_info->ipv4[i] == addr)
+				return 1;
+	}
+	else if (!tcp_v4_rcv_saddr(sk) || tcp_v4_rcv_saddr(sk) == addr)
+		return 1;
+	return 0;
+}
+	
+/*
+	Check if the addresses in sk1 conflict with those in sk2
+*/
+int tcp_ipv4_addr_conflict (struct sock *sk1, struct sock *sk2)
+{
+	if (sk1 && sk2)
+	vxdprintk("inet_bind(%p,%p) %p,%p;%lx %p,%p;%lx\n",
+		sk1, sk2,
+		sk1->sk_ip_info, sk1->sk_socket,
+		(sk1->sk_socket?sk1->sk_socket->flags:0),
+		sk2->sk_ip_info, sk2->sk_socket,
+		(sk2->sk_socket?sk2->sk_socket->flags:0));
+
+	if (tcp_v4_rcv_saddr(sk1)) {
+		/* Bind to one address only */
+		return tcp_in_list (sk2, tcp_v4_rcv_saddr(sk1));
+	} else if (sk1->sk_ip_info) {
+		/* A restricted bind(any) */
+		struct ip_info *ip_info = sk1->sk_ip_info;
+		int n = ip_info->nbipv4;
+		int i;
+
+		for (i=0; i<n; i++)
+			if (tcp_in_list (sk2, ip_info->ipv4[i]))
+				return 1;
+	} else	/* A bind(any) do not allow other bind on the same port */
+		return 1;
+	return 0;
+}
+
 static inline int tcp_bind_conflict(struct sock *sk, struct tcp_bind_bucket *tb)
 {
-	const u32 sk_rcv_saddr = tcp_v4_rcv_saddr(sk);
+//	const u32 sk_rcv_saddr = tcp_v4_rcv_saddr(sk);
 	struct sock *sk2;
 	struct hlist_node *node;
 	int reuse = sk->sk_reuse;
@@ -194,9 +249,8 @@ static inline int tcp_bind_conflict(stru
 		     sk->sk_bound_dev_if == sk2->sk_bound_dev_if)) {
 			if (!reuse || !sk2->sk_reuse ||
 			    sk2->sk_state == TCP_LISTEN) {
-				const u32 sk2_rcv_saddr = tcp_v4_rcv_saddr(sk2);
-				if (!sk2_rcv_saddr || !sk_rcv_saddr ||
-				    sk2_rcv_saddr == sk_rcv_saddr)
+//				const u32 sk2_rcv_saddr = tcp_v4_rcv_saddr(sk2);
+				if (tcp_ipv4_addr_conflict(sk, sk2))
 					break;
 			}
 		}
@@ -405,6 +459,34 @@ void tcp_unhash(struct sock *sk)
 		wake_up(&tcp_lhash_wait);
 }
 
+/*
+	Check if an address is in the list
+*/
+static inline int tcp_addr_in_list (
+	u32 rcv_saddr,
+	u32 daddr,
+	struct ip_info *ip_info)
+{
+	if (rcv_saddr == daddr)
+		return 1;
+	else if (rcv_saddr == 0) {
+		/* Accept any address or check the list */
+		if (!ip_info)
+			return 1;
+		else {
+			int n = ip_info->nbipv4;
+			int i;
+
+			for (i=0; i<n; i++)
+				if (ip_info->ipv4[i] == daddr)
+					return 1;
+		}
+	}
+	return 0;
+}
+
+
+
 /* Don't inline this cruft.  Here are some nice properties to
  * exploit here.  The BSD API does not allow a listening TCP
  * to specify the remote port nor the remote address for the
@@ -426,11 +508,10 @@ static struct sock *__tcp_v4_lookup_list
 			__u32 rcv_saddr = inet->rcv_saddr;
 
 			score = (sk->sk_family == PF_INET ? 1 : 0);
-			if (rcv_saddr) {
-				if (rcv_saddr != daddr)
-					continue;
+			if (tcp_addr_in_list(rcv_saddr, daddr, sk->sk_ip_info))
 				score+=2;
-			}
+			else
+				continue;
 			if (sk->sk_bound_dev_if) {
 				if (sk->sk_bound_dev_if != dif)
 					continue;
@@ -460,8 +541,8 @@ inline struct sock *tcp_v4_lookup_listen
 		struct inet_opt *inet = inet_sk((sk = __sk_head(head)));
 
 		if (inet->num == hnum && !sk->sk_node.next &&
-		    (!inet->rcv_saddr || inet->rcv_saddr == daddr) &&
 		    (sk->sk_family == PF_INET || !ipv6_only_sock(sk)) &&
+		    tcp_addr_in_list(inet->rcv_saddr, daddr, sk->sk_ip_info) &&
 		    !sk->sk_bound_dev_if)
 			goto sherry_cache;
 		sk = __tcp_v4_lookup_listener(head, daddr, hnum, dif);
diff -NurpP --minimal linux-2.6.5/net/ipv4/tcp_minisocks.c linux-2.6.5-vs1.9.0pre2/net/ipv4/tcp_minisocks.c
--- linux-2.6.5/net/ipv4/tcp_minisocks.c	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/tcp_minisocks.c	2004-04-05 00:55:13.000000000 +0200
@@ -362,6 +362,9 @@ void tcp_time_wait(struct sock *sk, int 
 		tw->tw_ts_recent_stamp	= tp->ts_recent_stamp;
 		tw_dead_node_init(tw);
 
+		tw->tw_xid		= sk->sk_xid;
+		tw->tw_ip_info		= NULL;
+		
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 		if (tw->tw_family == PF_INET6) {
 			struct ipv6_pinfo *np = inet6_sk(sk);
@@ -694,6 +697,7 @@ struct sock *tcp_create_openreq_child(st
 		struct sk_filter *filter;
 
 		memcpy(newsk, sk, sizeof(struct tcp_sock));
+		newsk->sk_ip_info = get_ip_info(sk->sk_ip_info);
 		newsk->sk_state = TCP_SYN_RECV;
 
 		/* SANITY */
diff -NurpP --minimal linux-2.6.5/net/ipv4/udp.c linux-2.6.5-vs1.9.0pre2/net/ipv4/udp.c
--- linux-2.6.5/net/ipv4/udp.c	2004-03-11 03:55:23.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/ipv4/udp.c	2004-04-05 00:55:13.000000000 +0200
@@ -120,6 +120,9 @@ rwlock_t udp_hash_lock = RW_LOCK_UNLOCKE
 /* Shared by v4/v6 udp. */
 int udp_port_rover;
 
+int tcp_ipv4_addr_conflict (struct sock *sk1, struct sock *sk2);
+
+
 static int udp_v4_get_port(struct sock *sk, unsigned short snum)
 {
 	struct hlist_node *node;
@@ -179,9 +182,7 @@ gotit:
 			    (!sk2->sk_bound_dev_if ||
 			     !sk->sk_bound_dev_if ||
 			     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
-			    (!inet2->rcv_saddr ||
-			     !inet->rcv_saddr ||
-			     inet2->rcv_saddr == inet->rcv_saddr) &&
+			    tcp_ipv4_addr_conflict(sk2, sk) &&
 			    (!sk2->sk_reuse || !sk->sk_reuse))
 				goto fail;
 		}
@@ -216,6 +217,17 @@ static void udp_v4_unhash(struct sock *s
 	write_unlock_bh(&udp_hash_lock);
 }
 
+static int udp_in_list (struct ip_info *ip_info, u32 addr)
+{
+	int n = ip_info->nbipv4;
+	int i;
+
+	for (i=0; i<n; i++)
+		if (ip_info->ipv4[i] == addr)
+			return 1;
+	return 0;
+}
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -235,6 +247,11 @@ struct sock *udp_v4_lookup_longway(u32 s
 				if (inet->rcv_saddr != daddr)
 					continue;
 				score+=2;
+			} else if (sk->sk_ip_info) {
+				if (udp_in_list(sk->sk_ip_info, daddr))
+					score+=2;
+				else
+					continue;
 			}
 			if (inet->daddr) {
 				if (inet->daddr != saddr)
@@ -290,7 +307,8 @@ static inline struct sock *udp_v4_mcast_
 		if (inet->num != hnum					||
 		    (inet->daddr && inet->daddr != rmt_addr)		||
 		    (inet->dport != rmt_port && inet->dport)		||
-		    (inet->rcv_saddr && inet->rcv_saddr != loc_addr)	||
+		    (inet->rcv_saddr && inet->rcv_saddr != loc_addr &&
+		     inet->rcv_saddr2 && inet->rcv_saddr2 != loc_addr)	||
 		    ipv6_only_sock(s)					||
 		    (s->sk_bound_dev_if && s->sk_bound_dev_if != dif))
 			continue;
@@ -599,6 +617,15 @@ int udp_sendmsg(struct kiocb *iocb, stru
 				    .uli_u = { .ports =
 					       { .sport = inet->sport,
 						 .dport = dport } } };
+		struct ip_info *ip_info = sk->sk_ip_info;
+
+		if (ip_info != NULL) {
+			err = ip_find_src(ip_info, &rt, &fl);
+			if (err)
+				goto out;
+			if (daddr == IPI_LOOPBACK && !vx_check(0, VX_ADMIN))
+				daddr = fl.fl4_dst = ip_info->ipv4[0];
+		}
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
 			goto out;
diff -NurpP --minimal linux-2.6.5/net/socket.c linux-2.6.5-vs1.9.0pre2/net/socket.c
--- linux-2.6.5/net/socket.c	2004-03-11 03:55:25.000000000 +0100
+++ linux-2.6.5-vs1.9.0pre2/net/socket.c	2004-04-05 00:55:18.000000000 +0200
@@ -285,7 +285,7 @@ static struct inode *sock_alloc_inode(st
 	ei->socket.ops = NULL;
 	ei->socket.sk = NULL;
 	ei->socket.file = NULL;
-	ei->socket.passcred = 0;
+	ei->socket.flags = 0;
 
 	return &ei->vfs_inode;
 }
@@ -529,7 +529,7 @@ static inline int __sock_sendmsg(struct 
 				 struct msghdr *msg, size_t size)
 {
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
-	int err;
+	int err, len;
 
 	si->sock = sock;
 	si->scm = NULL;
@@ -540,7 +540,20 @@ static inline int __sock_sendmsg(struct 
 	if (err)
 		return err;
 
-	return sock->ops->sendmsg(iocb, sock, msg, size);
+	len = sock->ops->sendmsg(iocb, sock, msg, size);
+	if (sock->sk) {
+		if (len == size)
+			vx_sock_send(sock->sk, size);
+		else
+			vx_sock_fail(sock->sk, size);
+	}
+	vxdprintk("__sock_sendmsg: %p[%p,%p,%p;%d]:%d/%d\n",
+		sock, sock->sk,
+		(sock->sk)?sock->sk->sk_ip_info:0,
+		(sock->sk)?sock->sk->sk_vx_info:0,
+		(sock->sk)?sock->sk->sk_xid:0,
+		size, len);
+	return len;
 }
 
 int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
@@ -559,7 +572,7 @@ int sock_sendmsg(struct socket *sock, st
 static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock, 
 				 struct msghdr *msg, size_t size, int flags)
 {
-	int err;
+	int err, len;
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 
 	si->sock = sock;
@@ -572,7 +585,16 @@ static inline int __sock_recvmsg(struct 
 	if (err)
 		return err;
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	len = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	if ((len >= 0) && sock->sk)
+		vx_sock_recv(sock->sk, len);
+	vxdprintk("__sock_recvmsg: %p[%p,%p,%p;%d]:%d/%d\n",
+		sock, sock->sk,
+		(sock->sk)?sock->sk->sk_ip_info:0,
+		(sock->sk)?sock->sk->sk_vx_info:0,
+		(sock->sk)?sock->sk->sk_xid:0,
+		size, len);
+	return len;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg, 
@@ -998,6 +1020,10 @@ int sock_create(int family, int type, in
 	if (type < 0 || type >= SOCK_MAX)
 		return -EINVAL;
 
+	/* disable IPv6 inside vservers for now */
+	if (family == PF_INET6 && !vx_check(0, VX_ADMIN))
+		return -EAFNOSUPPORT;
+
 	/* Compatibility.
 
 	   This uglymoron is moved from INET layer to here to avoid
@@ -1096,6 +1122,7 @@ asmlinkage long sys_socket(int family, i
 	if (retval < 0)
 		goto out;
 
+	set_bit(SOCK_USER_SOCKET, &sock->flags);
 	retval = sock_map_fd(sock);
 	if (retval < 0)
 		goto out_release;
@@ -1126,10 +1153,12 @@ asmlinkage long sys_socketpair(int famil
 	err = sock_create(family, type, protocol, &sock1);
 	if (err < 0)
 		goto out;
+	set_bit(SOCK_USER_SOCKET, &sock1->flags);
 
 	err = sock_create(family, type, protocol, &sock2);
 	if (err < 0)
 		goto out_release_1;
+	set_bit(SOCK_USER_SOCKET, &sock2->flags);
 
 	err = sock1->ops->socketpair(sock1, sock2);
 	if (err < 0) 
diff -NurpP --minimal linux-2.6.5/net/unix/af_unix.c linux-2.6.5-vs1.9.0pre2/net/unix/af_unix.c
--- linux-2.6.5/net/unix/af_unix.c	2004-04-04 18:03:15.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/net/unix/af_unix.c	2004-04-05 00:55:18.000000000 +0200
@@ -407,6 +407,7 @@ static int unix_release_sock (struct soc
 		mntput(mnt);
 	}
 
+	put_vx_info(sk->sk_vx_info);
 	sock_put(sk);
 
 	/* ---- Socket is dead now and most probably destroyed ---- */
@@ -561,6 +562,8 @@ static struct sock * unix_create1(struct
 	sock_init_data(sock,sk);
 	sk_set_owner(sk, THIS_MODULE);
 
+	sk->sk_xid = vx_current_xid();
+	sk->sk_vx_info = get_vx_info(current->vx_info);
 	sk->sk_write_space	= unix_write_space;
 	sk->sk_max_ack_backlog	= sysctl_unix_max_dgram_qlen;
 	sk->sk_destruct		= unix_sock_destructor;
@@ -872,7 +875,7 @@ static int unix_dgram_connect(struct soc
 			goto out;
 		alen = err;
 
-		if (sock->passcred && !unix_sk(sk)->addr &&
+		if (test_bit(SOCK_PASS_CRED, &sock->flags) && !unix_sk(sk)->addr &&
 		    (err = unix_autobind(sock)) != 0)
 			goto out;
 
@@ -963,7 +966,8 @@ static int unix_stream_connect(struct so
 		goto out;
 	addr_len = err;
 
-	if (sock->passcred && !u->addr && (err = unix_autobind(sock)) != 0)
+	if (test_bit(SOCK_PASS_CRED, &sock->flags)
+		&& !u->addr && (err = unix_autobind(sock)) != 0)
 		goto out;
 
 	timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);
@@ -1297,7 +1301,8 @@ static int unix_dgram_sendmsg(struct kio
 			goto out;
 	}
 
-	if (sock->passcred && !u->addr && (err = unix_autobind(sock)) != 0)
+	if (test_bit(SOCK_PASS_CRED, &sock->flags)
+		&& !u->addr && (err = unix_autobind(sock)) != 0)
 		goto out;
 
 	err = -EMSGSIZE;
diff -NurpP --minimal linux-2.6.5/security/commoncap.c linux-2.6.5-vs1.9.0pre2/security/commoncap.c
--- linux-2.6.5/security/commoncap.c	2004-04-04 18:03:15.000000000 +0200
+++ linux-2.6.5-vs1.9.0pre2/security/commoncap.c	2004-04-05 00:55:13.000000000 +0200
@@ -126,7 +126,7 @@ void cap_bprm_compute_creds (struct linu
 	/* Derived from fs/exec.c:compute_creds. */
 	kernel_cap_t new_permitted, working;
 
-	new_permitted = cap_intersect (bprm->cap_permitted, cap_bset);
+	new_permitted = cap_intersect (bprm->cap_permitted, vx_current_bcaps());
 	working = cap_intersect (bprm->cap_inheritable,
 				 current->cap_inheritable);
 	new_permitted = cap_combine (new_permitted, working);
