diff -NurpP --minimal linux-2.4.25-rc1/Documentation/Configure.help linux-2.4.25-rc1-vs1.3.6.3/Documentation/Configure.help
--- linux-2.4.25-rc1/Documentation/Configure.help	2004-02-06 00:45:51.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/Documentation/Configure.help	2004-02-06 02:52:25.000000000 +0100
@@ -552,6 +552,11 @@ CONFIG_BLK_DEV_LOOP
 
   Most users will answer N here.
 
+Virtual Root device support
+CONFIG_BLK_DEV_VROOT
+  Saying Y here will allow you to use quota/fs ioctls on a shared
+  partition within a virtual server without compromising security.
+
 Micro Memory MM5415 Battery Backed RAM support (EXPERIMENTAL)
 CONFIG_BLK_DEV_UMEM
   Saying Y here will include support for the MM5415 family of
diff -NurpP --minimal linux-2.4.25-rc1/Makefile linux-2.4.25-rc1-vs1.3.6.3/Makefile
--- linux-2.4.25-rc1/Makefile	2004-02-06 00:45:51.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/Makefile	2004-02-06 02:53:21.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 25
-EXTRAVERSION = -rc1
+EXTRAVERSION = -rc1-vs1.3.6.3
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
diff -NurpP --minimal linux-2.4.25-rc1/arch/alpha/kernel/entry.S linux-2.4.25-rc1-vs1.3.6.3/arch/alpha/kernel/entry.S
--- linux-2.4.25-rc1/arch/alpha/kernel/entry.S	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/alpha/kernel/entry.S	2004-02-06 02:52:25.000000000 +0100
@@ -1044,7 +1044,7 @@ sys_call_table:
 	.quad alpha_ni_syscall			/* 270 */
 	.quad alpha_ni_syscall
 	.quad alpha_ni_syscall
-	.quad alpha_ni_syscall
+	.quad sys_vserver			/* 273 sys_vserver */
 	.quad alpha_ni_syscall
 	.quad alpha_ni_syscall			/* 275 */
 	.quad alpha_ni_syscall
diff -NurpP --minimal linux-2.4.25-rc1/arch/alpha/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/alpha/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/alpha/kernel/ptrace.c	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/alpha/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -6,6 +6,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -273,7 +274,7 @@ sys_ptrace(long request, long pid, long 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out_notsk;
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
diff -NurpP --minimal linux-2.4.25-rc1/arch/i386/kernel/entry.S linux-2.4.25-rc1-vs1.3.6.3/arch/i386/kernel/entry.S
--- linux-2.4.25-rc1/arch/i386/kernel/entry.S	2003-06-13 16:51:29.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/i386/kernel/entry.S	2004-02-06 02:52:25.000000000 +0100
@@ -659,10 +659,25 @@ ENTRY(sys_call_table)
 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_exit_group */
 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_lookup_dcookie */
 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_epoll_create */
-	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_epoll_ctl 255 */
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 255 sys_epoll_ctl */
 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_epoll_wait */
  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_remap_file_pages */
  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_set_tid_address */
+	.long SYMBOL_NAME(sys_ni_syscall)	
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 260 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 265 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 270 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_vserver)		/* 273 sys_vserver */
 
 	.rept NR_syscalls-(.-sys_call_table)/4
 		.long SYMBOL_NAME(sys_ni_syscall)
diff -NurpP --minimal linux-2.4.25-rc1/arch/i386/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/i386/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/i386/kernel/ptrace.c	2002-08-03 02:39:42.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/i386/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -7,6 +7,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -170,7 +171,7 @@ asmlinkage int sys_ptrace(long request, 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/ia64/ia32/binfmt_elf32.c linux-2.4.25-rc1-vs1.3.6.3/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.4.25-rc1/arch/ia64/ia32/binfmt_elf32.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ia64/ia32/binfmt_elf32.c	2004-02-06 02:52:25.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/config.h>
 
 #include <linux/types.h>
+#include <linux/vserver.h>
 
 #include <asm/param.h>
 #include <asm/signal.h>
@@ -187,7 +188,8 @@ ia32_setup_arg_pages (struct linux_binpr
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = 0;
 		insert_vm_struct(current->mm, mpnt);
-		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(current->mm, current->mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	}
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.4.25-rc1/arch/ia64/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/ia64/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/ia64/kernel/ptrace.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ia64/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/errno.h>
@@ -1267,7 +1268,7 @@ sys_ptrace (long request, pid_t pid, uns
 			get_task_struct(child);
 	}
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 	ret = -EPERM;
 	if (pid == 1)		/* no messing around with init! */
diff -NurpP --minimal linux-2.4.25-rc1/arch/ia64/mm/fault.c linux-2.4.25-rc1-vs1.3.6.3/arch/ia64/mm/fault.c
--- linux-2.4.25-rc1/arch/ia64/mm/fault.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ia64/mm/fault.c	2004-02-06 02:52:25.000000000 +0100
@@ -36,10 +36,12 @@ expand_backing_store (struct vm_area_str
 	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur
 	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur))
 		return -ENOMEM;
+	if (!vx_vmpages_avail(vma->vm_mm, grow)
+		return -ENOMEM;
 	vma->vm_end += PAGE_SIZE;
-	vma->vm_mm->total_vm += grow;
+	vx_vmpages_add(vma->vm_mm, grow);
 	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
+		vx_vmlocked_add(vma->vm_mm, grow);
 	return 0;
 }
 
diff -NurpP --minimal linux-2.4.25-rc1/arch/m68k/atari/stram.c linux-2.4.25-rc1-vs1.3.6.3/arch/m68k/atari/stram.c
--- linux-2.4.25-rc1/arch/m68k/atari/stram.c	2003-06-13 16:51:31.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/m68k/atari/stram.c	2004-02-06 02:52:25.000000000 +0100
@@ -642,7 +642,7 @@ static inline void unswap_pte(struct vm_
 	set_pte(dir, pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
 	swap_free(entry);
 	get_page(page);
-	++vma->vm_mm->rss;
+	vx_rsspages_inc(vma->vm_mm);
 }
 
 static inline void unswap_pmd(struct vm_area_struct * vma, pmd_t *dir,
diff -NurpP --minimal linux-2.4.25-rc1/arch/m68k/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/m68k/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/m68k/kernel/ptrace.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/m68k/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -12,6 +12,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -122,7 +123,7 @@ asmlinkage int sys_ptrace(long request, 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/mips/kernel/irixelf.c linux-2.4.25-rc1-vs1.3.6.3/arch/mips/kernel/irixelf.c
--- linux-2.4.25-rc1/arch/mips/kernel/irixelf.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/mips/kernel/irixelf.c	2004-02-06 02:52:25.000000000 +0100
@@ -689,7 +689,7 @@ static int load_irix_binary(struct linux
 	/* Do this so that we can load the interpreter, if need be.  We will
 	 * change some of these later.
 	 */
-	current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	setup_arg_pages(bprm);
 	current->mm->start_stack = bprm->p;
 
diff -NurpP --minimal linux-2.4.25-rc1/arch/mips/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/mips/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/mips/kernel/ptrace.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/mips/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -13,6 +13,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/ptrace.h>
@@ -67,7 +68,7 @@ asmlinkage int sys_ptrace(long request, 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/mips64/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/mips64/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/mips64/kernel/ptrace.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/mips64/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/ptrace.h>
@@ -311,7 +312,7 @@ asmlinkage int sys_ptrace(long request, 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/parisc/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/parisc/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/parisc/kernel/ptrace.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/parisc/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -8,6 +8,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -113,7 +114,7 @@ long sys_ptrace(long request, pid_t pid,
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 	ret = -EPERM;
 	if (pid == 1)		/* no messing around with init! */
diff -NurpP --minimal linux-2.4.25-rc1/arch/parisc/kernel/sys_parisc32.c linux-2.4.25-rc1-vs1.3.6.3/arch/parisc/kernel/sys_parisc32.c
--- linux-2.4.25-rc1/arch/parisc/kernel/sys_parisc32.c	2003-06-13 16:51:31.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/parisc/kernel/sys_parisc32.c	2004-02-06 02:52:25.000000000 +0100
@@ -3046,13 +3046,18 @@ asmlinkage int sys32_sysinfo(struct sysi
 	 */
 
 	cli();
-	val.uptime = jiffies / HZ;
+	if (vx_check(0, VX_ADMIN|VX_WATCH)) {
+		val.uptime = jiffies / HZ;
+		val.procs = nr_threads-1;
+	} else {
+		struct vx_info *vxi = current->vx_info;
+		val.uptime = (jiffies - vxi->bias_jiffies) / HZ;
+		val.procs = vxi->nr_threads;
+	}
 
 	val.loads[0] = avenrun[0] << (SI_LOAD_SHIFT - FSHIFT);
 	val.loads[1] = avenrun[1] << (SI_LOAD_SHIFT - FSHIFT);
 	val.loads[2] = avenrun[2] << (SI_LOAD_SHIFT - FSHIFT);
-
-	val.procs = nr_threads-1;
 	sti();
 
 	si_meminfo(&val);
diff -NurpP --minimal linux-2.4.25-rc1/arch/parisc/kernel/syscall.S linux-2.4.25-rc1-vs1.3.6.3/arch/parisc/kernel/syscall.S
--- linux-2.4.25-rc1/arch/parisc/kernel/syscall.S	2003-06-13 16:51:31.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/parisc/kernel/syscall.S	2004-02-06 02:52:25.000000000 +0100
@@ -605,6 +605,71 @@ sys_call_table:
 	ENTRY_SAME(gettid)             
 	ENTRY_SAME(readahead)          
 	ENTRY_SAME(tkill)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 210 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 215 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 220 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 225 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 230 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 235 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 240 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 245 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 250 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 255 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 260 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 265 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)	       /* 270 */
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(ni_syscall)
+	ENTRY_SAME(vserver)	       /* 273 sys_vserver */
 
 .end
 
diff -NurpP --minimal linux-2.4.25-rc1/arch/ppc/kernel/misc.S linux-2.4.25-rc1-vs1.3.6.3/arch/ppc/kernel/misc.S
--- linux-2.4.25-rc1/arch/ppc/kernel/misc.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ppc/kernel/misc.S	2004-02-06 02:52:25.000000000 +0100
@@ -1298,6 +1298,30 @@ _GLOBAL(sys_call_table)
 	.long sys_ni_syscall	/*	reserved for sys_clock_getres */
 	.long sys_ni_syscall	/*	reserved for sys_clock_nanosleep */
 	.long sys_swapcontext
+	.long sys_ni_syscall	/* 250 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 255 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 260 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 265 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 270 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_vserver	/* 273 sys_vserver */
 
 	.rept NR_syscalls-(.-sys_call_table)/4
 		.long sys_ni_syscall
diff -NurpP --minimal linux-2.4.25-rc1/arch/ppc/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/ppc/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/ppc/kernel/ptrace.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ppc/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -18,6 +18,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -188,7 +189,7 @@ int sys_ptrace(long request, long pid, l
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/ppc64/kernel/misc.S linux-2.4.25-rc1-vs1.3.6.3/arch/ppc64/kernel/misc.S
--- linux-2.4.25-rc1/arch/ppc64/kernel/misc.S	2004-02-06 00:45:52.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ppc64/kernel/misc.S	2004-02-06 02:52:25.000000000 +0100
@@ -807,24 +807,74 @@ _GLOBAL(sys_call_table32)
 	.llong .sys_madvise		/* 205 */
 	.llong .sys_mincore		/* 206 */
 	.llong .sys_gettid		/* 207 */
-#if 0 /* Reserved syscalls */
-	.llong .sys_tkill		/* 208 */
-	.llong .sys_setxattr
-	.llong .sys_lsetxattr	/* 210 */
-	.llong .sys_fsetxattr
-	.llong .sys_getxattr
-	.llong .sys_lgetxattr
-	.llong .sys_fgetxattr
-	.llong .sys_listxattr	/* 215 */
-	.llong .sys_llistxattr
-	.llong .sys_flistxattr
-	.llong .sys_removexattr
-	.llong .sys_lremovexattr
-	.llong .sys_fremovexattr	/* 220 */
-	.llong .sys_futex
-#endif
-	.llong .sys_perfmonctl   /* Put this here for now ... */
-	.rept NR_syscalls-222
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 210 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 215 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 220 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 225 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 230 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 235 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 240 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 245 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 250 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 255 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 260 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 265 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 270 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_vserver		/* 273 sys_vserver */
+
+	.rept NR_syscalls-273
 		.llong .sys_ni_syscall
 	.endr
 #endif
@@ -1038,23 +1088,73 @@ _GLOBAL(sys_call_table)
 	.llong .sys_madvise		/* 205 */
 	.llong .sys_mincore		/* 206 */
 	.llong .sys_gettid		/* 207 */
-#if 0 /* Reserved syscalls */
-	.llong .sys_tkill		/* 208 */
-	.llong .sys_setxattr
-	.llong .sys_lsetxattr	/* 210 */
-	.llong .sys_fsetxattr
-	.llong .sys_getxattr
-	.llong .sys_lgetxattr
-	.llong .sys_fgetxattr
-	.llong .sys_listxattr	/* 215 */
-	.llong .sys_llistxattr
-	.llong .sys_flistxattr
-	.llong .sys_removexattr
-	.llong .sys_lremovexattr
-	.llong .sys_fremovexattr	/* 220 */
-	.llong .sys_futex
-#endif
-	.llong .sys_perfmonctl   /* Put this here for now ... */
-	.rept NR_syscalls-222
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 210 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 215 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 220 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 225 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 230 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 235 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 240 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 245 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 250 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 255 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 260 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 265 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall		/* 270 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_vserver		/* 273 sys_vserver */
+
+	.rept NR_syscalls-273
 	.llong .sys_ni_syscall
 	.endr
diff -NurpP --minimal linux-2.4.25-rc1/arch/ppc64/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/ppc64/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/ppc64/kernel/ptrace.c	2004-02-06 00:45:52.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/ppc64/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -19,6 +19,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -137,7 +138,7 @@ int sys_ptrace(long request, long pid, l
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/s390/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/s390/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/s390/kernel/ptrace.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/s390/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -24,6 +24,7 @@
 #include <stddef.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -239,7 +240,7 @@ asmlinkage int sys_ptrace(long request, 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.4.25-rc1/arch/s390x/kernel/exec32.c linux-2.4.25-rc1-vs1.3.6.3/arch/s390x/kernel/exec32.c
--- linux-2.4.25-rc1/arch/s390x/kernel/exec32.c	2001-04-12 04:02:29.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/s390x/kernel/exec32.c	2004-02-06 02:52:25.000000000 +0100
@@ -31,6 +31,7 @@
 #include <linux/kmod.h>
 #endif
 
+#include <linux/vinline.h>
 
 extern void put_dirty_page(struct task_struct * tsk, struct page *page, unsigned long address);
 
@@ -66,7 +67,8 @@ int setup_arg_pages32(struct linux_binpr
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = (void *) 0;
 		insert_vm_struct(current->mm, mpnt);
-		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(current->mm, current->mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	} 
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
diff -NurpP --minimal linux-2.4.25-rc1/arch/s390x/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/s390x/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/s390x/kernel/ptrace.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/s390x/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -25,6 +25,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -448,7 +449,7 @@ asmlinkage int sys_ptrace(long request, 
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 	ret = -EPERM;
 	if (pid == 1)		/* you may not mess with init */
diff -NurpP --minimal linux-2.4.25-rc1/arch/sparc/kernel/systbls.S linux-2.4.25-rc1-vs1.3.6.3/arch/sparc/kernel/systbls.S
--- linux-2.4.25-rc1/arch/sparc/kernel/systbls.S	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/sparc/kernel/systbls.S	2004-02-06 02:52:25.000000000 +0100
@@ -70,7 +70,10 @@ sys_call_table:
 /*240*/	.long sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 /*245*/	.long sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
-/*255*/	.long sys_nis_syscall, sys_nis_syscall
+/*255*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*260*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*265*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*270*/	.long sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_vserver, sys_nis_syscall
 
 #ifdef CONFIG_SUNOS_EMUL
 	/* Now the SunOS syscall table. */
diff -NurpP --minimal linux-2.4.25-rc1/arch/sparc64/kernel/binfmt_aout32.c linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/binfmt_aout32.c
--- linux-2.4.25-rc1/arch/sparc64/kernel/binfmt_aout32.c	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/binfmt_aout32.c	2004-02-06 02:52:25.000000000 +0100
@@ -239,7 +239,7 @@ static int load_aout32_binary(struct lin
 	current->mm->brk = ex.a_bss +
 		(current->mm->start_brk = N_BSSADDR(ex));
 
-	current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
diff -NurpP --minimal linux-2.4.25-rc1/arch/sparc64/kernel/entry.S linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/entry.S
--- linux-2.4.25-rc1/arch/sparc64/kernel/entry.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/entry.S	2004-02-06 02:52:25.000000000 +0100
@@ -26,7 +26,7 @@
 
 #define curptr      g6
 
-#define NR_SYSCALLS 256      /* Each OS is different... */
+#define NR_SYSCALLS 274      /* Each OS is different... */
 
 	.text
 	.align		32
diff -NurpP --minimal linux-2.4.25-rc1/arch/sparc64/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/sparc64/kernel/ptrace.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -12,6 +12,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/ptrace.h>
@@ -156,7 +157,7 @@ asmlinkage void do_ptrace(struct pt_regs
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
 
-	if (!child) {
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT)) {
 		pt_error_return(regs, ESRCH);
 		goto out;
 	}
diff -NurpP --minimal linux-2.4.25-rc1/arch/sparc64/kernel/systbls.S linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/systbls.S
--- linux-2.4.25-rc1/arch/sparc64/kernel/systbls.S	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/sparc64/kernel/systbls.S	2004-02-06 02:52:25.000000000 +0100
@@ -70,7 +70,10 @@ sys_call_table32:
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys32_sched_rr_get_interval, sys32_nanosleep
 /*250*/	.word sys32_mremap, sys32_sysctl, sys_getsid, sys_fdatasync, sys32_nfsservctl
-	.word sys_aplib
+	.word sys_aplib, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*260*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*270*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_vserver, sys_nis_syscall
 
 	/* Now the 64-bit native Linux syscall table. */
 
@@ -129,7 +132,10 @@ sys_call_table:
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.word sys64_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
-	.word sys_aplib
+	.word sys_aplib, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*260*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_nis_syscall
+/*270*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_vserver, sys_nis_syscall
 
 #if defined(CONFIG_SUNOS_EMUL) || defined(CONFIG_SOLARIS_EMUL) || \
     defined(CONFIG_SOLARIS_EMUL_MODULE)
@@ -225,5 +231,12 @@ sunos_sys_table:
 	.word sunos_nosys, sunos_nosys
 /*250*/	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sys_aplib
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys
 
 #endif
diff -NurpP --minimal linux-2.4.25-rc1/arch/x86_64/ia32/ia32_binfmt.c linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.4.25-rc1/arch/x86_64/ia32/ia32_binfmt.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/ia32/ia32_binfmt.c	2004-02-06 02:52:25.000000000 +0100
@@ -13,6 +13,7 @@
 #include <linux/sched.h>
 #include <linux/string.h>
 #include <linux/personality.h>
+#include <linux/vinline.h>
 #include <asm/segment.h> 
 #include <asm/ptrace.h>
 #include <asm/processor.h>
@@ -251,14 +252,15 @@ int ia32_setup_arg_pages(struct linux_bi
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = (void *) 0;
 		insert_vm_struct(current->mm, mpnt);
-		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_sub(current->mm, current->mm->total_vm -
+			((mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT));
 	} 
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
 		struct page *page = bprm->page[i];
 		if (page) {
 			bprm->page[i] = NULL;
-			current->mm->rss++;
+			vx_rsspages_inc(current->mm);
 			put_dirty_page(current,page,stack_base);
 		}
 		stack_base += PAGE_SIZE;
diff -NurpP --minimal linux-2.4.25-rc1/arch/x86_64/ia32/ia32entry.S linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/ia32/ia32entry.S
--- linux-2.4.25-rc1/arch/x86_64/ia32/ia32entry.S	2004-02-06 00:45:52.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/ia32/ia32entry.S	2004-02-06 02:52:25.000000000 +0100
@@ -369,9 +369,41 @@ ia32_sys_call_table:
 	.quad quiet_ni_syscall  /* fremovexattr - 237 */
 	.quad sys_tkill
 	.quad sys_sendfile64
-	.quad quiet_ni_syscall  /* futex */
+	.quad quiet_ni_syscall  /* 240 futex */
 	.quad quiet_ni_syscall  /* sched_setaffinity */
 	.quad quiet_ni_syscall  /* sched_getaffinity */	
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall  /* 245 */
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall  /* 250 */
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall  /* 255 */
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall  /* 260 */
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall  /* 265 */
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall  /* 270 */
+	.quad quiet_ni_syscall
+	.quad quiet_ni_syscall
+	.quad sys_vserver	/* 273 sys_vserver */
+
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
 		.quad ni_syscall
diff -NurpP --minimal linux-2.4.25-rc1/arch/x86_64/kernel/ptrace.c linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/kernel/ptrace.c
--- linux-2.4.25-rc1/arch/x86_64/kernel/ptrace.c	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/kernel/ptrace.c	2004-02-06 02:52:25.000000000 +0100
@@ -9,6 +9,7 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -194,7 +195,7 @@ asmlinkage long sys_ptrace(long request,
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (!child || !vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
 		goto out;
 
 	ret = -EPERM;
diff -NurpP --minimal linux-2.4.25-rc1/arch/x86_64/kernel/sys_x86_64.c linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.4.25-rc1/arch/x86_64/kernel/sys_x86_64.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/arch/x86_64/kernel/sys_x86_64.c	2004-02-06 02:52:25.000000000 +0100
@@ -108,8 +108,16 @@ unsigned long arch_get_unmapped_area(str
 asmlinkage long sys_uname(struct new_utsname * name)
 {
 	int err;
+	struct new_utsname tmp, *pttmp;
+
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	if (current->vx_info) {
+		tmp = current->vx_info->virt.utsname;
+		pttmp = &tmp;
+	}
+	else
+		pttmp = &system_utsname;
+	err=copy_to_user(name, pttmp, sizeof (*name));
 	up_read(&uts_sem);
 	if (personality(current->personality) == PER_LINUX32)
 		err = copy_to_user(name->machine, "i686", 5);
diff -NurpP --minimal linux-2.4.25-rc1/drivers/block/Config.in linux-2.4.25-rc1-vs1.3.6.3/drivers/block/Config.in
--- linux-2.4.25-rc1/drivers/block/Config.in	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/drivers/block/Config.in	2004-02-06 02:52:25.000000000 +0100
@@ -41,6 +41,7 @@ dep_tristate 'Mylex DAC960/DAC1100 PCI R
 dep_tristate 'Micro Memory MM5415 Battery Backed RAM support (EXPERIMENTAL)' CONFIG_BLK_DEV_UMEM $CONFIG_PCI $CONFIG_EXPERIMENTAL
 
 tristate 'Loopback device support' CONFIG_BLK_DEV_LOOP
+tristate 'Virtual Root device support' CONFIG_BLK_DEV_VROOT
 dep_tristate 'Network block device support' CONFIG_BLK_DEV_NBD $CONFIG_NET
 
 tristate 'RAM disk support' CONFIG_BLK_DEV_RAM
diff -NurpP --minimal linux-2.4.25-rc1/drivers/block/Makefile linux-2.4.25-rc1-vs1.3.6.3/drivers/block/Makefile
--- linux-2.4.25-rc1/drivers/block/Makefile	2003-06-13 16:51:32.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/drivers/block/Makefile	2004-02-06 02:52:25.000000000 +0100
@@ -31,6 +31,7 @@ obj-$(CONFIG_BLK_CPQ_CISS_DA)  += cciss.
 obj-$(CONFIG_BLK_DEV_DAC960)	+= DAC960.o
 obj-$(CONFIG_BLK_DEV_UMEM)	+= umem.o
 obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
+obj-$(CONFIG_BLK_DEV_VROOT)	+= vroot.o
 
 subdir-$(CONFIG_PARIDE) += paride
 
diff -NurpP --minimal linux-2.4.25-rc1/drivers/block/vroot.c linux-2.4.25-rc1-vs1.3.6.3/drivers/block/vroot.c
--- linux-2.4.25-rc1/drivers/block/vroot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/drivers/block/vroot.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,329 @@
+/*
+ *  linux/drivers/block/vroot.c
+ *
+ *  Written by Herbert Pötzl, 9/11/2002
+ *
+ *  based on the loop.c code by Theodore Ts'o.
+ *
+ * Copyright 2002-2004 by Herbert Pötzl.
+ * Redistribution of this file is permitted under the
+ * GNU General Public License.
+ *
+ */
+
+#define MAJOR_NR VROOT_MAJOR
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/wait.h>
+#include <linux/blk.h>
+#include <linux/blkpg.h>
+#include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/smp_lock.h>
+#include <linux/swap.h>
+#include <linux/slab.h>
+
+#include <asm/uaccess.h>
+
+#include "vroot.h"
+
+static int max_vroot = MAX_VROOT_DEFAULT;
+static struct vroot_device *vroot_dev;
+static devfs_handle_t devfs_handle;      /*  For the directory */
+
+#ifdef	MODULE
+typedef	kdev_t	(*vroot_get_dev_f)(int dev);
+
+extern int register_vroot_get_dev(vroot_get_dev_f);
+extern int unregister_vroot_get_dev(vroot_get_dev_f);
+
+static	kdev_t _vroot_get_dev(int dev)
+#else
+	kdev_t vroot_get_dev(int dev)
+#endif
+{
+	struct vroot_device *vr;
+
+	if (dev >= max_vroot)
+		return NODEV;
+
+	vr = &vroot_dev[dev];
+	if (vr->vr_state != Vr_bound)
+		return NODEV;
+	dprintk(KERN_INFO "vroot[%d]_get_dev: dev(%d,%d)\n",
+		dev, MAJOR(vr->vr_device), MINOR(vr->vr_device));
+	return vr->vr_device;
+}
+
+static int vroot_set_dev(
+	struct vroot_device *vr,
+	struct file *vr_file,
+	kdev_t dev,
+	unsigned int arg)
+{
+	struct file	*file;
+	struct inode	*inode;
+	int		error;
+
+	MOD_INC_USE_COUNT;
+
+	error = -EBUSY;
+	if (vr->vr_state != Vr_unbound)
+		goto out;
+
+	error = -EBADF;
+	file = fget(arg);
+	if (!file)
+		goto out;
+		
+	error = -EINVAL;
+	inode = file->f_dentry->d_inode;
+
+	if (S_ISBLK(inode->i_mode)) {
+		vr->vr_device = inode->i_rdev;
+		if (vr->vr_device == dev) {
+			error = -EBUSY;
+			goto out_fput;
+		}
+	} else
+		goto out_fput;
+		
+	dprintk(KERN_INFO "vroot[%d]_set_dev: dev(%d,%d)\n",
+		vr->vr_number,
+		MAJOR(inode->i_rdev), MINOR(inode->i_rdev));
+
+	vr->vr_state = Vr_bound;
+	fput(file);
+	return 0;
+ out_fput:
+	fput(file);
+ out:
+	MOD_DEC_USE_COUNT;
+	return error;
+}
+
+static int vroot_clr_dev(
+	struct vroot_device *vr,
+	struct file *vr_file,
+	kdev_t dev)
+{
+	if (vr->vr_state != Vr_bound)
+		return -ENXIO;
+	if (vr->vr_refcnt > 1)	/* we needed one fd for the ioctl */
+		return -EBUSY;
+
+	dprintk(KERN_INFO "vroot[%d]_clr_dev: dev(%d,%d)\n",
+		vr->vr_number,
+		MAJOR(vr->vr_device), MINOR(vr->vr_device));
+
+	vr->vr_state = Vr_unbound;
+	vr->vr_device = NODEV;
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static int vroot_make_request(
+	request_queue_t *q,
+	int rw,
+	struct buffer_head *rbh)
+{
+	if (!buffer_locked(rbh))
+		BUG();
+
+	if (MINOR(rbh->b_rdev) >= max_vroot)
+		goto out;
+
+	dprintk(KERN_WARNING "vroot[%d]_make_request: denied.\n",
+		MINOR(rbh->b_rdev));	
+ out:
+	buffer_IO_error(rbh);
+	return 0;
+}
+
+static int vr_ioctl(
+	struct inode * inode,
+	struct file * file,
+	unsigned int cmd,
+	unsigned long arg)
+{
+	struct vroot_device *vr;
+	int dev, err;
+
+	if (!inode)
+		return -EINVAL;
+	if (MAJOR(inode->i_rdev) != MAJOR_NR) {
+		dprintk(KERN_WARNING "vr_ioctl: pseudo-major != %d\n",
+		       MAJOR_NR);
+		return -ENODEV;
+	}
+	dev = MINOR(inode->i_rdev);
+	if (dev >= max_vroot)
+		return -ENODEV;
+	vr = &vroot_dev[dev];
+	down(&vr->vr_ctl_mutex);
+	switch (cmd) {
+	case VROOT_SET_DEV:
+		err = vroot_set_dev(vr, file, inode->i_rdev, arg);
+		break;
+	case VROOT_CLR_DEV:
+		err = vroot_clr_dev(vr, file, inode->i_rdev);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	up(&vr->vr_ctl_mutex);
+	return err;
+}
+
+static int vr_open(
+	struct inode *inode,
+	struct file *file)
+{
+	struct vroot_device *vr;
+	int	dev;
+
+	if (!inode)
+		return -EINVAL;
+	if (MAJOR(inode->i_rdev) != MAJOR_NR) {
+		dprintk(KERN_WARNING "vr_open: pseudo-major != %d\n", MAJOR_NR);
+		return -ENODEV;
+	}
+	dev = MINOR(inode->i_rdev);
+	if (dev >= max_vroot)
+		return -ENODEV;
+
+	vr = &vroot_dev[dev];
+	MOD_INC_USE_COUNT;
+	down(&vr->vr_ctl_mutex);
+
+	vr->vr_refcnt++;
+	up(&vr->vr_ctl_mutex);
+	return 0;
+}
+
+static int vr_release(
+	struct inode *inode,
+	struct file *file)
+{
+	struct vroot_device *vr;
+	int	dev;
+
+	if (!inode)
+		return 0;
+	if (MAJOR(inode->i_rdev) != MAJOR_NR) {
+		dprintk(KERN_WARNING "vr_release: pseudo-major != %d\n",
+		       MAJOR_NR);
+		return 0;
+	}
+	dev = MINOR(inode->i_rdev);
+	if (dev >= max_vroot)
+		return 0;
+
+	vr = &vroot_dev[dev];
+	down(&vr->vr_ctl_mutex);
+
+	vr->vr_refcnt--;
+	up(&vr->vr_ctl_mutex);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static struct block_device_operations vr_fops = {
+	owner:		THIS_MODULE,
+	open:		vr_open,
+	release:	vr_release,
+	ioctl:		vr_ioctl,
+};
+
+/*
+ * And now the modules code and kernel interface.
+ */
+MODULE_PARM(max_vroot, "i");
+MODULE_PARM_DESC(max_vroot, "Maximum number of vroot devices (1-256)");
+MODULE_LICENSE("GPL");
+
+MODULE_AUTHOR ("Herbert Pötzl");
+MODULE_DESCRIPTION ("Virtual Root Device Mapper");
+
+
+int __init vroot_init(void)
+{
+	int	i;
+
+	if ((max_vroot < 1) || (max_vroot > 256)) {
+		printk(KERN_WARNING "vroot: invalid max_vroot (must be between"
+				    " 1 and 256), using default (%d)\n",
+				    MAX_VROOT_DEFAULT);
+		max_vroot = MAX_VROOT_DEFAULT;
+	}
+
+	if (devfs_register_blkdev(MAJOR_NR, "vroot", &vr_fops)) {
+		printk(KERN_WARNING "Unable to get major number %d for vroot"
+				    " device\n", MAJOR_NR);
+		return -EIO;
+	}
+
+	devfs_handle = devfs_mk_dir(NULL, "vroot", NULL);
+	devfs_register_series(devfs_handle, "%u", max_vroot,
+			      DEVFS_FL_DEFAULT, MAJOR_NR, 0,
+			      S_IFBLK | S_IRUSR | S_IWUSR | S_IRGRP,
+			      &vr_fops, NULL);
+
+	vroot_dev = kmalloc(max_vroot * sizeof(struct vroot_device), GFP_KERNEL);
+	if (!vroot_dev)
+		return -ENOMEM;
+
+	blk_queue_make_request(BLK_DEFAULT_QUEUE(MAJOR_NR), vroot_make_request);
+
+	for (i = 0; i < max_vroot; i++) {
+		struct vroot_device *vr = &vroot_dev[i];
+		memset(vr, 0, sizeof(struct vroot_device));
+		init_MUTEX(&vr->vr_ctl_mutex);
+		vr->vr_number = i;
+		vr->vr_state = Vr_unbound;
+	}
+
+	for (i = 0; i < max_vroot; i++)
+		register_disk(NULL, MKDEV(MAJOR_NR, i), 1, &vr_fops, 0);
+
+#ifdef	MODULE
+	register_vroot_get_dev(_vroot_get_dev);
+#endif
+	printk(KERN_INFO "vroot: loaded (max %d devices)\n", max_vroot);
+	return 0;
+}
+
+void vroot_exit(void)
+{
+#ifdef	MODULE
+	unregister_vroot_get_dev(_vroot_get_dev);
+#endif	
+	devfs_unregister(devfs_handle);
+	if (devfs_unregister_blkdev(MAJOR_NR, "vroot"))
+		printk(KERN_WARNING "vroot: cannot unregister blkdev\n");
+
+	kfree(vroot_dev);
+}
+
+module_init(vroot_init);
+module_exit(vroot_exit);
+
+#ifndef MODULE
+static int __init max_vroot_setup(char *str)
+{
+	max_vroot = simple_strtol(str, NULL, 0);
+	return 1;
+}
+
+__setup("max_vroot=", max_vroot_setup);
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/drivers/block/vroot.h linux-2.4.25-rc1-vs1.3.6.3/drivers/block/vroot.h
--- linux-2.4.25-rc1/drivers/block/vroot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/drivers/block/vroot.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,46 @@
+#ifndef _LINUX_VROOT_H
+#define _LINUX_VROOT_H
+
+#include <linux/kdev_t.h>
+
+/*
+ * linux/drivers/block/vroot.h
+ *
+ * Written by Herbert Pötzl, 9/11/2002
+ *
+ * Copyright 2002-2003 by Herbert Pötzl.
+ * Redistribution of this file is permitted under the
+ * GNU General Public License.
+ */
+
+#ifdef __KERNEL__
+
+/* Possible states of device */
+enum {
+	Vr_unbound,
+	Vr_bound,
+};
+
+struct vroot_device {
+	int		vr_number;
+	int		vr_refcnt;
+
+	struct semaphore	vr_ctl_mutex;
+	kdev_t			vr_device;
+	int			vr_state;
+};
+
+#define dprintk(...)    /* printk(__VA_ARGS__) */
+
+#endif /* __KERNEL__ */
+
+#define MAX_VROOT_DEFAULT	8
+
+/*
+ * IOCTL commands --- we will commandeer 0x56 ('V')
+ */
+
+#define VROOT_SET_DEV		0x5600
+#define VROOT_CLR_DEV		0x5601
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/fs/Makefile linux-2.4.25-rc1-vs1.3.6.3/fs/Makefile
--- linux-2.4.25-rc1/fs/Makefile	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/Makefile	2004-02-06 02:52:25.000000000 +0100
@@ -7,7 +7,7 @@
 
 O_TARGET := fs.o
 
-export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o
+export-objs :=	filesystems.o open.o dcache.o buffer.o dquot.o quota.o
 mod-subdirs :=	nls xfs
 
 obj-y :=	open.o read_write.o devices.o file_table.o buffer.o \
diff -NurpP --minimal linux-2.4.25-rc1/fs/binfmt_aout.c linux-2.4.25-rc1-vs1.3.6.3/fs/binfmt_aout.c
--- linux-2.4.25-rc1/fs/binfmt_aout.c	2001-11-03 02:39:20.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/binfmt_aout.c	2004-02-06 02:52:25.000000000 +0100
@@ -303,7 +303,7 @@ static int load_aout_binary(struct linux
 	current->mm->brk = ex.a_bss +
 		(current->mm->start_brk = N_BSSADDR(ex));
 
-	current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	current->mm->mmap = NULL;
 	compute_creds(bprm);
  	current->flags &= ~PF_FORKNOEXEC;
diff -NurpP --minimal linux-2.4.25-rc1/fs/binfmt_elf.c linux-2.4.25-rc1-vs1.3.6.3/fs/binfmt_elf.c
--- linux-2.4.25-rc1/fs/binfmt_elf.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/binfmt_elf.c	2004-02-06 02:52:25.000000000 +0100
@@ -627,7 +627,7 @@ static int load_elf_binary(struct linux_
 
 	/* Do this so that we can load the interpreter, if need be.  We will
 	   change some of these later */
-	current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 	retval = setup_arg_pages(bprm);
 	if (retval < 0) {
 		send_sig(SIGKILL, current, 0);
diff -NurpP --minimal linux-2.4.25-rc1/fs/binfmt_som.c linux-2.4.25-rc1-vs1.3.6.3/fs/binfmt_som.c
--- linux-2.4.25-rc1/fs/binfmt_som.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/binfmt_som.c	2004-02-06 02:52:25.000000000 +0100
@@ -255,7 +255,7 @@ do_load_som_binary(struct linux_binprm *
 	create_som_tables(bprm);
 
 	current->mm->start_stack = bprm->p;
-	current->mm->rss = 0;
+	vx_rsspages_sub(current->mm, current->mm->rss);
 
 #if 0
 	printk("(start_brk) %08lx\n" , (unsigned long) current->mm->start_brk);
diff -NurpP --minimal linux-2.4.25-rc1/fs/devpts/inode.c linux-2.4.25-rc1-vs1.3.6.3/fs/devpts/inode.c
--- linux-2.4.25-rc1/fs/devpts/inode.c	2001-10-25 09:02:26.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/devpts/inode.c	2004-02-06 02:52:25.000000000 +0100
@@ -22,6 +22,7 @@
 #include <linux/slab.h>
 #include <linux/stat.h>
 #include <linux/tty.h>
+#include <linux/vinline.h>
 #include <asm/bitops.h>
 #include <asm/uaccess.h>
 
@@ -180,6 +181,18 @@ static int devpts_statfs(struct super_bl
 
 static DECLARE_FSTYPE(devpts_fs_type, "devpts", devpts_read_super, FS_SINGLE);
 
+static int devpts_tty_permission(struct inode *inode, int mask)
+{
+	int ret = -EACCES;
+	if (vx_check(inode->u.devpts_i.xid, VX_IDENT))
+		ret = vfs_permission(inode, mask);
+	return ret;
+}
+
+struct inode_operations devpts_tty_inode_operations = {
+	permission:	devpts_tty_permission,
+};
+
 void devpts_pty_new(int number, kdev_t device)
 {
 	struct super_block *sb = devpts_mnt->mnt_sb;
@@ -198,6 +211,8 @@ void devpts_pty_new(int number, kdev_t d
 	inode->i_uid = sbi->setuid ? sbi->uid : current->fsuid;
 	inode->i_gid = sbi->setgid ? sbi->gid : current->fsgid;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+	inode->u.devpts_i.xid = vx_current_xid();
+	inode->i_op = &devpts_tty_inode_operations;
 	init_special_inode(inode, S_IFCHR|sbi->mode, kdev_t_to_nr(device));
 
 	if ( sbi->inodes[number] ) {
diff -NurpP --minimal linux-2.4.25-rc1/fs/devpts/root.c linux-2.4.25-rc1-vs1.3.6.3/fs/devpts/root.c
--- linux-2.4.25-rc1/fs/devpts/root.c	2001-12-21 18:41:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/devpts/root.c	2004-02-06 02:52:25.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/stat.h>
 #include <linux/param.h>
 #include <linux/string.h>
+#include <linux/vinline.h>
 #include "devpts_i.h"
 
 static int devpts_root_readdir(struct file *,void *,filldir_t);
@@ -64,11 +65,14 @@ static int devpts_root_readdir(struct fi
 	default:
 		while ( nr - 2 < sbi->max_ptys ) {
 			int ptynr = nr - 2;
-			if ( sbi->inodes[ptynr] ) {
-				genptsname(numbuf, ptynr);
-				if ( filldir(dirent, numbuf, strlen(numbuf), nr, nr, DT_CHR) < 0 )
-					return 0;
-			}
+			struct inode *inode = sbi->inodes[ptynr];
+
+			if (!inode || !vx_check(inode->u.devpts_i.xid, VX_WATCH|VX_IDENT))
+				goto skip;
+			genptsname(numbuf, ptynr);
+			if ( filldir(dirent, numbuf, strlen(numbuf), nr, nr, DT_CHR) < 0 )
+				return 0;
+		skip:
 			filp->f_pos = ++nr;
 		}
 		break;
@@ -100,6 +104,7 @@ static struct dentry *devpts_root_lookup
 	unsigned int entry;
 	int i;
 	const char *p;
+	struct inode *inode;
 
 	dentry->d_op    = &devpts_dentry_operations;
 
@@ -126,10 +131,15 @@ static struct dentry *devpts_root_lookup
 	if ( entry >= sbi->max_ptys )
 		return NULL;
 
-	if ( sbi->inodes[entry] )
-		atomic_inc(&sbi->inodes[entry]->i_count);
+	inode = sbi->inodes[entry];
+	if (inode && vx_check(inode->u.devpts_i.xid, VX_IDENT))
+		atomic_inc(&inode->i_count);
+	else
+		inode = NULL;
 	
-	d_add(dentry, sbi->inodes[entry]);
+	d_add(dentry, inode);
 
 	return NULL;
 }
+
+
diff -NurpP --minimal linux-2.4.25-rc1/fs/exec.c linux-2.4.25-rc1-vs1.3.6.3/fs/exec.c
--- linux-2.4.25-rc1/fs/exec.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/exec.c	2004-02-06 02:52:25.000000000 +0100
@@ -311,7 +311,7 @@ void put_dirty_page(struct task_struct *
 	if (vma) 
 		prot = vma->vm_page_prot;
 	set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page, prot))));
-	tsk->mm->rss++;
+	vx_rsspages_inc(tsk->mm);
 	spin_unlock(&tsk->mm->page_table_lock);
 
 	/* no need for flush_tlb */
@@ -352,7 +352,7 @@ int setup_arg_pages(struct linux_binprm 
 		mpnt->vm_file = NULL;
 		mpnt->vm_private_data = (void *) 0;
 		insert_vm_struct(current->mm, mpnt);
-		current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;
+		vx_vmpages_add(current->mm, (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT);
 	} 
 
 	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
@@ -436,7 +436,7 @@ static int exec_mmap(void)
 	}
 
 
-	mm = mm_alloc();
+	mm = mm_alloc(current->vx_info);
 	if (mm) {
 		struct mm_struct *active_mm;
 
@@ -738,7 +738,7 @@ void compute_creds(struct linux_binprm *
 	kernel_cap_t new_permitted, working;
 	int do_unlock = 0;
 
-	new_permitted = cap_intersect(bprm->cap_permitted, cap_bset);
+	new_permitted = cap_intersect(bprm->cap_permitted, current->cap_bset);
 	working = cap_intersect(bprm->cap_inheritable,
 				current->cap_inheritable);
 	new_permitted = cap_combine(new_permitted, working);
diff -NurpP --minimal linux-2.4.25-rc1/fs/ext2/ialloc.c linux-2.4.25-rc1-vs1.3.6.3/fs/ext2/ialloc.c
--- linux-2.4.25-rc1/fs/ext2/ialloc.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ext2/ialloc.c	2004-02-06 02:52:25.000000000 +0100
@@ -388,7 +388,7 @@ repeat:
 	inode->u.ext2_i.i_state = EXT2_STATE_NEW;
 	inode->u.ext2_i.i_flags = dir->u.ext2_i.i_flags & ~EXT2_BTREE_FL;
 	if (S_ISLNK(mode))
-		inode->u.ext2_i.i_flags &= ~(EXT2_IMMUTABLE_FL|EXT2_APPEND_FL);
+		inode->u.ext2_i.i_flags &= ~(EXT2_IMMUTABLE_FL|EXT2_IUNLINK_FL|EXT2_APPEND_FL);
 	inode->u.ext2_i.i_block_group = group;
 	ext2_set_inode_flags(inode);
 	insert_inode_hash(inode);
diff -NurpP --minimal linux-2.4.25-rc1/fs/ext2/inode.c linux-2.4.25-rc1-vs1.3.6.3/fs/ext2/inode.c
--- linux-2.4.25-rc1/fs/ext2/inode.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ext2/inode.c	2004-02-06 02:52:25.000000000 +0100
@@ -57,6 +57,8 @@ void ext2_put_inode (struct inode * inod
 	ext2_discard_prealloc (inode);
 }
 
+static void ext2_truncate_nocheck (struct inode * inode);
+
 /*
  * Called at the last iput() if i_nlink is zero.
  */
@@ -73,7 +75,7 @@ void ext2_delete_inode (struct inode * i
 	ext2_update_inode(inode, IS_SYNC(inode));
 	inode->i_size = 0;
 	if (inode->i_blocks)
-		ext2_truncate (inode);
+		ext2_truncate_nocheck(inode);
 	ext2_free_inode (inode);
 
 	unlock_kernel();
@@ -797,7 +799,7 @@ static void ext2_free_branches(struct in
 		ext2_free_data(inode, p, q);
 }
 
-void ext2_truncate (struct inode * inode)
+static void ext2_truncate_nocheck(struct inode * inode)
 {
 	u32 *i_data = inode->u.ext2_i.i_data;
 	int addr_per_block = EXT2_ADDR_PER_BLOCK(inode->i_sb);
@@ -814,8 +816,6 @@ void ext2_truncate (struct inode * inode
 		return;
 	if (ext2_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
 
 	ext2_discard_prealloc(inode);
 
@@ -890,17 +890,26 @@ do_indirects:
 	}
 }
 
+void ext2_truncate (struct inode * inode)
+{
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return;
+	ext2_truncate_nocheck(inode);
+}
+
 void ext2_set_inode_flags(struct inode *inode)
 {
 	unsigned int flags = inode->u.ext2_i.i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME);
+	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_IUNLINK|S_NOATIME);
 	if (flags & EXT2_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT2_APPEND_FL)
 		inode->i_flags |= S_APPEND;
 	if (flags & EXT2_IMMUTABLE_FL)
 		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT2_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
 	if (flags & EXT2_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 }
diff -NurpP --minimal linux-2.4.25-rc1/fs/ext2/ioctl.c linux-2.4.25-rc1-vs1.3.6.3/fs/ext2/ioctl.c
--- linux-2.4.25-rc1/fs/ext2/ioctl.c	2003-06-13 16:51:37.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ext2/ioctl.c	2004-02-06 02:52:25.000000000 +0100
@@ -39,12 +39,12 @@ int ext2_ioctl (struct inode * inode, st
 		oldflags = inode->u.ext2_i.i_flags;
 
 		/*
-		 * The IMMUTABLE and APPEND_ONLY flags can only be changed by
-		 * the relevant capability.
+		 * The IMMUTABLE, IUNLINK and APPEND_ONLY flags can only be
+		 * changed by the relevant capability.
 		 *
 		 * This test looks nicer. Thanks to Pauline Middelink
 		 */
-		if ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL)) {
+		if ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL | EXT2_IUNLINK_FL)) {
 			if (!capable(CAP_LINUX_IMMUTABLE))
 				return -EPERM;
 		}
diff -NurpP --minimal linux-2.4.25-rc1/fs/ext3/ialloc.c linux-2.4.25-rc1-vs1.3.6.3/fs/ext3/ialloc.c
--- linux-2.4.25-rc1/fs/ext3/ialloc.c	2003-06-13 16:51:37.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ext3/ialloc.c	2004-02-06 02:52:25.000000000 +0100
@@ -485,7 +485,7 @@ repeat:
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	inode->u.ext3_i.i_flags = dir->u.ext3_i.i_flags & ~EXT3_INDEX_FL;
 	if (S_ISLNK(mode))
-		inode->u.ext3_i.i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_APPEND_FL);
+		inode->u.ext3_i.i_flags &= ~(EXT3_IMMUTABLE_FL|EXT3_IUNLINK_FL|EXT3_APPEND_FL);
 #ifdef EXT3_FRAGMENTS
 	inode->u.ext3_i.i_faddr = 0;
 	inode->u.ext3_i.i_frag_no = 0;
diff -NurpP --minimal linux-2.4.25-rc1/fs/ext3/inode.c linux-2.4.25-rc1-vs1.3.6.3/fs/ext3/inode.c
--- linux-2.4.25-rc1/fs/ext3/inode.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ext3/inode.c	2004-02-06 02:52:25.000000000 +0100
@@ -184,6 +184,7 @@ void ext3_put_inode (struct inode * inod
 	ext3_discard_prealloc (inode);
 }
 
+static void ext3_truncate_nocheck (struct inode *inode);
 /*
  * Called at the last iput() if i_nlink is zero.
  */
@@ -213,7 +214,7 @@ void ext3_delete_inode (struct inode * i
 		handle->h_sync = 1;
 	inode->i_size = 0;
 	if (inode->i_blocks)
-		ext3_truncate(inode);
+		ext3_truncate_nocheck(inode);
 	/*
 	 * Kill off the orphan record which ext3_truncate created.
 	 * AKPM: I think this can be inside the above `if'.
@@ -1866,7 +1867,7 @@ static void ext3_free_branches(handle_t 
  * ext3_truncate() run will find them and release them.
  */
 
-void ext3_truncate(struct inode * inode)
+static void ext3_truncate_nocheck(struct inode * inode)
 {
 	handle_t *handle;
 	u32 *i_data = inode->u.ext3_i.i_data;
@@ -1884,8 +1885,6 @@ void ext3_truncate(struct inode * inode)
 		return;
 	if (ext3_inode_is_fast_symlink(inode))
 		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
 
 	ext3_discard_prealloc(inode);
 
@@ -2015,6 +2014,13 @@ out_stop:
 	ext3_journal_stop(handle, inode);
 }
 
+void ext3_truncate(struct inode * inode)
+{
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return;
+	ext3_truncate_nocheck(inode);
+}
+
 /* 
  * ext3_get_inode_loc returns with an extra refcount against the
  * inode's underlying buffer_head on success. 
@@ -2086,13 +2092,15 @@ void ext3_set_inode_flags(struct inode *
 {
 	unsigned int flags = inode->u.ext3_i.i_flags;
 
-	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME);
+	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_IUNLINK|S_NOATIME);
 	if (flags & EXT3_SYNC_FL)
 		inode->i_flags |= S_SYNC;
 	if (flags & EXT3_APPEND_FL)
 		inode->i_flags |= S_APPEND;
 	if (flags & EXT3_IMMUTABLE_FL)
 		inode->i_flags |= S_IMMUTABLE;
+	if (flags & EXT3_IUNLINK_FL)
+		inode->i_flags |= S_IUNLINK;
 	if (flags & EXT3_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
 }
diff -NurpP --minimal linux-2.4.25-rc1/fs/ext3/ioctl.c linux-2.4.25-rc1-vs1.3.6.3/fs/ext3/ioctl.c
--- linux-2.4.25-rc1/fs/ext3/ioctl.c	2003-06-13 16:51:37.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ext3/ioctl.c	2004-02-06 02:52:25.000000000 +0100
@@ -48,12 +48,12 @@ int ext3_ioctl (struct inode * inode, st
 		jflag = flags & EXT3_JOURNAL_DATA_FL;
 
 		/*
-		 * The IMMUTABLE and APPEND_ONLY flags can only be changed by
-		 * the relevant capability.
+		 * The IMMUTABLE, IUNLINK and APPEND_ONLY flags can only be
+		 * changed by the relevant capability.
 		 *
 		 * This test looks nicer. Thanks to Pauline Middelink
 		 */
-		if ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL)) {
+		if ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL | EXT3_IUNLINK_FL)) {
 			if (!capable(CAP_LINUX_IMMUTABLE))
 				return -EPERM;
 		}
diff -NurpP --minimal linux-2.4.25-rc1/fs/inode.c linux-2.4.25-rc1-vs1.3.6.3/fs/inode.c
--- linux-2.4.25-rc1/fs/inode.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/inode.c	2004-02-06 02:54:40.000000000 +0100
@@ -17,6 +17,7 @@
 #include <linux/swapctl.h>
 #include <linux/prefetch.h>
 #include <linux/locks.h>
+#include <linux/vinline.h>
 
 /*
  * New inode.c implementation.
@@ -114,6 +115,7 @@ static struct inode *alloc_inode(struct 
 		inode->i_pipe = NULL;
 		inode->i_bdev = NULL;
 		inode->i_cdev = NULL;
+		// inode->i_xid = vx_current_xid(); /* bad for tagxid */
 
 		mapping->a_ops = &empty_aops;
 		mapping->host = inode;
diff -NurpP --minimal linux-2.4.25-rc1/fs/intermezzo/vfs.c linux-2.4.25-rc1-vs1.3.6.3/fs/intermezzo/vfs.c
--- linux-2.4.25-rc1/fs/intermezzo/vfs.c	2003-06-13 16:51:37.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/intermezzo/vfs.c	2004-02-06 02:52:25.000000000 +0100
@@ -140,7 +140,7 @@ static inline int may_delete(struct inod
         if (IS_APPEND(dir))
                 return -EPERM;
         if (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||
-            IS_IMMUTABLE(victim->d_inode))
+                IS_IXUNLINK(victim->d_inode))
                 return -EPERM;
         if (isdir) {
                 if (!S_ISDIR(victim->d_inode->i_mode))
@@ -772,7 +772,7 @@ int presto_do_link(struct presto_file_se
          * A link to an append-only or immutable file cannot be created.
          */
         error = -EPERM;
-        if (IS_APPEND(inode) || IS_IMMUTABLE(inode)) {
+        if (IS_APPEND(inode) || IS_IXUNLINK(inode)) {
                 EXIT;
                 goto exit_lock;
         }
diff -NurpP --minimal linux-2.4.25-rc1/fs/ioctl.c linux-2.4.25-rc1-vs1.3.6.3/fs/ioctl.c
--- linux-2.4.25-rc1/fs/ioctl.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/ioctl.c	2004-02-06 02:52:25.000000000 +0100
@@ -7,10 +7,14 @@
 #include <linux/mm.h>
 #include <linux/smp_lock.h>
 #include <linux/file.h>
+#include <linux/proc_fs.h>
 
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+extern int vx_proc_ioctl(struct inode *, struct file *,
+	unsigned int, unsigned long);
+
 static int file_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
 {
 	int error;
@@ -111,6 +115,12 @@ asmlinkage long sys_ioctl(unsigned int f
 			else
 				error = -ENOTTY;
 			break;
+		case FIOC_GETXFLG:
+		case FIOC_SETXFLG:
+			error = -ENOTTY;
+			if (filp->f_dentry->d_inode->i_sb->s_magic == PROC_SUPER_MAGIC)
+				error = vx_proc_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+			break;
 		default:
 			error = -ENOTTY;
 			if (S_ISREG(filp->f_dentry->d_inode->i_mode))
diff -NurpP --minimal linux-2.4.25-rc1/fs/namei.c linux-2.4.25-rc1-vs1.3.6.3/fs/namei.c
--- linux-2.4.25-rc1/fs/namei.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/namei.c	2004-02-06 02:52:25.000000000 +0100
@@ -22,6 +22,7 @@
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
 #include <linux/personality.h>
+#include <linux/vinline.h>
 
 #include <asm/namei.h>
 #include <asm/uaccess.h>
@@ -152,6 +153,15 @@ int vfs_permission(struct inode * inode,
 {
 	umode_t			mode = inode->i_mode;
 
+	/*
+		A dir with permission bit all 0s is a dead zone for
+		process running in a vserver. By doing
+			chmod 000 /vservers
+		you fix the "escape from chroot" bug.
+	*/
+	if ((mode & 0777) == 0 && S_ISDIR(mode)
+		&& !vx_check(0, VX_ADMIN))
+		return -EACCES;
 	if (mask & MAY_WRITE) {
 		/*
 		 * Nobody gets write access to a read-only fs.
@@ -905,7 +915,7 @@ static inline int may_delete(struct inod
 	if (IS_APPEND(dir))
 		return -EPERM;
 	if (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||
-	    IS_IMMUTABLE(victim->d_inode))
+		IS_IXUNLINK(victim->d_inode))
 		return -EPERM;
 	if (isdir) {
 		if (!S_ISDIR(victim->d_inode->i_mode))
@@ -1618,7 +1628,7 @@ int vfs_link(struct dentry *old_dentry, 
 	 * A link to an append-only or immutable file cannot be created.
 	 */
 	error = -EPERM;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+	if (IS_APPEND(inode) || IS_IXUNLINK(inode))
 		goto exit_lock;
 	if (!dir->i_op || !dir->i_op->link)
 		goto exit_lock;
diff -NurpP --minimal linux-2.4.25-rc1/fs/nfsd/vfs.c linux-2.4.25-rc1-vs1.3.6.3/fs/nfsd/vfs.c
--- linux-2.4.25-rc1/fs/nfsd/vfs.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/nfsd/vfs.c	2004-02-06 02:52:25.000000000 +0100
@@ -1480,7 +1480,7 @@ nfsd_permission(struct svc_export *exp, 
 	if (acc == MAY_NOP)
 		return 0;
 #if 0
-	dprintk("nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\n",
+	dprintk("nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s%s\n",
 		acc,
 		(acc & MAY_READ)?	" read"  : "",
 		(acc & MAY_WRITE)?	" write" : "",
@@ -1491,6 +1491,7 @@ nfsd_permission(struct svc_export *exp, 
 		(acc & MAY_OWNER_OVERRIDE)? " owneroverride" : "",
 		inode->i_mode,
 		IS_IMMUTABLE(inode)?	" immut" : "",
+		IS_IUNLINK(inode)?	" iunlink" : "",
 		IS_APPEND(inode)?	" append" : "",
 		IS_RDONLY(inode)?	" ro" : "");
 	dprintk("      owner %d/%d user %d/%d\n",
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/Makefile linux-2.4.25-rc1-vs1.3.6.3/fs/proc/Makefile
--- linux-2.4.25-rc1/fs/proc/Makefile	2001-05-09 01:41:32.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/Makefile	2004-02-06 02:52:25.000000000 +0100
@@ -12,7 +12,7 @@ O_TARGET := proc.o
 export-objs := root.o
 
 obj-y    := inode.o root.o base.o generic.o array.o \
-		kmsg.o proc_tty.o proc_misc.o kcore.o
+		kmsg.o proc_tty.o proc_misc.o kcore.o virtual.o
 
 ifeq ($(CONFIG_PROC_DEVICETREE),y)
 obj-y += proc_devtree.o
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/array.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/array.c
--- linux-2.4.25-rc1/fs/proc/array.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/array.c	2004-02-06 02:52:25.000000000 +0100
@@ -71,6 +71,7 @@
 #include <linux/signal.h>
 #include <linux/highmem.h>
 #include <linux/seq_file.h>
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -148,8 +149,13 @@ static inline const char * get_task_stat
 static inline char * task_state(struct task_struct *p, char *buffer)
 {
 	int g;
-
+	pid_t ppid;
 	read_lock(&tasklist_lock);
+	ppid = p->p_opptr->pid;
+	if (ppid != 0
+		&& current->vx_info
+		&& current->vx_info->vx_initpid == ppid)
+		ppid = 1;
 	buffer += sprintf(buffer,
 		"State:\t%s\n"
 		"Tgid:\t%d\n"
@@ -159,7 +165,7 @@ static inline char * task_state(struct t
 		"Uid:\t%d\t%d\t%d\t%d\n"
 		"Gid:\t%d\t%d\t%d\t%d\n",
 		get_task_state(p), p->tgid,
-		p->pid, p->pid ? p->p_opptr->pid : 0, 0,
+		p->pid, p->pid ? ppid : 0, 0,
 		p->uid, p->euid, p->suid, p->fsuid,
 		p->gid, p->egid, p->sgid, p->fsgid);
 	read_unlock(&tasklist_lock);	
@@ -267,10 +273,12 @@ static inline char *task_cap(struct task
 {
     return buffer + sprintf(buffer, "CapInh:\t%016x\n"
 			    "CapPrm:\t%016x\n"
-			    "CapEff:\t%016x\n",
+			    "CapEff:\t%016x\n"
+			    "CapBset:\t%016x\n",
 			    cap_t(p->cap_inheritable),
 			    cap_t(p->cap_permitted),
-			    cap_t(p->cap_effective));
+			    cap_t(p->cap_effective),
+			    cap_t(p->cap_bset));
 }
 
 
@@ -278,6 +286,8 @@ int proc_pid_status(struct task_struct *
 {
 	char * orig = buffer;
 	struct mm_struct *mm;
+	struct vx_info *vxi;
+	struct ip_info *ipi;
 
 	buffer = task_name(task, buffer);
 	buffer = task_state(task, buffer);
@@ -292,6 +302,44 @@ int proc_pid_status(struct task_struct *
 	}
 	buffer = task_sig(task, buffer);
 	buffer = task_cap(task, buffer);
+
+	buffer += sprintf (buffer,"s_context: %d\n", vx_task_xid(task));
+	vxi = task_get_vx_info(task);
+	if (vxi) {
+		buffer += sprintf (buffer,"ctxticks: %d %ld %d\n"
+			,atomic_read(&vxi->limit.ticks)
+			,task->counter
+			,atomic_read(&vxi->vx_refcount));
+		buffer += sprintf (buffer,"ctxflags: %d\n"
+			,vxi->vx_flags);
+		buffer += sprintf (buffer,"initpid: %d\n"
+			,vxi->vx_initpid);
+	} else {
+		buffer += sprintf (buffer,"ctxticks: none\n");
+		buffer += sprintf (buffer,"ctxflags: none\n");
+		buffer += sprintf (buffer,"initpid: none\n");
+	}
+	put_vx_info(vxi);
+	ipi = task_get_ip_info(task);
+	if (ipi) {
+		int i;
+
+		buffer += sprintf (buffer,"ipv4root:");
+		for (i=0; i<ipi->nbipv4; i++){
+			buffer += sprintf (buffer," %08x/%08x"
+				,ipi->ipv4[i]
+				,ipi->mask[i]);
+		}
+		*buffer++ = '\n';
+		buffer += sprintf (buffer,"ipv4root_bcast: %08x\n"
+			,ipi->v4_bcast);
+		buffer += sprintf (buffer,"ipv4root_refcnt: %d\n"
+			,atomic_read(&ipi->ip_refcount));
+	} else {
+		buffer += sprintf (buffer,"ipv4root: 0\n");
+		buffer += sprintf (buffer,"ipv4root_bcast: 0\n");
+	}
+	put_ip_info(ipi);
 #if defined(CONFIG_ARCH_S390)
 	buffer = task_show_regs(task, buffer);
 #endif
@@ -346,6 +394,9 @@ int proc_pid_stat(struct task_struct *ta
 	read_lock(&tasklist_lock);
 	ppid = task->pid ? task->p_opptr->pid : 0;
 	read_unlock(&tasklist_lock);
+	if (current->vx_info &&
+		current->vx_info->vx_initpid == ppid)
+		ppid = 1;
 	res = sprintf(buffer,"%d (%s) %c %d %d %d %d %d %lu %lu \
 %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu \
 %lu %lu %lu %lu %lu %lu %lu %lu %d %d\n",
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/base.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/base.c
--- linux-2.4.25-rc1/fs/proc/base.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/base.c	2004-02-06 02:52:25.000000000 +0100
@@ -25,6 +25,7 @@
 #include <linux/string.h>
 #include <linux/seq_file.h>
 #include <linux/namespace.h>
+#include <linux/vinline.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -774,6 +775,7 @@ static struct inode *proc_pid_make_inode
 		inode->i_uid = task->euid;
 		inode->i_gid = task->egid;
 	}
+	inode->i_xid = vx_task_xid(task);
 
 out:
 	return inode;
@@ -1078,8 +1080,10 @@ struct dentry *proc_pid_lookup(struct in
 	if (!task)
 		goto out;
 
-	inode = proc_pid_make_inode(dir->i_sb, task, PROC_PID_INO);
-
+	inode = NULL;
+	if (pid == 1 || vx_check(vx_task_xid(task), VX_WATCH|VX_IDENT))
+		inode = proc_pid_make_inode(dir->i_sb,
+			task, PROC_PID_INO);
 	free_task_struct(task);
 
 	if (!inode)
@@ -1106,7 +1110,7 @@ void proc_pid_delete_inode(struct inode 
 }
 
 #define PROC_NUMBUF 10
-#define PROC_MAXPIDS 20
+#define PROC_MAXPIDS 32
 
 /*
  * Get a few pid's to return for filldir - we need to hold the
@@ -1124,6 +1128,18 @@ static int get_pid_list(int index, unsig
 		int pid = p->pid;
 		if (!pid)
 			continue;
+		/* Even if the pid 1 is not part of the security context */
+		/* we show it anyway. This makes the security box */
+		/* more standard (and helps pstree do its job) */
+		/* So current process "knows" pid 1 exist anyway and can't */
+		/* send any signal either */
+
+		/* A process with security context 1 can see all processes */
+		if (pid != 1 && !vx_check(vx_task_xid(p), VX_WATCH|VX_IDENT))
+			continue;
+		/* We hide the fakeinit process since we show it as process 1 */
+		if (current->vx_info && current->vx_info->vx_initpid == pid)
+			continue;
 		if (--index >= 0)
 			continue;
 		pids[nr_pids] = pid;
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/generic.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/generic.c
--- linux-2.4.25-rc1/fs/proc/generic.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/generic.c	2004-02-06 02:52:25.000000000 +0100
@@ -16,6 +16,7 @@
 #include <linux/stat.h>
 #define __NO_VERSION__
 #include <linux/module.h>
+#include <linux/vinline.h>
 #include <asm/bitops.h>
 
 static ssize_t proc_file_read(struct file * file, char * buf,
@@ -265,6 +266,8 @@ struct dentry *proc_lookup(struct inode 
 				continue;
 			if (de->namelen != dentry->d_name.len)
 				continue;
+			if (!vx_weak_check(0, de->vx_flags))
+				continue;
 			if (!memcmp(dentry->d_name.name, de->name, de->namelen)) {
 				int ino = de->low_ino;
 				error = -EINVAL;
@@ -332,9 +335,12 @@ int proc_readdir(struct file * filp,
 			}
 
 			do {
+				if (!vx_weak_check(0, de->vx_flags))
+					goto skip;
 				if (filldir(dirent, de->name, de->namelen, filp->f_pos,
 					    de->low_ino, de->mode >> 12) < 0)
 					return 0;
+			skip:
 				filp->f_pos++;
 				de = de->next;
 			} while (de);
@@ -441,6 +447,7 @@ static struct proc_dir_entry *proc_creat
 	ent->namelen = len;
 	ent->mode = mode;
 	ent->nlink = nlink;
+	ent->vx_flags = VX_ADMIN;
  out:
 	return ent;
 }
@@ -461,7 +468,8 @@ struct proc_dir_entry *proc_symlink(cons
 				kfree(ent->data);
 				kfree(ent);
 				ent = NULL;
-			}
+			} else
+				ent->vx_flags = 0;
 		} else {
 			kfree(ent);
 			ent = NULL;
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/inode.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/inode.c
--- linux-2.4.25-rc1/fs/proc/inode.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/inode.c	2004-02-06 02:52:25.000000000 +0100
@@ -22,6 +22,8 @@
 
 extern void free_proc_entry(struct proc_dir_entry *);
 
+extern void proc_xid_delete_inode(struct inode *inode);
+
 static inline struct proc_dir_entry * de_get(struct proc_dir_entry *de)
 {
 	if (de)
@@ -63,7 +65,10 @@ static void proc_delete_inode(struct ino
 	inode->i_state = I_CLEAR;
 
 	if (PROC_INODE_PROPER(inode)) {
-		proc_pid_delete_inode(inode);
+		if ((inode->i_ino & 0xffe0) == 32)
+			proc_xid_delete_inode(inode);
+		else
+			proc_pid_delete_inode(inode);
 		return;
 	}
 	if (de) {
@@ -154,6 +159,8 @@ printk("proc_iget: using deleted entry %
 			inode->i_uid = de->uid;
 			inode->i_gid = de->gid;
 		}
+		if (de->vx_flags)
+			inode->u.proc_i.vx_flags = de->vx_flags;
 		if (de->size)
 			inode->i_size = de->size;
 		if (de->nlink)
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/proc_misc.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/proc_misc.c
--- linux-2.4.25-rc1/fs/proc/proc_misc.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/proc_misc.c	2004-02-06 02:52:25.000000000 +0100
@@ -18,6 +18,7 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/kernel.h>
 #include <linux/kernel_stat.h>
 #include <linux/tty.h>
@@ -126,6 +127,12 @@ static int uptime_read_proc(char *page, 
 
 	uptime = jiffies;
 	idle = init_tasks[0]->times.tms_utime + init_tasks[0]->times.tms_stime;
+	if (!vx_check(0, VX_ADMIN|VX_WATCH)) {
+		struct vx_info *vxi = current->vx_info;
+
+		uptime -= vxi->virt.bias_jiffies;
+		idle -= vxi->virt.bias_idle;
+	}
 
 	/* The formula for the fraction parts really is ((t * 100) / HZ) % 100, but
 	   that would overflow about every five days at HZ == 100.
@@ -373,14 +380,25 @@ static int kstat_read_proc(char *page, c
 		}
 	}
 
-	proc_sprintf(page, &off, &len,
-		"\nctxt %u\n"
-		"btime %lu\n"
-		"processes %lu\n",
-		kstat.context_swtch,
-		xtime.tv_sec - jif / HZ,
-		total_forks);
+	if (vx_check(0, VX_ADMIN|VX_WATCH)) {
+		proc_sprintf(page, &off, &len,
+			"\nctxt %u\n"
+			"btime %lu\n"
+			"processes %lu\n"
+			,kstat.context_swtch
+			,xtime.tv_sec - jif / HZ
+			,total_forks);
+	} else {
+		struct vx_info *vxi = current->vx_info;
 
+		proc_sprintf(page, &off, &len,
+			"\nctxt %u\n"
+			"btime %lu\n"
+			"processes %lu\n"
+			,kstat.context_swtch - vxi->virt.bias_cswtch
+			,xtime.tv_sec - jif / HZ + vxi->virt.bias_jiffies / HZ
+			,vxi->virt.total_forks);
+	}
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/root.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/root.c
--- linux-2.4.25-rc1/fs/proc/root.c	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/root.c	2004-02-06 02:52:25.000000000 +0100
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/vinline.h>
 #include <asm/bitops.h>
 
 struct proc_dir_entry *proc_net, *proc_bus, *proc_root_fs, *proc_root_driver;
@@ -22,6 +23,10 @@ struct proc_dir_entry *proc_net, *proc_b
 #ifdef CONFIG_SYSCTL
 struct proc_dir_entry *proc_sys_root;
 #endif
+struct proc_dir_entry *proc_virtual;
+
+extern void proc_vx_init(void);
+
 
 static DECLARE_FSTYPE(proc_fs_type, "proc", proc_read_super, FS_SINGLE);
 
@@ -68,6 +73,7 @@ void __init proc_root_init(void)
 	proc_rtas_init();
 #endif
 	proc_bus = proc_mkdir("bus", 0);
+	proc_vx_init();
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry)
diff -NurpP --minimal linux-2.4.25-rc1/fs/proc/virtual.c linux-2.4.25-rc1-vs1.3.6.3/fs/proc/virtual.c
--- linux-2.4.25-rc1/fs/proc/virtual.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/proc/virtual.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,547 @@
+/*
+ *  linux/fs/proc/virtual.c
+ *
+ *  Virtual Context Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Pötzl
+ *
+ *  V0.01  basic structure
+ *  V0.02  adaptation vs1.3.0
+ *  V0.03  proc permissions
+ *  V0.04  locking/generic
+ *  V0.05  next generation procfs
+ *  V0.06  inode validation
+ *
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+
+#include <linux/vinline.h>
+
+
+static struct proc_dir_entry *proc_virtual;
+
+enum xid_directory_inos {
+	PROC_XID_INO = 32,
+	PROC_XID_INFO,
+	PROC_XID_STATUS,
+	PROC_XID_LIMIT,
+};
+
+
+
+/* first the actual feeds */
+
+
+static int proc_virtual_info(struct vx_info *vxi, char *buffer)
+{
+	return sprintf(buffer,
+		"VCIVersion:\t%04x:%04x\n"
+		,VCI_VERSION >> 16
+		,VCI_VERSION & 0xFFFF);
+}
+
+
+int proc_xid_info (struct vx_info *vxi, char *buffer)
+{
+	return sprintf(buffer,
+		"ID:\t%d\n"
+		"Info:\t%p\n"
+		"Init:\t%d\n"
+		,vxi->vx_id
+		,vxi
+		,vxi->vx_initpid);
+}
+
+int proc_xid_status (struct vx_info *vxi, char *buffer)
+{
+	return sprintf(buffer,
+		"RefC:\t%d\n"		
+		"Flags:\t%08x\n"
+		"Ticks:\t%d\n"		
+		,atomic_read(&vxi->vx_refcount)
+		,vxi->vx_flags
+		,atomic_read(&vxi->limit.ticks));
+}
+
+int proc_xid_limit (struct vx_info *vxi, char *buffer)
+{
+	return sprintf(buffer,
+		"PROC:\t%8d/%ld\n"
+		"VM:\t%8d/%ld\n"
+		"VML:\t%8d/%ld\n"		
+		"RSS:\t%8d/%ld\n"
+		,atomic_read(&vxi->limit.res[RLIMIT_NPROC])
+		,vxi->limit.rlim[RLIMIT_NPROC]
+		,atomic_read(&vxi->limit.res[RLIMIT_AS])
+		,vxi->limit.rlim[RLIMIT_AS]
+		,atomic_read(&vxi->limit.res[RLIMIT_MEMLOCK])
+		,vxi->limit.rlim[RLIMIT_MEMLOCK]
+		,atomic_read(&vxi->limit.res[RLIMIT_RSS])
+		,vxi->limit.rlim[RLIMIT_RSS]);
+}
+
+
+
+
+/* here the inode helpers */
+
+
+
+#define fake_ino(xid,ino) (((xid)<<16)|(ino))
+
+#define MAX_MULBY10	((~0U-9)/10)
+
+
+static struct inode *proc_xid_make_inode(struct super_block * sb,
+	struct vx_info *vxi, int ino)
+{
+	struct inode *inode = new_inode(sb);
+	xid_t xid = (vxi)?vxi->vx_id:1;
+
+	if (!inode)
+		goto out;
+
+	inode->i_mtime = inode->i_atime =
+		inode->i_ctime = CURRENT_TIME;
+	inode->i_ino = fake_ino(xid, ino);
+
+	inode->u.generic_ip = vxi; /* reference from above */
+	inode->i_uid = 0;
+	inode->i_gid = 0;
+	inode->i_xid = xid;
+out:
+	return inode;
+}
+
+void proc_xid_delete_inode(struct inode *inode)
+{
+	struct vx_info *vxi = (struct vx_info *)inode->u.generic_ip;
+
+	if (vxi)
+		put_vx_info(vxi);
+}
+
+static int proc_xid_revalidate(struct dentry * dentry, int flags)
+{
+	struct vx_info *vxi = (struct vx_info *)dentry->d_inode->u.generic_ip;
+
+	if (atomic_read(&vxi->limit.res[RLIMIT_NPROC]))
+		return 1;
+        return 0;
+}
+
+
+
+static int proc_xid_delete_dentry(struct dentry * dentry)
+{
+        return 1;
+}
+
+
+
+#define PROC_BLOCK_SIZE (PAGE_SIZE - 1024)
+
+static ssize_t proc_xid_info_read(struct file * file, char * buf,
+			  size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	unsigned long page;
+	ssize_t length;
+	ssize_t end;
+	struct vx_info *vxi =
+		(struct vx_info *)inode->u.generic_ip;
+
+	if (count > PROC_BLOCK_SIZE)
+		count = PROC_BLOCK_SIZE;
+	if (!(page = __get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+
+	length = inode->u.proc_i.op.proc_xid_read(vxi, (char*)page);
+
+	if (length < 0) {
+		free_page(page);
+		return length;
+	}
+	/* Static 4kB (or whatever) block capacity */
+	if (*ppos >= length) {
+		free_page(page);
+		return 0;
+	}
+	if (count + *ppos > length)
+		count = length - *ppos;
+	end = count + *ppos;
+	copy_to_user(buf, (char *) page + *ppos, count);
+	*ppos = end;
+	free_page(page);
+	return count;
+}
+
+
+
+
+
+/* here comes the lower level (xid) */
+
+static struct file_operations proc_xid_info_file_operations = {
+	read:		proc_xid_info_read,
+};
+
+
+struct xid_entry {
+	int type;
+	int len;
+	char *name;
+	mode_t mode;
+};
+
+#define E(type,name,mode) {(type),sizeof(name)-1,(name),(mode)}
+
+static struct xid_entry base_stuff[] = {
+	E(PROC_XID_INFO,	"info",		S_IFREG|S_IRUGO),
+	E(PROC_XID_STATUS,	"status",	S_IFREG|S_IRUGO),
+	E(PROC_XID_LIMIT,	"limit",	S_IFREG|S_IRUGO),
+	{0,0,NULL,0}
+};
+
+static struct dentry *proc_xid_lookup(struct inode *dir,
+	struct dentry *dentry)
+{
+	struct inode *inode;
+	struct vx_info *vxi;
+	struct xid_entry *p;
+	int error;
+
+	error = -ENOENT;
+	inode = NULL;
+
+	for (p = base_stuff; p->name; p++) {
+		if (p->len != dentry->d_name.len)
+			continue;
+		if (!memcmp(dentry->d_name.name, p->name, p->len))
+			break;
+	}
+	if (!p->name)
+		goto out;
+	vxi = get_vx_info((struct vx_info *)dir->u.generic_ip);
+	if (!vxi)
+		goto out;
+
+	error = -EINVAL;
+	inode = proc_xid_make_inode(dir->i_sb, vxi, p->type);
+	if (!inode)
+		goto out_release;
+
+	switch(p->type) {
+		case PROC_XID_INFO:
+			inode->u.proc_i.op.proc_xid_read = proc_xid_info;
+			break;
+		case PROC_XID_STATUS:
+			inode->u.proc_i.op.proc_xid_read = proc_xid_status;
+			break;
+		case PROC_XID_LIMIT:
+			inode->u.proc_i.op.proc_xid_read = proc_xid_limit;
+			break;
+		default:
+			printk("procfs: impossible type (%d)",p->type);
+			iput(inode);
+			return ERR_PTR(-EINVAL);
+	}
+	inode->i_mode = p->mode;
+//	inode->i_op = &proc_xid_info_inode_operations;
+	inode->i_fop = &proc_xid_info_file_operations;
+	inode->i_nlink = 1;
+	inode->i_flags|=S_IMMUTABLE;
+	
+//	dentry->d_op = &proc_xid_dentry_operations;
+	d_add(dentry, inode);
+	return NULL;
+
+out_release:
+	put_vx_info(vxi);
+out:
+	return ERR_PTR(error);
+}
+
+
+static int proc_xid_readdir(struct file * filp,
+	void * dirent, filldir_t filldir)
+{
+	int i, xid;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct vx_info *vxi = (struct vx_info *)inode->u.generic_ip;
+	struct xid_entry *p;
+	
+	xid = vxi->vx_id;
+	i = filp->f_pos;
+	switch (i) {
+		case 0:
+			if (filldir(dirent, ".", 1, i,
+				inode->i_ino, DT_DIR) < 0)
+				return 0;
+			i++;
+			filp->f_pos++;
+			/* fall through */
+		case 1:
+			if (filldir(dirent, "..", 2, i,
+				PROC_ROOT_INO, DT_DIR) < 0)
+				return 0;
+			i++;
+			filp->f_pos++;
+			/* fall through */
+		default:
+			i -= 2;
+			if (i>=sizeof(base_stuff)/sizeof(base_stuff[0]))
+				return 1;
+			p = base_stuff + i;
+			while (p->name) {
+				if (filldir(dirent, p->name, p->len,
+					filp->f_pos, fake_ino(xid, p->type),
+					p->mode >> 12) < 0)
+					return 0;
+				filp->f_pos++;
+				p++;
+			}
+	}
+	return 1;
+}
+
+
+
+
+/* now the upper level (virtual) */
+
+static struct file_operations proc_xid_file_operations = {
+	read:		generic_read_dir,
+	readdir:	proc_xid_readdir,
+};
+
+static struct inode_operations proc_xid_inode_operations = {
+	lookup:		proc_xid_lookup,
+};
+
+static struct dentry_operations proc_xid_dentry_operations =
+{
+	d_revalidate:   proc_xid_revalidate,
+	d_delete:       proc_xid_delete_dentry,
+};
+
+
+
+struct dentry *proc_virtual_lookup(struct inode *dir, struct dentry * dentry)
+{
+	int xid, c;
+	struct vx_info *vxi;
+	const char *name;
+	struct inode *inode;
+	int len;
+
+	xid = 0;
+	name = dentry->d_name.name;
+	len = dentry->d_name.len;
+	if (len == 7 && !memcmp(name, "current", 7)) {
+		inode = new_inode(dir->i_sb);
+		if (!inode)
+			return ERR_PTR(-ENOMEM);
+		inode->i_mtime = inode->i_atime =
+			inode->i_ctime = CURRENT_TIME;
+		inode->i_ino = fake_ino(1, PROC_XID_INO);
+		inode->u.generic_ip = NULL;
+		inode->i_mode = S_IFLNK|S_IRWXUGO;
+		inode->i_uid = inode->i_gid = 0;
+		inode->i_size = 64;
+//		inode->i_op = &proc_current_inode_operations;
+		d_add(dentry, inode);
+		return NULL;
+	}
+	if (len == 4 && !memcmp(name, "info", 4)) {
+		inode = proc_xid_make_inode(dir->i_sb, NULL, PROC_XID_INFO);
+		if (!inode)
+			return ERR_PTR(-ENOMEM);
+		inode->i_fop = &proc_xid_info_file_operations;
+		inode->u.proc_i.op.proc_xid_read = proc_virtual_info;
+		inode->i_mode = S_IFREG|S_IRUGO;
+//		inode->i_size = 64;
+//		inode->i_op = &proc_current_inode_operations;
+		d_add(dentry, inode);
+		return NULL;
+	}
+
+	while (len-- > 0) {
+		c = *name - '0';
+		name++;
+		if (c > 9)
+			goto out;
+		if (xid >= MAX_MULBY10)
+			goto out;
+		xid *= 10;
+		xid += c;
+		if (!xid)
+			goto out;
+	}
+
+	vxi = find_vx_info(xid);
+	if (!vxi)
+		goto out;
+
+	inode = NULL;
+	if (vx_check(xid, VX_ADMIN|VX_WATCH|VX_IDENT))
+		inode = proc_xid_make_inode(dir->i_sb,
+			vxi, PROC_XID_INO);
+	if (!inode)
+		goto out_release;
+
+	inode->i_mode = S_IFDIR|S_IRUGO;
+	inode->i_op = &proc_xid_inode_operations;
+	inode->i_fop = &proc_xid_file_operations;
+	inode->i_nlink = 2;
+	inode->i_flags|=S_IMMUTABLE;
+
+	dentry->d_op = &proc_xid_dentry_operations;
+	d_add(dentry, inode);
+	return NULL;
+	
+out_release:
+	put_vx_info(vxi);
+out:
+	return ERR_PTR(-ENOENT);
+}
+
+
+
+#define PROC_NUMBUF 10
+#define PROC_MAXXIDS 32
+
+
+static int get_xid_list(int index, unsigned int *xids)
+{
+	struct vx_info *p;
+	int nr_xids = 0;
+
+	index--;
+	spin_lock(&vxlist_lock);
+	list_for_each_entry(p, &vx_infos, vx_list) {
+		int xid = p->vx_id;
+
+		if (--index >= 0)
+			continue;
+		xids[nr_xids] = xid;
+		if (++nr_xids >= PROC_MAXXIDS)
+			break;
+	}
+	spin_unlock(&vxlist_lock);
+	return nr_xids;
+}
+
+int proc_virtual_readdir(struct file * filp,
+	void * dirent, filldir_t filldir)
+{
+	unsigned int xid_array[PROC_MAXXIDS];
+	char buf[PROC_NUMBUF];
+	unsigned int nr = filp->f_pos-3;
+	unsigned int nr_xids, i;
+	ino_t ino;
+
+	switch (filp->f_pos) {
+		case 0:
+			ino = fake_ino(0, PROC_XID_INO);
+			if (filldir(dirent, ".", 1,
+				filp->f_pos, ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 1:
+			ino = filp->f_dentry->d_parent->d_inode->i_ino;
+			if (filldir(dirent, "..", 2,
+				filp->f_pos, ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 2:
+			ino = fake_ino(0, PROC_XID_INFO);
+			if (filldir(dirent, "info", 4,
+				filp->f_pos, ino, DT_LNK) < 0)
+				return 0;
+			filp->f_pos++;
+			/* fall through */
+		case 3:
+			if (current->xid > 1) {
+				ino = fake_ino(1, PROC_XID_INO);
+				if (filldir(dirent, "current", 7,
+					filp->f_pos, ino, DT_LNK) < 0)
+					return 0;
+			}
+			filp->f_pos++;
+		default:
+	}
+
+	nr_xids = get_xid_list(nr, xid_array);
+
+	for (i = 0; i < nr_xids; i++) {
+		int xid = xid_array[i];
+		ino_t ino = fake_ino(xid, PROC_XID_INO);
+		unsigned long j = PROC_NUMBUF;
+
+		do buf[--j] = '0' + (xid % 10); while (xid/=10);
+
+		if (filldir(dirent, buf+j, PROC_NUMBUF-j,
+			filp->f_pos, ino, DT_DIR) < 0)
+			break;
+		filp->f_pos++;
+	}
+	return 0;
+}
+
+
+static struct file_operations proc_virtual_dir_operations = {
+	read:		generic_read_dir,
+	readdir:	proc_virtual_readdir,
+};
+
+static struct inode_operations proc_virtual_dir_inode_operations = {
+	lookup:		proc_virtual_lookup,
+};
+
+
+
+
+
+
+
+void proc_vx_init(void)
+{
+	struct proc_dir_entry *ent;
+
+	ent = proc_mkdir("virtual", 0);
+	if (ent) {
+		ent->proc_fops = &proc_virtual_dir_operations;
+		ent->proc_iops = &proc_virtual_dir_inode_operations;
+	}
+	proc_virtual = ent;
+}
+
+
+
+
+/* per pid info */
+
+
+char *task_vinfo(struct task_struct *p, char *buffer)
+{
+	return buffer + sprintf(buffer,
+		"XID:\t%d\n"
+		,p->xid);
+}
+
+int proc_pid_vinfo(struct task_struct *p, char *buffer)
+{
+	char * orig = buffer;
+
+	buffer = task_vinfo(p, buffer);
+	return buffer - orig;
+}
+
diff -NurpP --minimal linux-2.4.25-rc1/fs/quota.c linux-2.4.25-rc1-vs1.3.6.3/fs/quota.c
--- linux-2.4.25-rc1/fs/quota.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/quota.c	2004-02-06 02:52:25.000000000 +0100
@@ -14,6 +14,10 @@
 #include <linux/quotaops.h>
 #include <linux/quotacompat.h>
 
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/major.h>
+
 struct dqstats dqstats;
 
 /* Check validity of quotactl */
@@ -95,15 +99,60 @@ static int check_quotactl_valid(struct s
 	if (cmd == Q_GETQUOTA || cmd == Q_XGETQUOTA) {
 		if (((type == USRQUOTA && current->euid != id) ||
 		     (type == GRPQUOTA && !in_egroup_p(id))) &&
-		    !capable(CAP_SYS_ADMIN))
+		    !capable(CAP_SYS_ADMIN) && !capable(CAP_QUOTACTL))
 			return -EPERM;
 	}
 	else if (cmd != Q_GETFMT && cmd != Q_SYNC && cmd != Q_GETINFO && cmd != Q_XGETQSTAT)
-		if (!capable(CAP_SYS_ADMIN))
+		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_QUOTACTL))
 			return -EPERM;
 	return 0;
 }
 
+#if	defined(CONFIG_BLK_DEV_VROOT) || defined(CONFIG_BLK_DEV_VROOT_MODULE)
+#if	defined(CONFIG_BLK_DEV_VROOT_MODULE)
+
+static  rwlock_t dquot_vroot_lock = RW_LOCK_UNLOCKED;
+
+typedef	kdev_t	(*vroot_get_dev_f)(int dev);
+
+static	vroot_get_dev_f vroot_get_dev = NULL;
+
+int register_vroot_get_dev(vroot_get_dev_f func)
+{
+	int ret = -EBUSY;
+	
+	write_lock(&dquot_vroot_lock);
+	if (!vroot_get_dev) {
+		vroot_get_dev = func;
+		ret = 0;
+	}
+	write_unlock(&dquot_vroot_lock);
+	return ret;
+}
+
+int unregister_vroot_get_dev(vroot_get_dev_f func)
+{
+	int ret = -EINVAL;
+	
+	write_lock(&dquot_vroot_lock);
+	if (vroot_get_dev == func) {
+		vroot_get_dev = NULL;
+		ret = 0;
+	}
+	write_unlock(&dquot_vroot_lock);
+	return ret;
+}
+
+EXPORT_SYMBOL(register_vroot_get_dev);
+EXPORT_SYMBOL(unregister_vroot_get_dev);
+
+#else	/* CONFIG_BLK_DEV_VROOT */
+
+extern	kdev_t	vroot_get_dev(int dev);
+
+#endif
+#endif
+
 /* Resolve device pathname to superblock */
 static struct super_block *resolve_dev(const char *path)
 {
@@ -124,6 +173,21 @@ static struct super_block *resolve_dev(c
 	ret = -ENOTBLK;
 	if (!S_ISBLK(mode))
 		goto out;
+
+#if defined(CONFIG_BLK_DEV_VROOT) || defined(CONFIG_BLK_DEV_VROOT_MODULE)
+	if (MAJOR(dev) == VROOT_MAJOR) {
+		ret = -ENODEV;
+#ifdef CONFIG_BLK_DEV_VROOT_MODULE
+		read_lock(&dquot_vroot_lock);
+		dev = (vroot_get_dev) ? vroot_get_dev(MINOR(dev)) : NODEV;
+		read_unlock(&dquot_vroot_lock);
+#else
+		dev = vroot_get_dev(MINOR(dev));
+#endif
+		if (dev == NODEV)
+			goto out;
+	}
+#endif
 	ret = -ENODEV;
 	sb = get_super(dev);
 	if (!sb)
@@ -308,11 +372,11 @@ static int check_compat_quotactl_valid(s
 	if (cmd == Q_V1_GETQUOTA || cmd == Q_V2_GETQUOTA) {
 		if (((type == USRQUOTA && current->euid != id) ||
 		     (type == GRPQUOTA && !in_egroup_p(id))) &&
-		    !capable(CAP_SYS_ADMIN))
+		    !capable(CAP_SYS_ADMIN) && !capable(CAP_QUOTACTL))
 			return -EPERM;
 	}
 	else if (cmd != Q_V1_GETSTATS && cmd != Q_V2_GETSTATS && cmd != Q_V2_GETINFO && cmd != Q_COMP_SYNC)
-		if (!capable(CAP_SYS_ADMIN))
+		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_QUOTACTL))
 			return -EPERM;
 	return 0;
 }
diff -NurpP --minimal linux-2.4.25-rc1/fs/reiserfs/inode.c linux-2.4.25-rc1-vs1.3.6.3/fs/reiserfs/inode.c
--- linux-2.4.25-rc1/fs/reiserfs/inode.c	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/reiserfs/inode.c	2004-02-06 02:52:25.000000000 +0100
@@ -2181,6 +2181,10 @@ void sd_attrs_to_i_attrs( __u16 sd_attrs
 			inode -> i_flags |= S_IMMUTABLE;
 		else
 			inode -> i_flags &= ~S_IMMUTABLE;
+		if( sd_attrs & REISERFS_IUNLINK_FL )
+			inode -> i_flags |= S_IUNLINK;
+		else
+			inode -> i_flags &= ~S_IUNLINK;
 		if( sd_attrs & REISERFS_APPEND_FL )
 			inode -> i_flags |= S_APPEND;
 		else
@@ -2203,6 +2207,10 @@ void i_attrs_to_sd_attrs( struct inode *
 			*sd_attrs |= REISERFS_IMMUTABLE_FL;
 		else
 			*sd_attrs &= ~REISERFS_IMMUTABLE_FL;
+		if( inode -> i_flags & S_IUNLINK )
+			*sd_attrs |= REISERFS_IUNLINK_FL;
+		else
+			*sd_attrs &= ~REISERFS_IUNLINK_FL;
 		if( inode -> i_flags & S_SYNC )
 			*sd_attrs |= REISERFS_SYNC_FL;
 		else
diff -NurpP --minimal linux-2.4.25-rc1/fs/reiserfs/ioctl.c linux-2.4.25-rc1-vs1.3.6.3/fs/reiserfs/ioctl.c
--- linux-2.4.25-rc1/fs/reiserfs/ioctl.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/reiserfs/ioctl.c	2004-02-06 02:52:25.000000000 +0100
@@ -51,7 +51,8 @@ int reiserfs_ioctl (struct inode * inode
 		if (get_user(flags, (int *) arg))
 			return -EFAULT;
 
-		if ( ( ( flags ^ inode->u.reiserfs_i.i_attrs) & ( REISERFS_IMMUTABLE_FL | REISERFS_APPEND_FL)) && 
+		if ( ( ( flags ^ inode->u.reiserfs_i.i_attrs) &
+		     ( REISERFS_IMMUTABLE_FL | REISERFS_IUNLINK_FL | REISERFS_APPEND_FL )) &&
 		     !capable( CAP_LINUX_IMMUTABLE ) )
 			return -EPERM;
 			
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/linux/xfs_ioctl.c linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/linux/xfs_ioctl.c
--- linux-2.4.25-rc1/fs/xfs/linux/xfs_ioctl.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/linux/xfs_ioctl.c	2004-02-06 02:52:25.000000000 +0100
@@ -1029,6 +1029,8 @@ xfs_ioc_fsgeometry(
 #define LINUX_XFLAG_APPEND	0x00000020 /* writes to file may only append */
 #define LINUX_XFLAG_NODUMP	0x00000040 /* do not dump file */
 #define LINUX_XFLAG_NOATIME	0x00000080 /* do not update atime */
+#define LINUX_XFLAG_BARRIER	0x04000000 /* chroot() barrier */
+#define LINUX_XFLAG_IUNLINK	0x08000000 /* Immutable unlink */
 
 STATIC unsigned int
 xfs_merge_ioc_xflags(
@@ -1041,6 +1043,10 @@ xfs_merge_ioc_xflags(
 		xflags |= XFS_XFLAG_IMMUTABLE;
 	else
 		xflags &= ~XFS_XFLAG_IMMUTABLE;
+	if (flags & LINUX_XFLAG_IUNLINK)
+		xflags |= XFS_XFLAG_IUNLINK;
+	else
+		xflags &= ~XFS_XFLAG_IUNLINK;
 	if (flags & LINUX_XFLAG_APPEND)
 		xflags |= XFS_XFLAG_APPEND;
 	else
@@ -1128,6 +1134,8 @@ xfs_ioc_xattr(
 		flags = 0;
 		if (ip->i_d.di_flags & XFS_XFLAG_IMMUTABLE)
 			flags |= LINUX_XFLAG_IMMUTABLE;
+		if (ip->i_d.di_flags & XFS_XFLAG_IUNLINK)
+			flags |= LINUX_XFLAG_IUNLINK;
 		if (ip->i_d.di_flags & XFS_XFLAG_APPEND)
 			flags |= LINUX_XFLAG_APPEND;
 		if (ip->i_d.di_flags & XFS_XFLAG_SYNC)
@@ -1147,7 +1155,7 @@ xfs_ioc_xattr(
 
 		if (flags & ~(LINUX_XFLAG_IMMUTABLE | LINUX_XFLAG_APPEND | \
 			      LINUX_XFLAG_NOATIME | LINUX_XFLAG_NODUMP | \
-			      LINUX_XFLAG_SYNC))
+			      LINUX_XFLAG_SYNC | LINUX_XFLAG_IUNLINK))
 			return -XFS_ERROR(EOPNOTSUPP);
 
 		attr_flags = 0;
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/linux/xfs_super.c linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/linux/xfs_super.c
--- linux-2.4.25-rc1/fs/xfs/linux/xfs_super.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/linux/xfs_super.c	2004-02-06 02:52:25.000000000 +0100
@@ -179,6 +179,10 @@ xfs_revalidate_inode(
 		inode->i_flags |= S_IMMUTABLE;
 	else
 		inode->i_flags &= ~S_IMMUTABLE;
+	if (ip->i_d.di_flags & XFS_DIFLAG_IUNLINK)
+		inode->i_flags |= S_IUNLINK;
+	else
+		inode->i_flags &= ~S_IUNLINK;
 	if (ip->i_d.di_flags & XFS_DIFLAG_APPEND)
 		inode->i_flags |= S_APPEND;
 	else
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/linux/xfs_vnode.c linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/linux/xfs_vnode.c
--- linux-2.4.25-rc1/fs/xfs/linux/xfs_vnode.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/linux/xfs_vnode.c	2004-02-06 02:52:25.000000000 +0100
@@ -229,6 +229,10 @@ vn_revalidate(
 			inode->i_flags |= S_IMMUTABLE;
 		else
 			inode->i_flags &= ~S_IMMUTABLE;
+		if (va.va_xflags & XFS_XFLAG_IUNLINK)
+			inode->i_flags |= S_IUNLINK;
+		else
+			inode->i_flags &= ~S_IUNLINK;
 		if (va.va_xflags & XFS_XFLAG_APPEND)
 			inode->i_flags |= S_APPEND;
 		else
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/xfs_dinode.h linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_dinode.h
--- linux-2.4.25-rc1/fs/xfs/xfs_dinode.h	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_dinode.h	2004-02-06 02:52:25.000000000 +0100
@@ -456,6 +456,8 @@ xfs_dinode_t *xfs_buf_to_dinode(struct x
 #define XFS_DIFLAG_SYNC_BIT      5	/* inode is written synchronously */
 #define XFS_DIFLAG_NOATIME_BIT   6	/* do not update atime */
 #define XFS_DIFLAG_NODUMP_BIT    7	/* do not dump */
+#define XFS_DIFLAG_BARRIER_BIT   26	/* chroot() barrier */
+#define XFS_DIFLAG_IUNLINK_BIT   27	/* inode has iunlink */
 #define XFS_DIFLAG_REALTIME      (1 << XFS_DIFLAG_REALTIME_BIT)
 #define XFS_DIFLAG_PREALLOC      (1 << XFS_DIFLAG_PREALLOC_BIT)
 #define XFS_DIFLAG_NEWRTBM       (1 << XFS_DIFLAG_NEWRTBM_BIT)
@@ -464,5 +466,7 @@ xfs_dinode_t *xfs_buf_to_dinode(struct x
 #define XFS_DIFLAG_SYNC          (1 << XFS_DIFLAG_SYNC_BIT)
 #define XFS_DIFLAG_NOATIME       (1 << XFS_DIFLAG_NOATIME_BIT)
 #define XFS_DIFLAG_NODUMP        (1 << XFS_DIFLAG_NODUMP_BIT)
+#define XFS_DIFLAG_BARRIER       (1 << XFS_DIFLAG_BARRIER_BIT)
+#define XFS_DIFLAG_IUNLINK       (1 << XFS_DIFLAG_IUNLINK_BIT)
 
 #endif	/* __XFS_DINODE_H__ */
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/xfs_fs.h linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_fs.h
--- linux-2.4.25-rc1/fs/xfs/xfs_fs.h	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_fs.h	2004-02-06 02:52:25.000000000 +0100
@@ -76,6 +76,8 @@ struct fsxattr {
 #define XFS_XFLAG_SYNC		0x00000020	/* all writes synchronous */
 #define XFS_XFLAG_NOATIME	0x00000040	/* do not update access time */
 #define XFS_XFLAG_NODUMP	0x00000080	/* do not include in backups */
+#define XFS_XFLAG_BARRIER	0x04000000	/* chroot() barrier */
+#define XFS_XFLAG_IUNLINK	0x08000000	/* Immutable unlink */
 #define XFS_XFLAG_HASATTR	0x80000000	/* no DIFLAG for this	*/
 
 /*
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/xfs_itable.c linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_itable.c
--- linux-2.4.25-rc1/fs/xfs/xfs_itable.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_itable.c	2004-02-06 02:52:25.000000000 +0100
@@ -172,6 +172,8 @@ xfs_bulkstat_one(
 			XFS_XFLAG_PREALLOC : 0) |
 	        ((di_flags & XFS_DIFLAG_IMMUTABLE) ?
 		        XFS_XFLAG_IMMUTABLE : 0) |
+	        ((di_flags & XFS_DIFLAG_IUNLINK) ?
+		        XFS_XFLAG_IUNLINK : 0) |
 		((di_flags & XFS_DIFLAG_APPEND) ?
 		        XFS_XFLAG_APPEND : 0) |
 		((di_flags & XFS_DIFLAG_SYNC) ?
diff -NurpP --minimal linux-2.4.25-rc1/fs/xfs/xfs_vnodeops.c linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_vnodeops.c
--- linux-2.4.25-rc1/fs/xfs/xfs_vnodeops.c	2004-02-06 00:45:54.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/fs/xfs/xfs_vnodeops.c	2004-02-06 02:52:25.000000000 +0100
@@ -255,6 +255,8 @@ xfs_getattr(
 		vap->va_xflags |= XFS_XFLAG_PREALLOC;
 	if (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)
 		vap->va_xflags |= XFS_XFLAG_IMMUTABLE;
+	if (ip->i_d.di_flags & XFS_DIFLAG_IUNLINK)
+		vap->va_xflags |= XFS_XFLAG_IUNLINK;
 	if (ip->i_d.di_flags & XFS_DIFLAG_APPEND)
 		vap->va_xflags |= XFS_XFLAG_APPEND;
 	if (ip->i_d.di_flags & XFS_DIFLAG_SYNC)
@@ -855,6 +857,8 @@ xfs_setattr(
 			}
 			if (vap->va_xflags & XFS_XFLAG_IMMUTABLE)
 				ip->i_d.di_flags |= XFS_DIFLAG_IMMUTABLE;
+			if (vap->va_xflags & XFS_XFLAG_IUNLINK)
+				ip->i_d.di_flags |= XFS_DIFLAG_IUNLINK;
 			if (vap->va_xflags & XFS_XFLAG_APPEND)
 				ip->i_d.di_flags |= XFS_DIFLAG_APPEND;
 			if (vap->va_xflags & XFS_XFLAG_SYNC)
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-alpha/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-alpha/unistd.h
--- linux-2.4.25-rc1/include/asm-alpha/unistd.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-alpha/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -233,6 +233,7 @@
 #define __NR_osf_memcntl	260	/* not implemented */
 #define __NR_osf_fdatasync	261	/* not implemented */
 
+#define __NR_vserver	273
 
 /*
  * Linux-specific system calls begin at 300
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-i386/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-i386/unistd.h
--- linux-2.4.25-rc1/include/asm-i386/unistd.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-i386/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -258,6 +258,8 @@
 #define __NR_free_hugepages	251
 #define __NR_exit_group		252
 
+#define __NR_vserver	273
+
 /* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
 
 #define __syscall_return(type, res) \
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-parisc/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-parisc/unistd.h
--- linux-2.4.25-rc1/include/asm-parisc/unistd.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-parisc/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -702,7 +702,9 @@
 #define __NR_readahead          (__NR_Linux + 207)
 #define __NR_tkill              (__NR_Linux + 208)
 
-#define __NR_Linux_syscalls     208
+#define __NR_vserver            (__NR_Linux + 273)
+
+#define __NR_Linux_syscalls     274
 
 #define HPUX_GATEWAY_ADDR       0xC0000004
 #define LINUX_GATEWAY_ADDR      0x100
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-ppc/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-ppc/unistd.h
--- linux-2.4.25-rc1/include/asm-ppc/unistd.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-ppc/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -257,6 +257,8 @@
 #endif
 #define __NR_swapcontext	249
 
+#define __NR_vserver	273
+
 #define __NR(n)	#n
 
 /* On powerpc a system call basically clobbers the same registers like a
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-ppc64/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-ppc64/unistd.h
--- linux-2.4.25-rc1/include/asm-ppc64/unistd.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-ppc64/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -244,6 +244,7 @@
 #define __NR_alloc_hugepages	232
 #define __NR_free_hugepages	233
 #define __NR_exit_group		234
+#define __NR_vserver		273
 
 /* On powerpc a system call basically clobbers the same registers like a
  * function call, with the exception of LR (which is needed for the
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-sparc/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-sparc/unistd.h
--- linux-2.4.25-rc1/include/asm-sparc/unistd.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-sparc/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -272,6 +272,8 @@
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
 
+#define __NR_vserver	273
+
 #define _syscall0(type,name) \
 type name(void) \
 { \
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-sparc64/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-sparc64/unistd.h
--- linux-2.4.25-rc1/include/asm-sparc64/unistd.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-sparc64/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -274,6 +274,8 @@
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
 
+#define __NR_vserver	273
+
 #define _syscall0(type,name) \
 type name(void) \
 { \
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-x86_64/ia32_unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-x86_64/ia32_unistd.h
--- linux-2.4.25-rc1/include/asm-x86_64/ia32_unistd.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-x86_64/ia32_unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -250,6 +250,8 @@
 #define __NR_ia32_sched_setaffinity	241
 #define __NR_ia32_sched_getaffinity	242
 
-#define IA32_NR_syscalls 245
+#define __NR_ia32_vserver	273
+
+#define IA32_NR_syscalls 274
 
 #endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -NurpP --minimal linux-2.4.25-rc1/include/asm-x86_64/unistd.h linux-2.4.25-rc1-vs1.3.6.3/include/asm-x86_64/unistd.h
--- linux-2.4.25-rc1/include/asm-x86_64/unistd.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/asm-x86_64/unistd.h	2004-02-06 02:52:25.000000000 +0100
@@ -500,7 +500,10 @@ __SYSCALL(__NR_restart_syscall, sys_ni_s
 #define __NR_semtimedop		220
 __SYSCALL(__NR_semtimedop, sys_semtimedop)
 
-#define __NR_syscall_max __NR_semtimedop
+#define __NR_vserver	273
+__SYSCALL(__NR_vserver, sys_vserver)
+
+#define __NR_syscall_max __NR_vserver
 
 #ifndef __NO_STUBS
 
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/capability.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/capability.h
--- linux-2.4.25-rc1/include/linux/capability.h	2004-02-01 22:12:40.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/capability.h	2004-02-06 02:52:25.000000000 +0100
@@ -130,7 +130,8 @@ typedef __u32 kernel_cap_t;
 
 #define CAP_SETPCAP          8
 
-/* Allow modification of S_IMMUTABLE and S_APPEND file attributes */
+/* Allow modification of S_IMMUTABLE, S_IUNLINK and S_APPEND file
+   attributes */
 
 #define CAP_LINUX_IMMUTABLE  9
 
@@ -231,6 +232,7 @@ typedef __u32 kernel_cap_t;
 /* Allow enabling/disabling tagged queuing on SCSI controllers and sending
    arbitrary SCSI commands */
 /* Allow setting encryption key on loopback filesystem */
+/* Allow the selection of a security context */
 
 #define CAP_SYS_ADMIN        21
 
@@ -279,6 +281,15 @@ typedef __u32 kernel_cap_t;
 
 #define CAP_LEASE            28
 
+/* Allow quotactl */
+
+#define CAP_QUOTACTL         29
+
+/* Allow context manipulations */
+/* Allow changing context info on files */
+
+#define CAP_CONTEXT          30
+
 #ifdef __KERNEL__
 /* 
  * Bounding set
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/devpts_fs_info.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/devpts_fs_info.h
--- linux-2.4.25-rc1/include/linux/devpts_fs_info.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/devpts_fs_info.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,4 @@
+struct devpts_inode_info {
+	xid_t xid;
+};
+
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/ext2_fs.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/ext2_fs.h
--- linux-2.4.25-rc1/include/linux/ext2_fs.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/ext2_fs.h	2004-02-06 02:52:25.000000000 +0100
@@ -198,10 +198,12 @@ struct ext2_group_desc
 #define EXT2_ECOMPR_FL			0x00000800 /* Compression error */
 /* End compression flags --- maybe not all used */	
 #define EXT2_BTREE_FL			0x00001000 /* btree format dir */
+#define EXT2_BARRIER_FL			0x04000000 /* chroot() barrier */
+#define EXT2_IUNLINK_FL			0x08000000 /* Immutable unlink */
 #define EXT2_RESERVED_FL		0x80000000 /* reserved for ext2 lib */
 
-#define EXT2_FL_USER_VISIBLE		0x00001FFF /* User visible flags */
-#define EXT2_FL_USER_MODIFIABLE		0x000000FF /* User modifiable flags */
+#define EXT2_FL_USER_VISIBLE		0x00009FFF /* User visible flags */
+#define EXT2_FL_USER_MODIFIABLE		0x000080FF /* User modifiable flags */
 
 /*
  * ioctl commands
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/ext3_fs.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/ext3_fs.h
--- linux-2.4.25-rc1/include/linux/ext3_fs.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/ext3_fs.h	2004-02-06 02:52:25.000000000 +0100
@@ -203,10 +203,12 @@ struct ext3_group_desc
 #define EXT3_INDEX_FL			0x00001000 /* hash-indexed directory */
 #define EXT3_IMAGIC_FL			0x00002000 /* AFS directory */
 #define EXT3_JOURNAL_DATA_FL		0x00004000 /* file data should be journaled */
+#define EXT3_BARRIER_FL			0x04000000 /* chroot() barrier */
+#define EXT3_IUNLINK_FL			0x08000000 /* Immutable unlink */
 #define EXT3_RESERVED_FL		0x80000000 /* reserved for ext3 lib */
 
-#define EXT3_FL_USER_VISIBLE		0x00005FFF /* User visible flags */
-#define EXT3_FL_USER_MODIFIABLE		0x000000FF /* User modifiable flags */
+#define EXT3_FL_USER_VISIBLE		0x0000DFFF /* User visible flags */
+#define EXT3_FL_USER_MODIFIABLE		0x000080FF /* User modifiable flags */
 
 /*
  * Inode dynamic state flags
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/fs.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/fs.h
--- linux-2.4.25-rc1/include/linux/fs.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/fs.h	2004-02-06 02:52:25.000000000 +0100
@@ -136,6 +136,9 @@ extern int leases_enable, dir_notify_ena
 #define S_DEAD		32	/* removed, but still open directory */
 #define S_NOQUOTA	64	/* Inode is not counted to quota */
 
+#define S_BARRIER	256	/* chroot() barrier */
+#define S_IUNLINK	512	/* Immutable unlink */
+
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
  * flags just means all the inodes inherit those flags by default. It might be
@@ -159,9 +162,12 @@ extern int leases_enable, dir_notify_ena
 #define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
 #define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
 #define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
+#define IS_IUNLINK(inode)	((inode)->i_flags & S_IUNLINK)
+#define	IS_IXUNLINK(inode)	((IS_IUNLINK(inode) ? S_IMMUTABLE : 0) ^ IS_IMMUTABLE(inode))
 #define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
 #define IS_NODIRATIME(inode)	__IS_FLG(inode, MS_NODIRATIME)
 
+#define IS_BARRIER(inode)	((inode)->i_flags & S_BARRIER)
 #define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
 
 /* the read-only stuff doesn't really belong here, but any other place is
@@ -324,6 +330,7 @@ extern void set_bh_page(struct buffer_he
 #include <linux/usbdev_fs_i.h>
 #include <linux/jffs2_fs_i.h>
 #include <linux/cramfs_fs_sb.h>
+#include <linux/devpts_fs_info.h>
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -452,6 +459,7 @@ struct inode {
 	nlink_t			i_nlink;
 	uid_t			i_uid;
 	gid_t			i_gid;
+	xid_t			i_xid;
 	kdev_t			i_rdev;
 	loff_t			i_size;
 	time_t			i_atime;
@@ -519,6 +527,7 @@ struct inode {
 		struct socket			socket_i;
 		struct usbdev_inode_info        usbdev_i;
 		struct jffs2_inode_info		jffs2_i;
+		struct devpts_inode_info	devpts_i;
 		void				*generic_ip;
 	} u;
 };
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/major.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/major.h
--- linux-2.4.25-rc1/include/linux/major.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/major.h	2004-02-06 02:52:25.000000000 +0100
@@ -24,6 +24,7 @@
 #define PTY_SLAVE_MAJOR 3
 #define HD_MAJOR	IDE0_MAJOR
 #define TTY_MAJOR	4
+#define VROOT_MAJOR	4
 #define TTYAUX_MAJOR	5
 #define LP_MAJOR	6
 #define VCS_MAJOR	7
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/mm.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/mm.h
--- linux-2.4.25-rc1/include/linux/mm.h	2004-02-06 01:48:51.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/mm.h	2004-02-06 02:52:25.000000000 +0100
@@ -1,7 +1,7 @@
 #ifndef _LINUX_MM_H
 #define _LINUX_MM_H
 
-#include <linux/sched.h>
+#include <linux/vinline.h>
 #include <linux/errno.h>
 
 #ifdef __KERNEL__
@@ -656,11 +656,15 @@ static inline int expand_stack(struct vm
 		spin_unlock(&vma->vm_mm->page_table_lock);
 		return -ENOMEM;
 	}
+	if (!vx_vmpages_avail(vma->vm_mm, grow)) {
+		spin_unlock(&vma->vm_mm->page_table_lock);
+		return -ENOMEM;
+	}
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
-	vma->vm_mm->total_vm += grow;
+	vx_vmpages_add(vma->vm_mm, grow);
 	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
+		vx_vmlocked_add(vma->vm_mm, grow);
 	spin_unlock(&vma->vm_mm->page_table_lock);
 	return 0;
 }
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/proc_fs.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/proc_fs.h
--- linux-2.4.25-rc1/include/linux/proc_fs.h	2004-02-01 22:12:48.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/proc_fs.h	2004-02-06 02:52:25.000000000 +0100
@@ -58,6 +58,7 @@ struct proc_dir_entry {
 	nlink_t nlink;
 	uid_t uid;
 	gid_t gid;
+	int vx_flags;
 	unsigned long size;
 	struct inode_operations * proc_iops;
 	struct file_operations * proc_fops;
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/proc_fs_i.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/proc_fs_i.h
--- linux-2.4.25-rc1/include/linux/proc_fs_i.h	2000-04-07 22:38:00.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/proc_fs_i.h	2004-02-06 02:52:25.000000000 +0100
@@ -1,9 +1,14 @@
+
+struct vx_info;
+
 struct proc_inode_info {
 	struct task_struct *task;
 	int type;
+	int vx_flags;
 	union {
 		int (*proc_get_link)(struct inode *, struct dentry **, struct vfsmount **);
 		int (*proc_read)(struct task_struct *task, char *page);
+		int (*proc_xid_read)(struct vx_info *vxi, char *page);
 	} op;
 	struct file *file;
 };
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/reiserfs_fs.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/reiserfs_fs.h
--- linux-2.4.25-rc1/include/linux/reiserfs_fs.h	2004-02-01 22:14:50.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/reiserfs_fs.h	2004-02-06 02:52:25.000000000 +0100
@@ -867,6 +867,8 @@ struct stat_data_v1
 /* we want common flags to have the same values as in ext2,
    so chattr(1) will work without problems */
 #define REISERFS_IMMUTABLE_FL EXT2_IMMUTABLE_FL
+#define REISERFS_IUNLINK_FL   EXT2_IUNLINK_FL
+#define REISERFS_BARRIER_FL   EXT2_BARRIER_FL
 #define REISERFS_APPEND_FL    EXT2_APPEND_FL
 #define REISERFS_SYNC_FL      EXT2_SYNC_FL
 #define REISERFS_NOATIME_FL   EXT2_NOATIME_FL
@@ -884,6 +886,7 @@ struct stat_data_v1
 
 /* persistent flags that file inherits from the parent directory */
 #define REISERFS_INHERIT_MASK ( REISERFS_IMMUTABLE_FL |	\
+				REISERFS_IUNLINK_FL |	\
 				REISERFS_SYNC_FL |	\
 				REISERFS_NOATIME_FL |	\
 				REISERFS_NODUMP_FL |	\
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/sched.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/sched.h
--- linux-2.4.25-rc1/include/linux/sched.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/sched.h	2004-02-06 02:52:25.000000000 +0100
@@ -85,6 +85,7 @@ extern int last_pid;
 #endif
 
 #include <asm/processor.h>
+#include <linux/vserver/context.h>
 
 #define TASK_RUNNING		0
 #define TASK_INTERRUPTIBLE	1
@@ -231,6 +232,7 @@ struct mm_struct {
 
 	/* Architecture-specific MM context */
 	mm_context_t context;
+	struct vx_info *mm_vx_info;
 };
 
 extern int mmlist_nr;
@@ -270,6 +272,7 @@ struct user_struct {
 	/* Hash table maintenance information */
 	struct user_struct *next, **pprev;
 	uid_t uid;
+	xid_t xid;
 };
 
 #define get_current_user() ({ 				\
@@ -404,6 +407,13 @@ struct task_struct {
 	unsigned long sas_ss_sp;
 	size_t sas_ss_size;
 	int (*notifier)(void *priv);
+
+/* vserver data */
+	__u32 cap_bset;
+	xid_t xid;
+	struct vx_info *vx_info;
+	struct ip_info *ip_info;
+
 	void *notifier_data;
 	sigset_t *notifier_mask;
 	
@@ -510,6 +520,10 @@ extern struct exec_domain	default_exec_d
     blocked:		{{0}},						\
     alloc_lock:		SPIN_LOCK_UNLOCKED,				\
     journal_info:	NULL,						\
+    cap_bset:		CAP_INIT_EFF_SET,				\
+    xid:		0,						\
+    vx_info:		NULL,						\
+    ip_info:		NULL,						\
 }
 
 
@@ -574,7 +588,7 @@ static inline void task_release_cpu(stru
 }
 
 /* per-UID process charging. */
-extern struct user_struct * alloc_uid(uid_t);
+extern struct user_struct * alloc_uid(xid_t, uid_t);
 extern void free_uid(struct user_struct *);
 extern void switch_uid(struct user_struct *);
 
@@ -757,7 +771,7 @@ static inline int capable(int cap)
 /*
  * Routines for handling mm_structs
  */
-extern struct mm_struct * mm_alloc(void);
+extern struct mm_struct * mm_alloc(struct vx_info *);
 
 extern struct mm_struct * start_lazy_tlb(void);
 extern void end_lazy_tlb(struct mm_struct *mm);
@@ -910,6 +924,10 @@ static inline void unhash_process(struct
 		out_of_line_bug();
 	write_lock_irq(&tasklist_lock);
 	nr_threads--;
+	if (p->vx_info) {
+		p->vx_info->virt.nr_threads--;
+		atomic_dec(&p->vx_info->limit.res[RLIMIT_NPROC]);
+	}
 	unhash_pid(p);
 	REMOVE_LINKS(p);
 	list_del(&p->thread_group);
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/sys.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/sys.h
--- linux-2.4.25-rc1/include/linux/sys.h	2003-06-13 16:51:39.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/sys.h	2004-02-06 02:52:25.000000000 +0100
@@ -4,7 +4,7 @@
 /*
  * system call entry points ... but not all are defined
  */
-#define NR_syscalls 270
+#define NR_syscalls 274
 
 /*
  * These are system calls that will be removed at some time
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/sysctl.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/sysctl.h
--- linux-2.4.25-rc1/include/linux/sysctl.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/sysctl.h	2004-02-06 02:52:25.000000000 +0100
@@ -128,6 +128,7 @@ enum
 	KERN_PPC_L3CR=57,       /* l3cr register on PPC */
 	KERN_EXCEPTION_TRACE=58, /* boolean: exception trace */
  	KERN_CORE_SETUID=59,	/* int: set to allow core dumps of setuid apps */
+	KERN_VSHELPER=60,	/* string: path to vshelper policy agent */
 };
 
 
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/types.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/types.h
--- linux-2.4.25-rc1/include/linux/types.h	2004-02-06 01:48:51.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/types.h	2004-02-06 02:52:25.000000000 +0100
@@ -33,6 +33,7 @@ typedef __kernel_uid32_t	uid_t;
 typedef __kernel_gid32_t	gid_t;
 typedef __kernel_uid16_t        uid16_t;
 typedef __kernel_gid16_t        gid16_t;
+typedef	unsigned int		xid_t;
 
 #ifdef CONFIG_UID16
 /* This is defined by include/asm-{arch}/posix_types.h */
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vinline.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vinline.h
--- linux-2.4.25-rc1/include/linux/vinline.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vinline.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,289 @@
+#ifndef _VX_INLINE_H
+#define _VX_INLINE_H
+
+
+// #define VX_DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#include <linux/vserver/context.h>
+#include <linux/vserver/network.h>
+
+#if defined(VX_DEBUG)
+#define vxdprintk(x...) printk("vxd: " x)
+#else
+#define vxdprintk(x...)
+#endif
+
+
+
+void free_vx_info(struct vx_info *);
+
+extern int proc_pid_vinfo(struct task_struct *, char *);
+
+
+#define get_vx_info(i)	__get_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ struct vx_info *__get_vx_info(struct vx_info *vxi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!vxi)
+		return NULL;
+	vxdprintk("get_vx_info(%p[#%d.%d])\t%s:%d\n", vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount),
+		_file, _line);
+	atomic_inc(&vxi->vx_refcount);
+	return vxi;
+}
+
+#define put_vx_info(i)	__put_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ void __put_vx_info(struct vx_info *vxi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!vxi)
+		return;
+	vxdprintk("put_vx_info(%p[#%d.%d])\t%s:%d\n", vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount),
+		_file, _line);
+	if (atomic_dec_and_lock(&vxi->vx_refcount, &vxlist_lock)) {
+		list_del(&vxi->vx_list);
+		spin_unlock(&vxlist_lock);
+		free_vx_info(vxi);
+	}
+}
+
+#define task_get_vx_info(i)	__task_get_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ struct vx_info *__task_get_vx_info(struct task_struct *p,
+	const char *_file, int _line)
+{
+	struct vx_info *vxi;
+	
+	task_lock(p);
+	vxi = __get_vx_info(p->vx_info, _file, _line);
+	task_unlock(p);
+	return vxi;
+}
+
+
+#define vx_verify_info(p,i)	\
+	__vx_verify_info((p)->vx_info,i,__FILE__,__LINE__)
+
+static __inline__ void __vx_verify_info(
+	struct vx_info *vxa, struct vx_info *vxb,
+	const char *_file, int _line)
+{
+	if (vxa == vxb)
+		return;
+	printk(KERN_ERR "vx bad assumption (%p==%p) at %s:%d\n",
+		vxa, vxb, _file, _line);
+}
+
+
+#define vx_task_xid(t)   ((t)->xid)
+
+#define vx_current_xid() vx_task_xid(current)
+
+#define vx_check(c,m)	__vx_check(vx_current_xid(),c,m)
+
+#define vx_weak_check(c,m)	((m) ? vx_check(c,m) : 1)
+
+/*
+ * check current context for ADMIN/WATCH and
+ * optionally agains supplied argument
+ */
+static __inline__ int __vx_check(xid_t cid, xid_t id, unsigned int mode)
+{
+	if (mode & VX_ARG_MASK) {
+		if ((mode & VX_IDENT) &&
+			(id == cid))
+			return 1;
+	}
+	if (mode & VX_ATR_MASK) {
+		if ((mode & VX_DYNAMIC) &&
+			(id >= MIN_D_CONTEXT) &&
+			(id <= MAX_S_CONTEXT))
+			return 1;
+		if ((mode & VX_STATIC) &&
+			(id > 1) && (id < MIN_D_CONTEXT))
+			return 1;
+	}
+	return (((mode & VX_ADMIN) && (cid == 0)) ||
+		((mode & VX_WATCH) && (cid == 1)));
+}
+
+
+
+void free_ip_info(struct ip_info *);
+
+#define get_ip_info(i)	__get_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ struct ip_info *__get_ip_info(struct ip_info *ipi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!ipi)
+		return NULL;
+	vxdprintk("get_ip_info(%p[%d])\t%s:%d\n", ipi,
+		atomic_read(&ipi->ip_refcount), _file, _line);
+	atomic_inc(&ipi->ip_refcount);
+	return ipi;
+}
+
+#define put_ip_info(i)	__put_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ void __put_ip_info(struct ip_info *ipi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!ipi)
+		return;
+	vxdprintk("put_ip_info(%p[%d])\t%s:%d\n", ipi,
+		atomic_read(&ipi->ip_refcount), _file, _line);
+	if (atomic_dec_and_lock(&ipi->ip_refcount, &iplist_lock)) {
+		list_del(&ipi->ip_list);
+		spin_unlock(&iplist_lock);
+		free_ip_info(ipi);
+	}
+}
+
+#define task_get_ip_info(i)	__task_get_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ struct ip_info *__task_get_ip_info(struct task_struct *p,
+	const char *_file, int _line)
+{
+	struct ip_info *ipi;
+	
+	task_lock(p);
+	ipi = __get_ip_info(p->ip_info, _file, _line);
+	task_unlock(p);
+	return ipi;
+}
+
+#define ip_verify_info(p,i)	\
+	__ip_verify_info((p)->ip_info,i,__FILE__,__LINE__)
+
+static __inline__ void __ip_verify_info(
+	struct ip_info *ipa, struct ip_info *ipb,
+	const char *_file, int _line)
+{
+	if (ipa == ipb)
+		return;
+	printk(KERN_ERR "ip bad assumption (%p==%p) at %s:%d\n",
+		ipa, ipb, _file, _line);
+}
+
+
+
+#define VX_DEBUG_ACC_RSS   0
+#define VX_DEBUG_ACC_VM    0
+#define VX_DEBUG_ACC_VML   0
+
+
+#define vx_acc_page(m, d, v, r) \
+	__vx_acc_page(&(m->v), m->mm_vx_info, r, d, __FILE__, __LINE__)
+
+static inline void __vx_acc_page(unsigned long *v, struct vx_info *vxi,
+                int res, int dir, char *file, int line)
+{
+        if (v) {
+                if (dir > 0)
+                        ++(*v);
+                else
+                        --(*v);
+        }
+        if (vxi) {
+                if (dir > 0)
+                        atomic_inc(&vxi->limit.res[res]);
+                else
+                        atomic_dec(&vxi->limit.res[res]);
+        }
+}
+
+
+#define vx_acc_pages(m, p, v, r) \
+	__vx_acc_pages(&(m->v), m->mm_vx_info, r, p, __FILE__, __LINE__)
+
+static inline void __vx_acc_pages(unsigned long *v, struct vx_info *vxi,
+                int res, int pages, char *file, int line)
+{
+        if ((pages > 1 || pages < -1) &&
+                ((res == RLIMIT_RSS && VX_DEBUG_ACC_RSS) ||
+                 (res == RLIMIT_AS && VX_DEBUG_ACC_VM) ||
+                 (res == RLIMIT_MEMLOCK && VX_DEBUG_ACC_VML)))
+                vxdprintk("vx_acc_pages  [%5d,%2d]: %5d += %5d in %s:%d\n",
+                        (vxi?vxi->vx_id:-1), res,
+                        (vxi?atomic_read(&vxi->limit.res[res]):0),
+			pages, file, line);
+        if (pages == 0)
+                return;
+        if (v)
+                *v += pages;
+        if (vxi)
+                atomic_add(pages, &vxi->limit.res[res]);
+}
+
+
+
+#define vx_acc_vmpage(m,d)     vx_acc_page(m, d, total_vm,  RLIMIT_AS)
+#define vx_acc_vmlpage(m,d)    vx_acc_page(m, d, locked_vm, RLIMIT_MEMLOCK)
+#define vx_acc_rsspage(m,d)    vx_acc_page(m, d, rss,	    RLIMIT_RSS)
+
+#define vx_acc_vmpages(m,p)    vx_acc_pages(m, p, total_vm,  RLIMIT_AS)
+#define vx_acc_vmlpages(m,p)   vx_acc_pages(m, p, locked_vm, RLIMIT_MEMLOCK)
+#define vx_acc_rsspages(m,p)   vx_acc_pages(m, p, rss,       RLIMIT_RSS)
+
+#define vx_pages_add(s,r,p)    __vx_acc_pages(0, s, r, p, __FILE__, __LINE__)
+#define vx_pages_sub(s,r,p)    __vx_pages_add(s, r, -(p))
+
+#define vx_vmpages_inc(m)      vx_acc_vmpage(m, 1)
+#define vx_vmpages_dec(m)      vx_acc_vmpage(m,-1)
+#define vx_vmpages_add(m,p)    vx_acc_vmpages(m, p)
+#define vx_vmpages_sub(m,p)    vx_acc_vmpages(m,-(p))
+
+#define vx_vmlocked_inc(m)     vx_acc_vmlpage(m, 1)
+#define vx_vmlocked_dec(m)     vx_acc_vmlpage(m,-1)
+#define vx_vmlocked_add(m,p)   vx_acc_vmlpages(m, p)
+#define vx_vmlocked_sub(m,p)   vx_acc_vmlpages(m,-(p))
+
+#define vx_rsspages_inc(m)     vx_acc_rsspage(m, 1)
+#define vx_rsspages_dec(m)     vx_acc_rsspage(m,-1)
+#define vx_rsspages_add(m,p)   vx_acc_rsspages(m, p)
+#define vx_rsspages_sub(m,p)   vx_acc_rsspages(m,-(p))
+
+
+
+#define vx_pages_avail(m, p, r) \
+        __vx_pages_avail((m)->mm_vx_info, (r), (p), __FILE__, __LINE__)
+
+static inline int __vx_pages_avail(struct vx_info *vxi,
+                int res, int pages, char *file, int line)
+{
+        if ((res == RLIMIT_RSS && VX_DEBUG_ACC_RSS) ||
+                (res == RLIMIT_AS && VX_DEBUG_ACC_VM) ||
+                (res == RLIMIT_MEMLOCK && VX_DEBUG_ACC_VML))
+                printk("vx_pages_avail[%5d,%2d]: %5ld > %5d + %5d in %s:%d\n",
+                        (vxi?vxi->vx_id:-1), res,
+			(vxi?vxi->limit.rlim[res]:1),
+                        (vxi?atomic_read(&vxi->limit.res[res]):0),
+			pages, file, line);
+        if (!vxi)
+                return 1;
+        if (vxi->limit.rlim[res] == RLIM_INFINITY)
+                return 1;
+        if (vxi->limit.rlim[res] < atomic_read(&vxi->limit.res[res]) + pages)
+                return 0;
+        return 1;
+}
+
+#define vx_vmpages_avail(m,p)  vx_pages_avail(m, p, RLIMIT_AS)
+#define vx_vmlocked_avail(m,p) vx_pages_avail(m, p, RLIMIT_MEMLOCK)
+#define vx_rsspages_avail(m,p) vx_pages_avail(m, p, RLIMIT_RSS)
+
+/* procfs ioctls */
+
+#define	FIOC_GETXFLG	_IOR('x', 5, long)
+#define	FIOC_SETXFLG	_IOW('x', 6, long)
+
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/context.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/context.h
--- linux-2.4.25-rc1/include/linux/vserver/context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/context.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,132 @@
+#ifndef _VX_CONTEXT_H
+#define _VX_CONTEXT_H
+
+	
+#include <linux/types.h>
+
+
+#define MAX_S_CONTEXT	65535	/* Arbitrary limit */
+#define MIN_D_CONTEXT	49152	/* dynamic contexts start here */
+
+#define VX_DYNAMIC_ID	(-1UL)	/* id for dynamic context */
+
+
+#include <linux/utsname.h>
+
+struct _vx_virt {
+	int nr_threads;
+	int nr_running;
+	int max_threads;
+	unsigned long total_forks;
+
+	unsigned int bias_cswtch;
+	long bias_jiffies;
+	long bias_idle;
+
+	struct new_utsname utsname;
+};
+
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#include <linux/vserver/limit.h>
+
+struct vx_info {
+	struct list_head vx_list;		/* linked list of contexts */
+	xid_t vx_id;				/* context id */
+	atomic_t vx_refcount;			/* refcount */
+	struct vx_info *vx_parent;		/* parent context */
+
+	struct proc_dir_entry *vx_procent;	/* proc entry */
+	unsigned int vx_flags;			/* VX_INFO_xxx */
+	pid_t vx_initpid;			/* PID of fake init process */
+
+	struct _vx_virt virt;			/* virtual/bias stuff */
+	struct _vx_limit limit;			/* vserver limits */
+
+	char vx_name[65];			/* vserver name */
+};
+
+
+extern spinlock_t vxlist_lock;
+extern struct list_head vx_infos;
+
+
+#define	VX_ADMIN	0x0001
+#define	VX_WATCH	0x0002
+#define VX_DUMMY	0x0008
+
+#define	VX_IDENT	0x0010
+#define	VX_EQUIV	0x0020
+#define	VX_PARENT	0x0040
+#define	VX_CHILD	0x0080
+
+#define	VX_ARG_MASK	0x00F0
+
+#define	VX_DYNAMIC	0x0100
+#define	VX_STATIC	0x0200
+
+#define	VX_ATR_MASK	0x0F00
+
+
+void free_vx_info(struct vx_info *);
+
+extern struct vx_info *find_vx_info(int);
+extern struct vx_info *find_or_create_vx_info(int);
+
+
+#include <linux/vserver/switch.h>
+
+/* vinfo commands */
+
+#define	VCMD_task_xid		VC_CMD(VINFO, 1, 0)
+#define	VCMD_task_nid		VC_CMD(VINFO, 2, 0)
+
+extern int vc_task_xid(uint32_t, void *);
+
+
+#define	VCMD_vx_info		VC_CMD(VINFO, 5, 0)
+#define	VCMD_nx_info		VC_CMD(VINFO, 6, 0)
+
+struct  vcmd_vx_info_v0 {
+	uint32_t xid;
+	uint32_t initpid;
+	/* more to come */	
+};
+
+extern int vc_vx_info(uint32_t, void *);
+
+
+/* virtual host info names */
+
+#define	VCMD_vx_set_vhi_name	VC_CMD(VHOST, 1, 0)
+#define	VCMD_vx_get_vhi_name	VC_CMD(VHOST, 2, 0)
+
+extern int vc_set_vhi_name(uint32_t, void *);
+extern int vc_get_vhi_name(uint32_t, void *);
+
+struct  vcmd_vx_vhi_name_v0 {
+	uint32_t field;
+	char name[65];
+};
+
+
+enum vx_vhi_name_field {
+	VHIN_CONTEXT=0,
+	VHIN_SYSNAME,
+	VHIN_NODENAME,
+	VHIN_RELEASE,
+	VHIN_VERSION,
+	VHIN_MACHINE,
+	VHIN_DOMAINNAME,
+};
+
+
+// EXPORT_SYMBOL_GPL(vxlist_lock);
+// EXPORT_SYMBOL_GPL(vx_infos);
+
+// EXPORT_SYMBOL_GPL(find_vx_info);
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/inode.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/inode.h
--- linux-2.4.25-rc1/include/linux/vserver/inode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/inode.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,41 @@
+#ifndef _VX_INODE_H
+#define _VX_INODE_H
+
+
+#include <linux/vserver/switch.h>
+
+/*  inode vserver commands */
+
+#define VCMD_get_iattr		VC_CMD(INODE, 1, 0)
+#define VCMD_set_iattr		VC_CMD(INODE, 2, 0)
+
+struct  vcmd_ctx_iattr_v0 {
+	/* device handle in id */
+	uint64_t ino;
+	uint32_t xid;
+	uint32_t flags;
+	uint32_t mask;
+};
+
+#define IATTR_XID	0x01000000
+
+#define IATTR_ADMIN	0x00000001
+#define IATTR_WATCH	0x00000002
+#define IATTR_HIDE	0x00000004
+#define IATTR_FLAGS	0x00000007
+
+#define IATTR_BARRIER	0x00010000
+#define	IATTR_IUNLINK	0x00020000
+
+
+extern int vc_get_iattr(uint32_t, void *);
+extern int vc_set_iattr(uint32_t, void *);
+
+
+/* inode ioctls */
+
+#define	FIOC_GETXFLG	_IOR('x', 5, long)
+#define	FIOC_SETXFLG	_IOW('x', 6, long)
+
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/legacy.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/legacy.h
--- linux-2.4.25-rc1/include/linux/vserver/legacy.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/legacy.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,57 @@
+#ifndef _VX_LEGACY_H
+#define _VX_LEGACY_H
+
+
+#include <linux/vserver/switch.h>
+#include <linux/vserver/network.h>
+
+/*  compatibiliy vserver commands */
+
+#define VCMD_new_s_context	VC_CMD(COMPAT, 1, 1)
+#define VCMD_set_ipv4root	VC_CMD(COMPAT, 2, 3)
+
+/*  compatibiliy vserver arguments */
+
+struct  vcmd_new_s_context_v1 {
+	uint32_t remove_cap;
+	uint32_t flags;
+};
+
+struct  vcmd_set_ipv4root_v3 {
+	/* number of pairs in id */
+	uint32_t broadcast;
+	struct {
+		uint32_t ip;
+		uint32_t mask;
+	} ip_mask_pair[NB_IPV4ROOT];
+};
+
+
+#define VX_INFO_LOCK		1	/* Can't request a new vx_id */
+#define VX_INFO_SCHED		2	/* All process in the vx_id */
+					/* Contribute to the schedular */
+#define VX_INFO_NPROC		4	/* Limit number of processes in a context */
+#define VX_INFO_PRIVATE		8	/* Noone can join this security context */
+#define VX_INFO_INIT		16	/* This process wants to become the */
+					/* logical process 1 of the security */
+					/* context */
+#define VX_INFO_HIDEINFO	32	/* Hide some information in /proc */
+#define VX_INFO_ULIMIT		64	/* Use ulimit of the current process */
+					/* to become the global limits */
+					/* of the context */
+	
+#define MAX_S_CONTEXT	65535	/* Arbitrary limit */
+#define MIN_D_CONTEXT	49152	/* dynamic contexts start here */
+
+#define VX_DYNAMIC_ID	(-1UL)	/* id for dynamic context */
+
+#define NB_S_CONTEXT	16
+
+#define NB_IPV4ROOT	16
+
+
+extern int vc_new_s_context(uint32_t, void *);
+extern int vc_set_ipv4root(uint32_t, void *);
+
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/limit.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/limit.h
--- linux-2.4.25-rc1/include/linux/vserver/limit.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/limit.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,49 @@
+#ifndef _VX_LIMIT_H
+#define _VX_LIMIT_H
+
+
+#include <linux/vserver/switch.h>
+
+/*  rlimit vserver commands */
+
+#define VCMD_get_rlimit		VC_CMD(RLIMIT, 1, 0)
+#define VCMD_set_rlimit		VC_CMD(RLIMIT, 2, 0)
+#define VCMD_get_rlimit_mask	VC_CMD(RLIMIT, 3, 0)
+
+struct  vcmd_ctx_rlimit_v0 {
+	uint32_t id;
+	uint64_t minimum;
+	uint64_t softlimit;
+	uint64_t maximum;
+};
+
+struct  vcmd_ctx_rlimit_mask_v0 {
+	uint32_t minimum;
+	uint32_t softlimit;
+	uint32_t maximum;
+};
+
+#define CRLIM_UNSET		(0ULL)
+#define CRLIM_INFINITY		(~0ULL)
+#define CRLIM_KEEP		(~1ULL)
+
+
+extern int vc_get_rlimit(uint32_t, void *);
+extern int vc_set_rlimit(uint32_t, void *);
+extern int vc_get_rlimit_mask(uint32_t, void *);
+
+
+#include <asm/atomic.h>
+#include <asm/resource.h>
+
+/* context sub struct */
+
+struct _vx_limit {
+	atomic_t ticks;
+
+	unsigned long rlim[RLIM_NLIMITS];	/* Per context limit */
+	atomic_t res[RLIM_NLIMITS];		/* Current value */
+};
+
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/network.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/network.h
--- linux-2.4.25-rc1/include/linux/vserver/network.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/network.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,43 @@
+#ifndef _VX_NETWORK_H
+#define _VX_NETWORK_H
+
+
+#define NB_IPV4ROOT	16
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/utsname.h>
+#include <asm/resource.h>
+#include <asm/atomic.h>
+
+
+struct ip_info {
+	struct list_head ip_list;		/* linked list of ipinfos */
+	atomic_t ip_refcount;
+	int nbipv4;
+	__u32 ipv4[NB_IPV4ROOT];/* Process can only bind to these IPs */
+				/* The first one is used to connect */
+				/* and for bind any service */
+				/* The other must be used explicity when */
+				/* binding */
+	__u32 mask[NB_IPV4ROOT];/* Netmask for each ipv4 */
+				/* Used to select the proper source address */
+				/* for sockets */
+	__u32 v4_bcast;	/* Broadcast address used to receive UDP packets */
+};
+
+
+extern spinlock_t iplist_lock;
+extern struct list_head ip_infos;
+
+
+void free_ip_info(struct ip_info *);
+struct ip_info *create_ip_info(void);
+
+
+// EXPORT_SYMBOL_GPL(iplist_lock);
+// EXPORT_SYMBOL_GPL(ip_infos);
+
+// EXPORT_SYMBOL_GPL(find_ip_info);
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/signal.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/signal.h
--- linux-2.4.25-rc1/include/linux/vserver/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/signal.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef _VX_SIGNAL_H
+#define _VX_SIGNAL_H
+
+	
+#include <linux/vserver/switch.h>
+
+/*  context signalling */
+
+#define VCMD_ctx_kill		VC_CMD(PROCTRL, 1, 0)
+
+struct  vcmd_ctx_kill_v0 {
+	int32_t pid;
+	int32_t sig;
+};
+
+
+extern int vc_ctx_kill(uint32_t, void *);
+
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver/switch.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/switch.h
--- linux-2.4.25-rc1/include/linux/vserver/switch.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver/switch.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,82 @@
+#ifndef _LINUX_VIRTUAL_H
+#define _LINUX_VIRTUAL_H
+
+#include <linux/types.h>
+
+#define VC_CATEGORY(c)		(((c) >> 24) & 0x3F)
+#define VC_COMMAND(c)		(((c) >> 16) & 0xFF)
+#define VC_VERSION(c)		((c) & 0xFFF)
+
+#define VC_CMD(c,i,v)		((((VC_CAT_ ## c) & 0x3F) << 24) \
+				| (((i) & 0xFF) << 16) | ((v) & 0xFFF))
+
+/*
+
+  Syscall Matrix V2.4
+
+         |VERSION|CREATE |MODIFY |MIGRATE|CONTROL|EXPERIM| |SPECIAL|SPECIAL|
+         |STATS  |DESTROY|ALTER  |CHANGE |LIMIT  |TEST   | |       |       |
+         |INFO   |SETUP  |       |MOVE   |       |       | |       |       |
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  SYSTEM |VERSION|       |       |       |       |       | |DEVICES|       |
+  HOST   |     00|     01|     02|     03|     04|     05| |     06|     07|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  CPU    |       |       |       |       |       |       | |SCHED. |       |
+  PROCESS|     08|     09|     10|     11|     12|     13| |     14|     15|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  MEMORY |       |       |       |       |       |       | |SWAP   |       |
+         |     16|     17|     18|     19|     20|     21| |     22|     23|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  NETWORK|       |       |       |       |       |       | |SERIAL |       |
+         |     24|     25|     26|     27|     28|     29| |     30|     31|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  DISK   |       |       |       |       |       |       | |INODE  |       |
+  VFS    |     32|     33|     34|     35|     36|     37| |     38|     39|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  OTHER  |       |       |       |       |       |       | |VINFO  |       |
+         |     40|     41|     42|     43|     44|     45| |     46|     47|
+  =======+=======+=======+=======+=======+=======+=======+ +=======+=======+
+  SPECIAL|       |       |       |       |       |       | |       |       |
+         |     48|     49|     50|     51|     52|     53| |     54|     55|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  SPECIAL|       |       |       |       |RLIMIT |SYSCALL| |       |COMPAT |
+         |     56|     57|     58|     59|     60|TEST 61| |     62|     63|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+
+*/
+
+#define VC_CAT_VERSION		0
+
+#define	VC_CAT_VHOST		2
+	
+#define VC_CAT_PROCTRL		12
+
+#define VC_CAT_SCHED		14
+#define VC_CAT_INODE		38
+
+#define	VC_CAT_VINFO		46
+
+#define VC_CAT_RLIMIT		60
+
+#define VC_CAT_SYSTEST		61
+#define VC_CAT_COMPAT		63
+	
+/*  interface version */
+
+#define VCI_VERSION		0x00010010
+
+
+/*  query version */
+
+#define VCMD_get_version	VC_CMD(VERSION, 0, 0)
+
+
+#include <linux/errno.h>
+
+#define	ENOTSUP		ENOTSUPP
+
+
+// EXPORT_SYMBOL_GPL(sys_vserver);
+
+
+#endif /* _LINUX_VIRTUAL_H */
diff -NurpP --minimal linux-2.4.25-rc1/include/linux/vserver.h linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver.h
--- linux-2.4.25-rc1/include/linux/vserver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/linux/vserver.h	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef _LINUX_VSERVER_H
+#define _LINUX_VSERVER_H
+
+#include <linux/vserver/context.h>
+#include <linux/vserver/network.h>
+#include <linux/vinline.h>
+
+#endif
diff -NurpP --minimal linux-2.4.25-rc1/include/net/route.h linux-2.4.25-rc1-vs1.3.6.3/include/net/route.h
--- linux-2.4.25-rc1/include/net/route.h	2004-02-01 22:14:41.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/net/route.h	2004-02-06 02:52:25.000000000 +0100
@@ -32,6 +32,7 @@
 #include <linux/route.h>
 #include <linux/ip.h>
 #include <linux/cache.h>
+#include <linux/vinline.h>
 
 #ifndef __KERNEL__
 #warning This file is not supposed to be used outside of kernel.
@@ -166,6 +167,44 @@ static inline char rt_tos2priority(u8 to
 static inline int ip_route_connect(struct rtable **rp, u32 dst, u32 src, u32 tos, int oif)
 {
 	int err;
+	struct ip_info *ip_info = current->ip_info;
+	if (ip_info != NULL) {
+		__u32 ipv4root = ip_info->ipv4[0];
+		if (ipv4root != 0) {
+			int n = ip_info->nbipv4;
+			if (dst == 0x0100007f && !vx_check(0, VX_ADMIN))
+				dst = ipv4root;
+			if (src == 0) {
+				if (n > 1) {
+					u32 foundsrc;
+					int i;
+					err = ip_route_output(rp, dst, src, tos, oif);
+					if (err) return err;
+					foundsrc = (*rp)->rt_src;
+					ip_rt_put(*rp);
+					for (i=0; i<n; i++){
+						u32 mask = ip_info->mask[i];
+						u32 ipv4 = ip_info->ipv4[i];
+						u32 netipv4 = ipv4 & mask;
+						if ((foundsrc & mask) == netipv4) {
+							src = ipv4;
+							break;
+						}
+					}
+				}
+				if (src == 0)
+					src = dst == 0x0100007f
+						? 0x0100007f: ipv4root;
+			} else {
+				int i;
+				for (i=0; i<n; i++) {
+					if (ip_info->ipv4[i] == src) break;
+				}
+				if (i == n)
+					return -EPERM;
+			}
+		}
+	}
 	err = ip_route_output(rp, dst, src, tos, oif);
 	if (err || (dst && src))
 		return err;
diff -NurpP --minimal linux-2.4.25-rc1/include/net/sock.h linux-2.4.25-rc1-vs1.3.6.3/include/net/sock.h
--- linux-2.4.25-rc1/include/net/sock.h	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/net/sock.h	2004-02-06 02:52:25.000000000 +0100
@@ -501,6 +501,7 @@ do {	spin_lock_init(&((__sk)->lock.slock
 } while(0)
 
 struct sock {
+	/* See tcp.h comment on tcp_tw_bucket */
 	/* Socket demultiplex comparisons on incoming packets. */
 	__u32			daddr;		/* Foreign IPv4 addr			*/
 	__u32			rcv_saddr;	/* Bound local IPv4 addr		*/
@@ -522,6 +523,8 @@ struct sock {
 	unsigned char		reuse;		/* SO_REUSEADDR setting			*/
 	unsigned char		shutdown;
 	atomic_t		refcnt;		/* Reference count			*/
+	struct ip_info		*ip_info;
+	/* End of common section with tcp_tw_bucket */
 
 	socket_lock_t		lock;		/* Synchronizer...			*/
 	int			rcvbuf;		/* Size of receive buffer in bytes	*/
@@ -539,6 +542,7 @@ struct sock {
 	__u32			saddr;		/* Sending source			*/
 	unsigned int		allocation;	/* Allocation mode			*/
 	int			sndbuf;		/* Size of send buffer in bytes		*/
+	__u32			rcv_saddr2;	/* Second bound ipv4 addr, for ipv4root */
 	struct sock		*prev;
 
 	/* Not all are volatile, but some are, so we might as well say they all are.
@@ -686,6 +690,9 @@ struct sock {
 	/* RPC layer private data */
 	void			*user_data;
   
+	/* Context of process creating this socket */
+	xid_t			xid;
+
 	/* Callbacks */
 	void			(*state_change)(struct sock *sk);
 	void			(*data_ready)(struct sock *sk,int bytes);
diff -NurpP --minimal linux-2.4.25-rc1/include/net/tcp.h linux-2.4.25-rc1-vs1.3.6.3/include/net/tcp.h
--- linux-2.4.25-rc1/include/net/tcp.h	2004-02-01 22:17:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/include/net/tcp.h	2004-02-06 02:52:25.000000000 +0100
@@ -173,6 +173,7 @@ struct tcp_tw_bucket {
 	unsigned char		reuse,
 				rcv_wscale; /* It is also TW bucket specific */
 	atomic_t		refcnt;
+	struct ip_info		*ip_info;
 
 	/* And these are ours. */
 	int			hashent;
@@ -191,6 +192,7 @@ struct tcp_tw_bucket {
 	struct in6_addr		v6_daddr;
 	struct in6_addr		v6_rcv_saddr;
 #endif
+	xid_t			xid;
 };
 
 extern kmem_cache_t *tcp_timewait_cachep;
diff -NurpP --minimal linux-2.4.25-rc1/ipc/util.c linux-2.4.25-rc1-vs1.3.6.3/ipc/util.c
--- linux-2.4.25-rc1/ipc/util.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/ipc/util.c	2004-02-06 02:52:25.000000000 +0100
@@ -93,6 +93,8 @@ int ipc_findkey(struct ipc_ids* ids, key
 	struct kern_ipc_perm* p;
 
 	for (id = 0; id <= ids->max_id; id++) {
+		if (!vx_check(ids->entries[id].xid, VX_IDENT))
+			continue;
 		p = ids->entries[id].p;
 		if(p==NULL)
 			continue;
@@ -167,6 +169,7 @@ found:
 
 	spin_lock(&ids->ary);
 	ids->entries[id].p = new;
+	ids->entries[id].xid = vx_current_xid();
 	return id;
 }
 
diff -NurpP --minimal linux-2.4.25-rc1/ipc/util.h linux-2.4.25-rc1-vs1.3.6.3/ipc/util.h
--- linux-2.4.25-rc1/ipc/util.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/ipc/util.h	2004-02-06 02:52:25.000000000 +0100
@@ -5,6 +5,8 @@
  * ipc helper functions (c) 1999 Manfred Spraul <manfreds@colorfullife.com>
  */
 
+#include <linux/vinline.h>
+
 #define USHRT_MAX 0xffff
 #define SEQ_MULTIPLIER	(IPCMNI)
 
@@ -25,6 +27,7 @@ struct ipc_ids {
 
 struct ipc_id {
 	struct kern_ipc_perm* p;
+	xid_t xid;
 };
 
 
@@ -74,8 +77,11 @@ extern inline struct kern_ipc_perm* ipc_
 
 	spin_lock(&ids->ary);
 	out = ids->entries[lid].p;
-	if(out==NULL)
+	if (out==NULL ||
+		!vx_check(ids->entries[lid].xid, VX_WATCH|VX_IDENT)) {
 		spin_unlock(&ids->ary);
+		out = NULL;
+	}
 	return out;
 }
 
diff -NurpP --minimal linux-2.4.25-rc1/kernel/Makefile linux-2.4.25-rc1-vs1.3.6.3/kernel/Makefile
--- linux-2.4.25-rc1/kernel/Makefile	2001-09-17 06:22:40.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/Makefile	2004-02-06 02:52:25.000000000 +0100
@@ -16,6 +16,11 @@ obj-y     = sched.o dma.o fork.o exec_do
 	    sysctl.o acct.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o context.o
 
+# mod-subdirs := vserver
+
+subdir-y  += vserver
+obj-y	  += vserver/vserver.o
+
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += ksyms.o
 obj-$(CONFIG_PM) += pm.o
diff -NurpP --minimal linux-2.4.25-rc1/kernel/exit.c linux-2.4.25-rc1-vs1.3.6.3/kernel/exit.c
--- linux-2.4.25-rc1/kernel/exit.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/exit.c	2004-02-06 02:52:25.000000000 +0100
@@ -16,6 +16,7 @@
 #ifdef CONFIG_BSD_PROCESS_ACCT
 #include <linux/acct.h>
 #endif
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -29,6 +30,9 @@ int getrusage(struct task_struct *, int,
 static void release_task(struct task_struct * p)
 {
 	if (p != current) {
+		struct vx_info *vxi = p->vx_info;
+		struct ip_info *ipi = p->ip_info;
+
 #ifdef CONFIG_SMP
 		/*
 		 * Wait to make sure the process isn't on the
@@ -66,6 +70,20 @@ static void release_task(struct task_str
 		current->counter += p->counter;
 		if (current->counter >= MAX_COUNTER)
 			current->counter = MAX_COUNTER;
+
+		if (vxi) {
+			task_lock(p);
+			p->vx_info = NULL;
+			p->xid = 0;
+			task_unlock(p);
+			put_vx_info(vxi);
+		}
+		if (ipi) {
+			task_lock(p);
+			p->ip_info = NULL;
+			task_unlock(p);
+			put_ip_info(ipi);
+		}
 		p->pid = 0;
 		free_task_struct(p);
 	} else {
@@ -159,8 +177,18 @@ static inline int has_stopped_jobs(int p
 static inline void forget_original_parent(struct task_struct * father)
 {
 	struct task_struct * p;
+	struct task_struct *vchild_reaper = child_reaper;
 
 	read_lock(&tasklist_lock);
+	if (father->vx_info) {
+		pid_t initpid = father->vx_info->vx_initpid;
+		if ((initpid != 0) && (father->pid != initpid)) {
+			struct task_struct *r = find_task_by_pid(initpid);
+
+			if (r != NULL)
+				vchild_reaper = r;
+		}
+	}
 
 	for_each_task(p) {
 		if (p->p_opptr == father) {
@@ -169,7 +197,7 @@ static inline void forget_original_paren
 			p->self_exec_id++;
 
 			/* Make sure we're not reparenting to ourselves */
-			p->p_opptr = child_reaper;
+			p->p_opptr = vchild_reaper;
 
 			if (p->pdeath_signal) send_sig(p->pdeath_signal, p, 0);
 		}
diff -NurpP --minimal linux-2.4.25-rc1/kernel/fork.c linux-2.4.25-rc1-vs1.3.6.3/kernel/fork.c
--- linux-2.4.25-rc1/kernel/fork.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/fork.c	2004-02-06 02:52:25.000000000 +0100
@@ -22,6 +22,7 @@
 #include <linux/namespace.h>
 #include <linux/personality.h>
 #include <linux/compiler.h>
+#include <linux/vinline.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -229,7 +230,7 @@ int mmlist_nr;
 #define allocate_mm()	(kmem_cache_alloc(mm_cachep, SLAB_KERNEL))
 #define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))
 
-static struct mm_struct * mm_init(struct mm_struct * mm)
+static struct mm_struct * mm_init(struct mm_struct * mm, struct vx_info *vxi)
 {
 	atomic_set(&mm->mm_users, 1);
 	atomic_set(&mm->mm_count, 1);
@@ -237,6 +238,7 @@ static struct mm_struct * mm_init(struct
 	mm->page_table_lock = SPIN_LOCK_UNLOCKED;
 	mm->pgd = pgd_alloc(mm);
 	mm->def_flags = 0;
+	mm->mm_vx_info = get_vx_info(vxi);
 	if (mm->pgd)
 		return mm;
 	free_mm(mm);
@@ -247,14 +249,14 @@ static struct mm_struct * mm_init(struct
 /*
  * Allocate and initialize an mm_struct.
  */
-struct mm_struct * mm_alloc(void)
+struct mm_struct * mm_alloc(struct vx_info *vxi)
 {
 	struct mm_struct * mm;
 
 	mm = allocate_mm();
 	if (mm) {
 		memset(mm, 0, sizeof(*mm));
-		return mm_init(mm);
+		return mm_init(mm, vxi);
 	}
 	return NULL;
 }
@@ -270,6 +272,7 @@ inline void __mmdrop(struct mm_struct *m
 	pgd_free(mm->pgd);
 	check_pgt_cache();
 	destroy_context(mm);
+	put_vx_info(mm->mm_vx_info);
 	free_mm(mm);
 }
 
@@ -349,7 +352,7 @@ static int copy_mm(unsigned long clone_f
 
 	/* Copy the current MM stuff.. */
 	memcpy(mm, oldmm, sizeof(*mm));
-	if (!mm_init(mm))
+	if (!mm_init(mm, current->vx_info))
 		goto fail_nomem;
 
 	if (init_new_context(tsk,mm))
@@ -641,6 +644,7 @@ int do_fork(unsigned long clone_flags, u
 	int retval;
 	struct task_struct *p;
 	struct completion vfork;
+	struct vx_info *vxi;
 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return -EINVAL;
@@ -661,9 +665,14 @@ int do_fork(unsigned long clone_flags, u
 	if (!p)
 		goto fork_out;
 
+	retval = -EAGAIN;
 	*p = *current;
+	vxi = get_vx_info(current->vx_info);
+	get_ip_info(current->ip_info);
 
-	retval = -EAGAIN;
+	if (vxi && (atomic_read(&vxi->limit.res[RLIMIT_NPROC])
+		>= vxi->limit.rlim[RLIMIT_NPROC]))
+		goto bad_fork_free;
 	/*
 	 * Check if we are over our maximum process limit, but be sure to
 	 * exclude root. This is needed to make it possible for login and
@@ -757,6 +766,13 @@ int do_fork(unsigned long clone_flags, u
 	if (retval)
 		goto bad_fork_cleanup_namespace;
 	p->semundo = NULL;
+
+        if (p->mm && !(clone_flags & CLONE_VM)) {
+                if (vx_vmpages_avail(p->mm, p->mm->total_vm))
+                        vx_pages_add(p->mm->mm_vx_info, RLIMIT_AS, p->mm->total_vm);
+                else
+                        goto bad_fork_cleanup_namespace;
+        }
 	
 	/* Our parent execution domain becomes current domain
 	   These must match for thread signalling to apply */
@@ -809,6 +825,10 @@ int do_fork(unsigned long clone_flags, u
 	SET_LINKS(p);
 	hash_pid(p);
 	nr_threads++;
+	if (vxi) {
+		vxi->virt.nr_threads++;
+		atomic_inc(&vxi->limit.res[RLIMIT_NPROC]);
+	}
 	write_unlock_irq(&tasklist_lock);
 
 	if (p->ptrace & PT_PTRACED)
@@ -816,6 +836,8 @@ int do_fork(unsigned long clone_flags, u
 
 	wake_up_process(p);		/* do this last */
 	++total_forks;
+	if (vxi)
+		vxi->virt.total_forks++;
 	if (clone_flags & CLONE_VFORK)
 		wait_for_completion(&vfork);
 
@@ -840,6 +862,8 @@ bad_fork_cleanup_count:
 	atomic_dec(&p->user->processes);
 	free_uid(p->user);
 bad_fork_free:
+	put_ip_info(current->ip_info);
+	put_vx_info(vxi);
 	free_task_struct(p);
 	goto fork_out;
 }
diff -NurpP --minimal linux-2.4.25-rc1/kernel/info.c linux-2.4.25-rc1-vs1.3.6.3/kernel/info.c
--- linux-2.4.25-rc1/kernel/info.c	2001-04-21 01:15:40.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/info.c	2004-02-06 02:52:25.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/unistd.h>
 #include <linux/swap.h>
 #include <linux/smp_lock.h>
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 
@@ -20,13 +21,19 @@ asmlinkage long sys_sysinfo(struct sysin
 	memset((char *)&val, 0, sizeof(struct sysinfo));
 
 	cli();
-	val.uptime = jiffies / HZ;
+	if (vx_check(0, VX_ADMIN|VX_WATCH)) {
+		val.uptime = jiffies / HZ;
+		val.procs = nr_threads-1;
+	} else {
+		struct vx_info *vxi = current->vx_info;
+
+		val.uptime = (jiffies - vxi->virt.bias_jiffies) / HZ;
+		val.procs = vxi->virt.nr_threads;
+	}
 
 	val.loads[0] = avenrun[0] << (SI_LOAD_SHIFT - FSHIFT);
 	val.loads[1] = avenrun[1] << (SI_LOAD_SHIFT - FSHIFT);
 	val.loads[2] = avenrun[2] << (SI_LOAD_SHIFT - FSHIFT);
-
-	val.procs = nr_threads-1;
 	sti();
 
 	si_meminfo(&val);
diff -NurpP --minimal linux-2.4.25-rc1/kernel/printk.c linux-2.4.25-rc1-vs1.3.6.3/kernel/printk.c
--- linux-2.4.25-rc1/kernel/printk.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/printk.c	2004-02-06 02:52:25.000000000 +0100
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 
@@ -176,6 +177,9 @@ int do_syslog(int type, char * buf, int 
 	char c;
 	int error = 0;
 
+	if (!capable(CAP_SYS_ADMIN) && !vx_check(0, VX_ADMIN))
+		return -EPERM;
+
 	switch (type) {
 	case 0:		/* Close log */
 		break;
diff -NurpP --minimal linux-2.4.25-rc1/kernel/sched.c linux-2.4.25-rc1-vs1.3.6.3/kernel/sched.c
--- linux-2.4.25-rc1/kernel/sched.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/sched.c	2004-02-06 02:52:25.000000000 +0100
@@ -29,6 +29,8 @@
 #include <linux/completion.h>
 #include <linux/prefetch.h>
 #include <linux/compiler.h>
+#include <linux/vinline.h>
+#include <linux/vserver/legacy.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -165,7 +167,16 @@ static inline int goodness(struct task_s
 		 * Don't do any other calculations if the time slice is
 		 * over..
 		 */
-		weight = p->counter;
+		struct vx_info *vxi = p->vx_info;
+
+		if (vxi && (vxi->vx_flags & VX_INFO_SCHED)) {
+			weight = atomic_read(&vxi->limit.ticks) /
+				atomic_read(&vxi->limit.res[RLIMIT_NPROC]);
+			weight = (weight+p->counter) >> 1;
+		} else
+			weight = p->counter;
+
+		vx_verify_info(p, vxi);
 		if (!weight)
 			goto out;
 			
@@ -615,11 +626,27 @@ repeat_schedule:
 	/* Do we need to re-calculate counters? */
 	if (unlikely(!c)) {
 		struct task_struct *p;
+		struct vx_info *vxi;
 
 		spin_unlock_irq(&runqueue_lock);
 		read_lock(&tasklist_lock);
-		for_each_task(p)
+		/*
+			Reset the s_info->ticks to the sum off all
+			member processes p->counter
+		*/
+
+		spin_lock(&vxlist_lock);
+		list_for_each_entry(vxi, &vx_infos, vx_list)
+			atomic_set(&vxi->limit.ticks, 0);
+		spin_unlock(&vxlist_lock);
+
+		for_each_task(p) {
+			vxi = p->vx_info;
 			p->counter = (p->counter >> 1) + NICE_TO_TICKS(p->nice);
+			if (vxi && (vxi->vx_flags & VX_INFO_SCHED))
+				atomic_add(p->counter, &vxi->limit.ticks);
+			vx_verify_info(p, vxi);
+		}
 		read_unlock(&tasklist_lock);
 		spin_lock_irq(&runqueue_lock);
 		goto repeat_schedule;
diff -NurpP --minimal linux-2.4.25-rc1/kernel/signal.c linux-2.4.25-rc1-vs1.3.6.3/kernel/signal.c
--- linux-2.4.25-rc1/kernel/signal.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/signal.c	2004-02-06 02:52:25.000000000 +0100
@@ -13,6 +13,7 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 
@@ -621,7 +622,9 @@ kill_pg_info(int sig, struct siginfo *in
 		retval = -ESRCH;
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
-			if (p->pgrp == pgrp && thread_group_leader(p)) {
+			if (p->pgrp == pgrp && thread_group_leader(p) &&
+				((long)info == 1 ||
+				vx_check(vx_task_xid(p), VX_IDENT))) {
 				int err = send_sig_info(sig, info, p);
 				if (retval)
 					retval = err;
@@ -675,7 +678,20 @@ kill_proc_info(int sig, struct siginfo *
                        if (tg)
                                p = tg;
                 }
-		error = send_sig_info(sig, info, p);
+		switch ((unsigned long)info) {
+		case 0:
+			if (vx_check(vx_task_xid(p), VX_IDENT))
+				error = send_sig_info(sig, info, p);
+			break;
+		case 1:
+			error = send_sig_info(sig, info, p);
+			break;
+		default:
+			if ((info->si_code == SI_KERNEL)
+				|| vx_check(vx_task_xid(p), VX_IDENT))
+				error = send_sig_info(sig, info, p);
+			break;
+		}
 	}
 	read_unlock(&tasklist_lock);
 	return error;
@@ -699,7 +715,9 @@ static int kill_something_info(int sig, 
 
 		read_lock(&tasklist_lock);
 		for_each_task(p) {
-			if (p->pid > 1 && p != current && thread_group_leader(p)) {
+			if (p->pid > 1 && p != current &&
+				thread_group_leader(p) &&
+				vx_check(vx_task_xid(p), VX_IDENT)) {
 				int err = send_sig_info(sig, info, p);
 				++count;
 				if (err != -EPERM)
diff -NurpP --minimal linux-2.4.25-rc1/kernel/sys.c linux-2.4.25-rc1-vs1.3.6.3/kernel/sys.c
--- linux-2.4.25-rc1/kernel/sys.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/sys.c	2004-02-06 02:52:25.000000000 +0100
@@ -10,10 +10,12 @@
 #include <linux/mman.h>
 #include <linux/smp_lock.h>
 #include <linux/notifier.h>
+#include <linux/kmod.h>
 #include <linux/reboot.h>
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -277,6 +279,67 @@ asmlinkage long sys_getpriority(int whic
 	return retval;
 }
 
+/*
+ *      vshelper path is set via /proc/sys
+ *      invoked by vserver sys_reboot(), with
+ *      the following arguments
+ *
+ *      argv [0] = vshelper_path;
+ *      argv [1] = action: "restart", "halt", "poweroff", ...
+ *      argv [2] = context identifier
+ *      argv [3] = additional argument (restart2)
+ *
+ *      envp [*] = type-specific parameters
+ */
+char vshelper_path[255] = "/sbin/vshelper";
+
+long vs_reboot(unsigned int cmd, void * arg)
+{
+	char id_buf[8], cmd_buf[32];
+	char uid_buf[32], pid_buf[32];
+	char buffer[256];
+
+	char *argv[] = {vshelper_path, NULL, id_buf, NULL, 0};
+	char *envp[] = {"HOME=/", "TERM=linux",
+			"PATH=/sbin:/usr/sbin:/bin:/usr/bin",
+			uid_buf, pid_buf, cmd_buf, 0};
+
+	snprintf(id_buf, sizeof(id_buf)-1, "%d", vx_current_xid());
+
+	snprintf(cmd_buf, sizeof(cmd_buf)-1, "VS_CMD=%08x", cmd);
+	snprintf(uid_buf, sizeof(uid_buf)-1, "VS_UID=%d", current->uid);
+	snprintf(pid_buf, sizeof(pid_buf)-1, "VS_PID=%d", current->pid);
+
+	switch (cmd) {
+	case LINUX_REBOOT_CMD_RESTART:
+		argv[1] = "restart";
+		break;	
+
+	case LINUX_REBOOT_CMD_HALT:
+		argv[1] = "halt";
+		break;	
+
+	case LINUX_REBOOT_CMD_POWER_OFF:
+		argv[1] = "poweroff";
+		break;	
+
+	case LINUX_REBOOT_CMD_RESTART2:
+		if (strncpy_from_user(&buffer[0], (char *)arg, sizeof(buffer) - 1) < 0)
+			return -EFAULT;
+		argv[3] = buffer;
+	default:
+		argv[1] = "restart2";
+		break;	
+	}
+
+	if (call_usermodehelper(*argv, argv, envp)) {
+		printk( KERN_WARNING
+			"vs_reboot(): failed to exec (%s %s %s %s)\n",
+			vshelper_path, argv[1], argv[2], argv[3]);
+		return -EPERM;
+	}
+	return 0;
+}
 
 /*
  * Reboot system call: for obvious reasons only root may call it,
@@ -300,6 +363,9 @@ asmlinkage long sys_reboot(int magic1, i
 			magic2 != LINUX_REBOOT_MAGIC2B))
 		return -EINVAL;
 
+	if (!vx_check(0, VX_ADMIN|VX_WATCH))
+		return vs_reboot(cmd, arg);
+
 	lock_kernel();
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
@@ -513,7 +579,7 @@ static int set_user(uid_t new_ruid, int 
 {
 	struct user_struct *new_user;
 
-	new_user = alloc_uid(new_ruid);
+	new_user = alloc_uid(vx_current_xid(), new_ruid);
 	if (!new_user)
 		return -EAGAIN;
 	switch_uid(new_user);
@@ -1025,9 +1091,16 @@ DECLARE_RWSEM(uts_sem);
 asmlinkage long sys_newuname(struct new_utsname * name)
 {
 	int errno = 0;
+	struct new_utsname tmp,*pttmp;
 
 	down_read(&uts_sem);
-	if (copy_to_user(name,&system_utsname,sizeof *name))
+	if (current->vx_info) {
+		tmp = current->vx_info->virt.utsname;
+		pttmp = &tmp;
+	}
+	else
+		pttmp = &system_utsname;
+	if (copy_to_user(name,pttmp,sizeof *name))
 		errno = -EFAULT;
 	up_read(&uts_sem);
 	return errno;
@@ -1036,6 +1109,7 @@ asmlinkage long sys_newuname(struct new_
 asmlinkage long sys_sethostname(char *name, int len)
 {
 	int errno;
+	char *nodename;
 	char tmp[__NEW_UTS_LEN];
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -1044,9 +1118,12 @@ asmlinkage long sys_sethostname(char *na
 		return -EINVAL;
 	down_write(&uts_sem);
 	errno = -EFAULT;
+	nodename = system_utsname.nodename;
+	if (current->vx_info)
+		nodename = current->vx_info->virt.utsname.nodename;
 	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.nodename, tmp, len);
-		system_utsname.nodename[len] = 0;
+		memcpy(nodename, tmp, len);
+		nodename[len] = 0;
 		errno = 0;
 	}
 	up_write(&uts_sem);
@@ -1056,15 +1133,19 @@ asmlinkage long sys_sethostname(char *na
 asmlinkage long sys_gethostname(char *name, int len)
 {
 	int i, errno;
+	char *nodename;
 
 	if (len < 0)
 		return -EINVAL;
 	down_read(&uts_sem);
-	i = 1 + strlen(system_utsname.nodename);
+	nodename = system_utsname.nodename;
+	if (current->vx_info)
+		nodename = current->vx_info->virt.utsname.nodename;
+	i = 1 + strlen(nodename);
 	if (i > len)
 		i = len;
 	errno = 0;
-	if (copy_to_user(name, system_utsname.nodename, i))
+	if (copy_to_user(name, nodename, i))
 		errno = -EFAULT;
 	up_read(&uts_sem);
 	return errno;
@@ -1077,6 +1158,7 @@ asmlinkage long sys_gethostname(char *na
 asmlinkage long sys_setdomainname(char *name, int len)
 {
 	int errno;
+	char *domainname;
 	char tmp[__NEW_UTS_LEN];
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -1085,10 +1167,13 @@ asmlinkage long sys_setdomainname(char *
 		return -EINVAL;
 
 	down_write(&uts_sem);
+	domainname = system_utsname.domainname;
+	if (current->vx_info)
+		domainname = current->vx_info->virt.utsname.domainname;
 	errno = -EFAULT;
 	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.domainname, tmp, len);
-		system_utsname.domainname[len] = 0;
+		memcpy(domainname, tmp, len);
+		domainname[len] = 0;
 		errno = 0;
 	}
 	up_write(&uts_sem);
diff -NurpP --minimal linux-2.4.25-rc1/kernel/sysctl.c linux-2.4.25-rc1-vs1.3.6.3/kernel/sysctl.c
--- linux-2.4.25-rc1/kernel/sysctl.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/sysctl.c	2004-02-06 02:52:25.000000000 +0100
@@ -80,6 +80,7 @@ extern int sem_ctls[];
 #endif
 
 extern int exception_trace;
+extern char vshelper_path[];
 
 #ifdef __sparc__
 extern char reboot_command [];
@@ -275,6 +276,8 @@ static ctl_table kern_table[] = {
 	{KERN_EXCEPTION_TRACE,"exception-trace",
 	 &exception_trace,sizeof(int),0644,NULL,&proc_dointvec},
 #endif	
+	{KERN_VSHELPER,"vshelper",
+	 &vshelper_path,256,0644,NULL,&proc_dostring,&sysctl_string},
 	{0}
 };
 
@@ -414,6 +417,8 @@ extern asmlinkage long sys_sysctl(struct
 
 static int test_perm(int mode, int op)
 {
+	if (!capable(CAP_SYS_ADMIN))
+		mode &= ~(0222);
 	if (!current->euid)
 		mode >>= 6;
 	else if (in_egroup_p(0))
@@ -829,7 +834,18 @@ static int proc_doutsstring(ctl_table *t
 		  void *buffer, size_t *lenp)
 {
 	int r;
+	ctl_table tmp;
+
+	/* HACK for per context hostname and domainname */
+	if (current->vx_info) {
+		tmp = *table;
+		table = &tmp;
 
+		if (table->data == (void*)&system_utsname.nodename)
+			tmp.data = &current->vx_info->virt.utsname.nodename;
+		else if (table->data == (void*)&system_utsname.domainname)
+			tmp.data = &current->vx_info->virt.utsname.domainname;
+	}
 	if (!write) {
 		down_read(&uts_sem);
 		r=proc_dostring(table,0,filp,buffer,lenp);
diff -NurpP --minimal linux-2.4.25-rc1/kernel/timer.c linux-2.4.25-rc1-vs1.3.6.3/kernel/timer.c
--- linux-2.4.25-rc1/kernel/timer.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/timer.c	2004-02-06 02:52:25.000000000 +0100
@@ -22,6 +22,7 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
+#include <linux/vserver/legacy.h>
 
 #include <asm/uaccess.h>
 
@@ -599,6 +600,11 @@ void update_process_times(int user_tick)
 
 	update_one_process(p, user_tick, system, cpu);
 	if (p->pid) {
+		struct vx_info *vxi = p->vx_info;
+
+		if (vxi && (vxi->vx_flags & VX_INFO_SCHED))
+			atomic_dec (&vxi->limit.ticks);
+
 		if (--p->counter <= 0) {
 			p->counter = 0;
 			/*
@@ -752,6 +758,10 @@ asmlinkage unsigned long sys_alarm(unsig
  */
 asmlinkage long sys_getpid(void)
 {
+	if (current->vx_info &&
+		current->vx_info->vx_initpid == current->tgid)
+		/* We are faking process 1 for this security context */
+		return 1;
 	return current->tgid;
 }
 
@@ -798,6 +808,10 @@ asmlinkage long sys_getppid(void)
 #endif
 		break;
 	}
+	if (pid && current->vx_info
+		&& current->vx_info->vx_initpid == pid)
+		/* We are faking process 1 for this security context */
+		pid = 1;
 	return pid;
 }
 
diff -NurpP --minimal linux-2.4.25-rc1/kernel/user.c linux-2.4.25-rc1-vs1.3.6.3/kernel/user.c
--- linux-2.4.25-rc1/kernel/user.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/user.c	2004-02-06 02:52:25.000000000 +0100
@@ -6,6 +6,19 @@
  * We have a per-user structure to keep track of how many
  * processes, files etc the user has claimed, in order to be
  * able to have per-user limits for system resources. 
+ *
+ * For the vserver project, the key is extended from UID to (SC,UID),
+ * with SC being the security context ID. Thus, each security context
+ * has independant per-UID resource usage counters.
+ *
+ * As a consequence, even if two UIDs are the same, the 'struct user *'
+ * in their task_struct could be different. I don't think any code cares.
+ *
+ * (vserver modifications done Sun Jan 13 08:48:45 CET 2002 by bof@bof.de)
+ *
+ * NOTE: For now, the hash function is unmodified: the same uid in several
+ * security contexts, will always sit on the same hash chain. This could
+ * be changed easily.
  */
 
 #include <linux/init.h>
@@ -56,7 +69,7 @@ static inline void uid_hash_remove(struc
 	*pprev = next;
 }
 
-static inline struct user_struct *uid_hash_find(uid_t uid, struct user_struct **hashent)
+static inline struct user_struct *uid_hash_find(xid_t xid, uid_t uid, struct user_struct **hashent)
 {
 	struct user_struct *next;
 
@@ -65,7 +78,7 @@ static inline struct user_struct *uid_ha
 		struct user_struct *up = next;
 		if (next) {
 			next = up->next;
-			if (up->uid != uid)
+			if (up->uid != uid || up->xid != xid)
 				continue;
 			atomic_inc(&up->__count);
 		}
@@ -82,13 +95,13 @@ void free_uid(struct user_struct *up)
 	}
 }
 
-struct user_struct * alloc_uid(uid_t uid)
+struct user_struct * alloc_uid(xid_t xid, uid_t uid)
 {
 	struct user_struct **hashent = uidhashentry(uid);
 	struct user_struct *up;
 
 	spin_lock(&uidhash_lock);
-	up = uid_hash_find(uid, hashent);
+	up = uid_hash_find(xid, uid, hashent);
 	spin_unlock(&uidhash_lock);
 
 	if (!up) {
@@ -98,6 +111,7 @@ struct user_struct * alloc_uid(uid_t uid
 		if (!new)
 			return NULL;
 		new->uid = uid;
+		new->xid = xid;
 		atomic_set(&new->__count, 1);
 		atomic_set(&new->processes, 0);
 		atomic_set(&new->files, 0);
@@ -107,7 +121,7 @@ struct user_struct * alloc_uid(uid_t uid
 		 * on adding the same user already..
 		 */
 		spin_lock(&uidhash_lock);
-		up = uid_hash_find(uid, hashent);
+		up = uid_hash_find(xid, uid, hashent);
 		if (up) {
 			kmem_cache_free(uid_cachep, new);
 		} else {
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/Makefile linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/Makefile
--- linux-2.4.25-rc1/kernel/vserver/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/Makefile	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,20 @@
+#
+# Makefile for the Linux vserver routines.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile.
+
+O_TARGET := vserver.o
+
+export-objs := switch.o context.o network.o
+
+obj-y    := switch.o context.o network.o inode.o limit.o signal.o
+
+# ifeq ($(CONFIG_PROC_DEVICETREE),y)
+obj-y += legacy.o
+# endif
+
+include $(TOPDIR)/Rules.make
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/context.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/context.c
--- linux-2.4.25-rc1/kernel/vserver/context.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/context.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,297 @@
+/*
+ *  linux/kernel/vserver/context.c
+ *
+ *  Virtual Server: Context Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Pötzl
+ *
+ *  V0.01  context helper
+ *  V0.02  vx_ctx_kill syscall command
+ *  V0.03  replaced context_info calls
+ *  V0.04  redesign of struct (de)alloc
+ *  V0.05  rlimit basic implementation
+ *  V0.06  task_xid and info commands
+ *
+ */
+
+#include <linux/config.h>
+//#include <linux/linkage.h>
+#include <linux/utsname.h>
+#include <linux/slab.h>
+#include <linux/vserver/context.h>
+//#include <linux/vswitch.h>
+#include <linux/vinline.h>
+//#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/errno.h>
+//#include <asm/uaccess.h>
+
+
+
+/*  system functions */
+
+
+LIST_HEAD(vx_infos);
+
+spinlock_t vxlist_lock
+	__cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ *	struct vx_info allocation and deallocation
+ */
+
+static struct vx_info *alloc_vx_info(int id)
+{
+	struct vx_info *new = NULL;
+	int lim;
+	
+	vxdprintk("alloc_vx_info(%d)\n", id);
+	/* would this benefit from a slab cache? */
+	new = kmalloc(sizeof(struct vx_info), GFP_KERNEL);
+	if (!new)
+		return 0;
+
+	memset (new, 0, sizeof(struct vx_info));
+	new->vx_id = id;
+	INIT_LIST_HEAD(&new->vx_list);
+	/* rest of init goes here */
+	
+	for (lim=0; lim<RLIM_NLIMITS; lim++)
+		new->limit.rlim[lim] = RLIM_INFINITY;
+	
+	atomic_set(&new->limit.ticks, current->counter);
+	new->virt.nr_threads = 1;
+	new->virt.bias_cswtch = kstat.context_swtch;
+	new->virt.bias_jiffies = jiffies;
+	new->virt.bias_idle = init_tasks[0]->times.tms_utime +
+		init_tasks[0]->times.tms_stime;
+	down_read(&uts_sem);
+	new->virt.utsname = system_utsname;
+	up_read(&uts_sem);
+	
+	vxdprintk("alloc_vx_info(%d) = %p\n", id, new);
+	return new;
+}
+
+void free_vx_info(struct vx_info *vxi)
+{
+	vxdprintk("free_vx_info(%p)\n", vxi);
+	kfree(vxi);
+}
+
+
+/*
+ *	struct vx_info search by id
+ *	assumes vxlist_lock is held
+ */
+
+static __inline__ struct vx_info *__find_vx_info(int id)
+{
+	struct vx_info *vxi;
+
+	list_for_each_entry(vxi, &vx_infos, vx_list)
+		if (vxi->vx_id == id)
+			return vxi;
+	return 0;
+}
+
+
+/*
+ *	struct vx_info ref stuff
+ */
+
+struct vx_info *find_vx_info(int id)
+{
+	struct vx_info *vxi;
+	
+	spin_lock(&vxlist_lock);
+	if ((vxi = __find_vx_info(id)))
+		get_vx_info(vxi);
+	spin_unlock(&vxlist_lock);
+	return vxi;
+}
+
+
+/*
+ *	struct vx_info search by id
+ *	assumes vxlist_lock is held
+ */
+
+static __inline__ xid_t __vx_dynamic_id(void)
+{
+	static xid_t seq = MAX_S_CONTEXT;
+	xid_t barrier = seq;
+	
+	do {
+		if (++seq > MAX_S_CONTEXT)
+			seq = MIN_D_CONTEXT;
+		if (!__find_vx_info(seq))
+			return seq;
+	} while (barrier != seq);
+	return 0;
+}
+
+
+struct vx_info *find_or_create_vx_info(int id)
+{
+	struct vx_info *new, *vxi = NULL;
+	
+	vxdprintk("find_or_create_vx_info(%d)\n", id);
+	if (!(new = alloc_vx_info(id)))
+		return 0;
+
+	spin_lock(&vxlist_lock);
+
+	/* dynamic context requested */
+	if (id == VX_DYNAMIC_ID) {
+		id = __vx_dynamic_id();
+		if (!id) {
+			printk(KERN_ERR "no dynamic context available.\n");
+			goto out_unlock;
+		}
+		new->vx_id = id;
+	}
+	/* existing context requested */
+	else if ((vxi = __find_vx_info(id))) {
+		vxdprintk("find_or_create_vx_info(%d) = %p (found)\n", id, vxi);
+		get_vx_info(vxi);
+		goto out_unlock;
+	}
+
+	/* new context requested */
+	vxdprintk("find_or_create_vx_info(%d) = %p (new)\n", id, vxi);
+	atomic_set(&new->vx_refcount, 1);
+	list_add(&new->vx_list, &vx_infos);
+	vxi = new, new = NULL;
+
+out_unlock:
+	spin_unlock(&vxlist_lock);
+	if (new)
+		free_vx_info(new);
+	return vxi;
+}
+
+
+#include <asm/uaccess.h>
+
+
+int vc_task_xid(uint32_t id, void *data)
+{
+        xid_t xid;
+
+        if (id) {
+                struct task_struct *tsk;
+
+                if (!vx_check(0, VX_ADMIN|VX_WATCH))
+                        return -EPERM;
+
+                read_lock(&tasklist_lock);
+                tsk = find_task_by_pid(id);
+                xid = (tsk) ? tsk->xid : -ESRCH;
+                read_unlock(&tasklist_lock);
+        }
+        else
+                xid = current->xid;
+        return xid;
+}
+
+
+int vc_vx_info(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_vx_info_v0 vc_data;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+	return 0;
+}
+
+
+/* virtual host info names */
+
+static char * vx_vhi_name(struct vx_info *vxi, int id)
+{
+	switch (id) {
+		case VHIN_CONTEXT:
+			return vxi->vx_name;
+		case VHIN_SYSNAME:
+			return vxi->virt.utsname.sysname;
+		case VHIN_NODENAME:
+			return vxi->virt.utsname.nodename;
+		case VHIN_RELEASE:
+			return vxi->virt.utsname.release;
+		case VHIN_VERSION:
+			return vxi->virt.utsname.version;
+		case VHIN_MACHINE:
+			return vxi->virt.utsname.machine;
+		case VHIN_DOMAINNAME:
+			return vxi->virt.utsname.domainname;
+		default:
+	}
+	return NULL;
+}
+
+int vc_set_vhi_name(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_vx_vhi_name_v0 vc_data;
+	char *name;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+	
+	name = vx_vhi_name(vxi, vc_data.field);
+	if (name)
+		memcpy(name, vc_data.name, 65);
+	put_vx_info(vxi);
+	return (name ? 0 : -EFAULT);
+}
+
+int vc_get_vhi_name(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_vx_vhi_name_v0 vc_data;
+	char *name;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	name = vx_vhi_name(vxi, vc_data.field);
+	if (!name)
+		goto out_put;
+			
+	memcpy(vc_data.name, name, 65);
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+out_put:
+	put_vx_info(vxi);
+	return (name ? 0 : -EFAULT);
+}
+
+
+
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/inode.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/inode.c
--- linux-2.4.25-rc1/kernel/vserver/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/inode.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,171 @@
+/*
+ *  linux/kernel/vserver/inode.c
+ *
+ *  Virtual Server: File System Support
+ *
+ *  Copyright (C) 2004  Herbert Pötzl
+ *
+ *  V0.01  separated from vcontext V0.05
+ *
+ */
+
+#include <linux/config.h>
+//#include <linux/linkage.h>
+//#include <linux/utsname.h>
+//#include <linux/slab.h>
+//#include <linux/vcontext.h>
+//#include <linux/vswitch.h>
+#include <linux/vinline.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+//#include <linux/kernel_stat.h>
+#include <linux/vserver/inode.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+#include <asm/smplock.h>
+
+
+int vc_get_iattr(uint32_t id, void *data)
+{
+	struct super_block *sb;
+	struct inode *in;
+	struct vcmd_ctx_iattr_v0 vc_data;
+	int ret;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	ret = -ESRCH;
+	sb = get_super(to_kdev_t(id));
+	if (!sb)
+		goto out;
+	in = iget(sb, vc_data.ino);
+	if (!in)
+		goto out_drop_sb;
+	
+	vc_data.xid = in->i_xid;
+	vc_data.flags = IATTR_XID
+		| (IS_BARRIER(in) ? IATTR_BARRIER : 0)
+		| (IS_IUNLINK(in) ? IATTR_IUNLINK : 0);	
+	vc_data.mask = IATTR_XID | IATTR_BARRIER | IATTR_IUNLINK;
+
+	if (sb->s_magic == PROC_SUPER_MAGIC) {
+		vc_data.flags |= (in->u.proc_i.vx_flags & IATTR_FLAGS);	
+		vc_data.mask |= IATTR_FLAGS;
+	}
+
+	ret = 0;
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		ret = -EFAULT;
+	iput(in);
+out_drop_sb:
+        drop_super(sb);
+out:
+	return ret;
+}
+
+int vc_set_iattr(uint32_t id, void *data)
+{
+	struct super_block *sb;
+	struct inode *in;
+	struct vcmd_ctx_iattr_v0 vc_data;
+	int ret;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_LINUX_IMMUTABLE))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	ret = -ESRCH;
+	sb = get_super(to_kdev_t(id));
+	if (!sb)
+		goto out;
+
+	ret = -ENOTSUP;
+	if ((vc_data.mask & IATTR_FLAGS) && (sb->s_magic != PROC_SUPER_MAGIC))
+		goto out_drop_sb;
+
+	ret = -ESRCH;
+	in = iget(sb, vc_data.ino);
+	if (!in)
+		goto out_drop_sb;
+
+	lock_kernel();
+	if (vc_data.mask & IATTR_XID)
+		in->i_xid = vc_data.xid;
+
+	if (vc_data.mask & IATTR_FLAGS) {
+		unsigned int flags = in->u.proc_i.vx_flags;
+		unsigned int mask = vc_data.mask;
+
+		in->u.proc_i.vx_flags = (flags & ~(mask & IATTR_FLAGS))
+			| (vc_data.flags & IATTR_FLAGS);
+	}
+	
+	if (vc_data.mask & IATTR_BARRIER)
+		in->i_flags = (in->i_flags & ~S_BARRIER)
+			| ((vc_data.flags & IATTR_BARRIER) ? S_BARRIER : 0);
+	if (vc_data.mask & IATTR_IUNLINK)
+		in->i_flags = (in->i_flags & ~S_IUNLINK)
+			| ((vc_data.flags & IATTR_IUNLINK) ? S_IUNLINK : 0);
+	mark_inode_dirty(in);
+	unlock_kernel();
+	iput(in);
+out_drop_sb:
+        drop_super(sb);
+out:
+	return ret;
+}
+
+
+
+#include <linux/proc_fs.h>
+
+int vx_proc_ioctl(struct inode * inode, struct file * filp,
+	unsigned int cmd, unsigned long arg)
+{
+	struct proc_dir_entry *entry;
+	int error = 0;
+	int flags;
+
+	if (inode->i_ino < PROC_DYNAMIC_FIRST ||
+		inode->i_ino >= PROC_DYNAMIC_FIRST+PROC_NDYNAMIC)
+		return -ENOTTY;
+
+	entry = (struct proc_dir_entry *) inode->u.generic_ip;
+
+	switch(cmd) {
+	case FIOC_GETXFLG: {
+		/* fixme: if stealth, return -ENOTTY */
+		error = -EPERM;
+		flags = entry->vx_flags;
+		if (capable(CAP_CONTEXT))
+			error = put_user(flags, (int *) arg);
+		break;
+	}
+	case FIOC_SETXFLG: {
+		/* fixme: if stealth, return -ENOTTY */
+		error = -EPERM;
+		if (!capable(CAP_CONTEXT))
+			break;
+		error = -EROFS;
+		if (IS_RDONLY(inode))
+			break;
+		error = -EFAULT;
+		if (get_user(flags, (int *) arg))
+			break;
+		error = 0;
+		entry->vx_flags = flags;
+		break;
+	}
+	default:
+		return -ENOTTY;
+	}
+	return error;
+}
+
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/legacy.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/legacy.c
--- linux-2.4.25-rc1/kernel/vserver/legacy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/legacy.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,211 @@
+/*
+ *  linux/kernel/vserver/legacy.c
+ *
+ *  Virtual Server: Legacy Funtions
+ *
+ *  Copyright (C) 2001-2003  Jacques Gelinas
+ *  Copyright (C) 2003-2004  Herbert Pötzl
+ *
+ *  V0.01  broken out from vcontext.c V0.05
+ *
+ */
+
+#include <linux/config.h>
+//#include <linux/linkage.h>
+//#include <linux/utsname.h>
+//#include <linux/slab.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/legacy.h>
+//#include <linux/vswitch.h>
+#include <linux/vinline.h>
+#include <linux/sched.h>
+//#include <linux/kernel_stat.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+static int vx_migrate_user(struct task_struct *p, struct vx_info *vxi)
+{
+	struct user_struct *new_user, *old_user;
+	
+	if (!p || !vxi)
+		BUG();
+	new_user = alloc_uid(vxi->vx_id, p->uid);
+	if (!new_user)
+		return -ENOMEM;
+
+	old_user = p->user;
+	if (new_user != old_user) {
+		atomic_inc(&new_user->processes);
+		atomic_dec(&old_user->processes);
+		p->user = new_user;
+	}
+	free_uid(old_user);
+	return 0;
+}
+
+/*
+ *	migrate task to new context
+ *	gets vxi, puts old_vxi on change
+ */
+
+static int vx_migrate_task(struct task_struct *p, struct vx_info *vxi)
+{
+	struct vx_info *old_vxi = task_get_vx_info(p);
+	int ret = 0;
+	
+	if (!p || !vxi)
+		BUG();
+
+	vxdprintk("vx_migrate_task(%p,%p[#%d.%d)\n", p, vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount));
+	spin_lock(&p->alloc_lock);
+	if (old_vxi == vxi)
+		goto out;
+
+	if (!(ret = vx_migrate_user(p, vxi))) {
+		if (old_vxi) {
+			old_vxi->virt.nr_threads--;
+			atomic_dec(&old_vxi->limit.res[RLIMIT_NPROC]);
+		}		
+		vxi->virt.nr_threads++;
+		atomic_inc(&vxi->limit.res[RLIMIT_NPROC]);
+		p->vx_info = get_vx_info(vxi);
+		p->xid = vxi->vx_id;
+		if (old_vxi)
+			put_vx_info(old_vxi);
+	}
+out:
+	spin_unlock(&p->alloc_lock);
+	put_vx_info(old_vxi);
+	return ret;
+}
+
+
+static int vx_set_initpid(struct vx_info *vxi, int pid)
+{
+	int ret = 0;
+	if (vxi->vx_initpid)
+		ret = -EPERM;
+	else
+		vxi->vx_initpid = pid;
+	return ret;
+}
+
+int vc_new_s_context(uint32_t ctx, void *data)
+{
+	int ret = -ENOMEM;
+	struct vcmd_new_s_context_v1 vc_data;
+	struct vx_info *new_vxi;
+
+	if (copy_from_user(&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	/* legacy hack, will be removed soon */
+	if (ctx == -2) {
+		/* assign flags and initpid */
+		if (!current->vx_info)
+			return -EINVAL;
+		ret = 0;
+		if (vc_data.flags & VX_INFO_INIT)
+			ret = vx_set_initpid(current->vx_info, current->tgid);
+		if (ret == 0) {
+			/* We keep the same vx_id, but lower the capabilities */
+			current->cap_bset &= (~vc_data.remove_cap);
+			ret = vx_current_xid();
+			current->vx_info->vx_flags |= vc_data.flags;
+		}
+		return ret;
+	}
+	
+	if (!vx_check(0, VX_ADMIN) ||
+		!capable(CAP_SYS_ADMIN) ||
+		(current->vx_info &&
+		(current->vx_info->vx_flags & VX_INFO_LOCK)))
+		return -EPERM;
+
+	if (((ctx > MAX_S_CONTEXT) && (ctx != VX_DYNAMIC_ID)) ||
+		(ctx == 0))
+		return -EINVAL;
+		
+	if ((ctx == VX_DYNAMIC_ID) || (ctx < MIN_D_CONTEXT))
+		new_vxi = find_or_create_vx_info(ctx);
+	else
+		new_vxi = find_vx_info(ctx);
+		
+	if (!new_vxi)
+		return -EINVAL;
+
+	ret = vx_migrate_task(current, new_vxi);
+	if (ret == 0) {
+		current->cap_bset &= (~vc_data.remove_cap);
+		new_vxi->vx_flags |= vc_data.flags;
+		if (vc_data.flags & VX_INFO_INIT)
+			vx_set_initpid(new_vxi, current->tgid);
+		if (vc_data.flags & VX_INFO_NPROC)
+			new_vxi->limit.rlim[RLIMIT_NPROC] =
+				current->rlim[RLIMIT_NPROC].rlim_max;
+		ret = new_vxi->vx_id;
+	}
+	put_vx_info(new_vxi);
+	return ret;
+}
+
+
+
+/*  set ipv4 root (syscall) */
+
+int vc_set_ipv4root(uint32_t nbip, void *data)
+{
+	int i, err = -EPERM;
+	struct vcmd_set_ipv4root_v3 vc_data;
+	struct ip_info *new_ipi, *ipi = current->ip_info;
+
+	if (nbip < 0 || nbip > NB_IPV4ROOT)
+		return -EINVAL;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	if (!ipi || ipi->ipv4[0] == 0 || capable(CAP_NET_ADMIN))
+		// We are allowed to change everything
+		err = 0;
+	else if (ipi) {
+		int found = 0;
+		
+		// We are allowed to select a subset of the currently
+		// installed IP numbers. No new one allowed
+		// We can't change the broadcast address though
+		for (i=0; i<nbip; i++) {
+			int j;
+			__u32 ipip = vc_data.ip_mask_pair[i].ip;
+			for (j=0; j<ipi->nbipv4; j++) {
+				if (ipip == ipi->ipv4[j]) {
+					found++;
+					break;
+				}
+			}
+		}
+		if ((found == nbip) &&
+			(vc_data.broadcast == ipi->v4_bcast))
+			err = 0;
+	}
+	if (err)
+		return err;
+
+	new_ipi = create_ip_info();
+	if (!new_ipi)
+		return -EINVAL;
+
+	new_ipi->nbipv4 = nbip;
+	for (i=0; i<nbip; i++) {
+		new_ipi->ipv4[i] = vc_data.ip_mask_pair[i].ip;
+		new_ipi->mask[i] = vc_data.ip_mask_pair[i].mask;
+	}
+	new_ipi->v4_bcast = vc_data.broadcast;
+	current->ip_info = new_ipi;
+	put_ip_info(ipi);
+	return 0;
+}
+
+
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/limit.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/limit.c
--- linux-2.4.25-rc1/kernel/vserver/limit.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/limit.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,116 @@
+/*
+ *  linux/kernel/vserver/limit.c
+ *
+ *  Virtual Server: Context Limits
+ *
+ *  Copyright (C) 2004  Herbert Pötzl
+ *
+ *  V0.01  broken out from vcontext V0.05
+ *
+ */
+
+#include <linux/config.h>
+//#include <linux/linkage.h>
+//#include <linux/utsname.h>
+//#include <linux/slab.h>
+#include <linux/vserver/limit.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/switch.h>
+#include <linux/vinline.h>
+//#include <linux/sched.h>
+//#include <linux/kernel_stat.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+static int is_valid_rlimit(int id)
+{
+	int valid = 0;
+
+	switch (id) {
+		case RLIMIT_NPROC:
+		case RLIMIT_AS:
+		case RLIMIT_RSS:
+			valid = 1;
+			break;
+	}
+	return valid;
+}
+
+int vc_get_rlimit(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_rlimit_v0 vc_data;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	if (!is_valid_rlimit(vc_data.id))
+		return -ENOTSUPP;
+		
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	if (vc_data.maximum != CRLIM_KEEP)
+		vc_data.maximum = vxi->limit.rlim[vc_data.id];
+	vc_data.minimum = CRLIM_UNSET;
+	vc_data.softlimit = CRLIM_UNSET;
+	put_vx_info(vxi);
+
+	if (copy_to_user (data, &vc_data, sizeof(vc_data)))
+		return -EFAULT;
+	return 0;
+}
+
+int vc_set_rlimit(uint32_t id, void *data)
+{
+	struct vx_info *vxi;
+	struct vcmd_ctx_rlimit_v0 vc_data;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	if (!is_valid_rlimit(vc_data.id))
+		return -ENOTSUPP;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	if (vc_data.maximum != CRLIM_KEEP)
+		vxi->limit.rlim[vc_data.id] = vc_data.maximum;
+	printk("setting [%d] = %d\n", vc_data.id, (int)vc_data.maximum);
+	put_vx_info(vxi);
+
+	return 0;
+}
+
+int vc_get_rlimit_mask(uint32_t id, void *data)
+{
+	static struct vcmd_ctx_rlimit_mask_v0 mask = {
+			/* minimum */
+		0
+		,	/* softlimit */
+		0
+		,	/* maximum */
+		(1 << RLIMIT_NPROC) |
+		(1 << RLIMIT_AS) |
+		(1 << RLIMIT_RSS)
+		};
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+	if (copy_to_user(data, &mask, sizeof(mask)))
+                return -EFAULT;
+	return 0;
+}
+
+
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/network.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/network.c
--- linux-2.4.25-rc1/kernel/vserver/network.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/network.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,83 @@
+/*
+ *  linux/kernel/vserver/network.c
+ *
+ *  Virtual Server: Network Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Pötzl
+ *
+ *  V0.01  broken out from vcontext V0.05
+ *  V0.05  rlimit basic implementation
+ *
+ */
+
+#include <linux/config.h>
+//#include <linux/linkage.h>
+//#include <linux/utsname.h>
+#include <linux/slab.h>
+#include <linux/vserver/network.h>
+//#include <linux/vswitch.h>
+#include <linux/vinline.h>
+//#include <linux/sched.h>
+//#include <linux/kernel_stat.h>
+
+#include <asm/errno.h>
+//#include <asm/uaccess.h>
+
+
+
+LIST_HEAD(ip_infos);
+
+spinlock_t iplist_lock
+	__cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ *	struct ip_info allocation and deallocation
+ */
+
+static struct ip_info *alloc_ip_info(void)
+{
+	struct ip_info *new = NULL;
+	
+	vxdprintk("alloc_ip_info()\n");
+	/* would this benefit from a slab cache? */
+	new = kmalloc(sizeof(struct ip_info), GFP_KERNEL);
+	if (!new)
+		return 0;
+	
+	memset (new, 0, sizeof(struct ip_info));
+	/* rest of init goes here */
+	
+	
+	vxdprintk("alloc_ip_info() = %p\n", new);
+	return new;
+}
+
+// extern int ip_proc_destroy(struct ip_info *);
+
+void free_ip_info(struct ip_info *ipi)
+{
+	vxdprintk("free_ip_info(%p)\n", ipi);
+//	ip_proc_destroy(ipi);
+	kfree(ipi);
+}
+
+struct ip_info *create_ip_info(void)
+{
+	struct ip_info *new;
+	
+	vxdprintk("create_ip_info()\n");
+	if (!(new = alloc_ip_info()))
+		return 0;
+
+	spin_lock(&iplist_lock);
+
+	/* new ip info */
+	atomic_set(&new->ip_refcount, 1);
+	list_add(&new->ip_list, &ip_infos);
+//	ip_proc_create(new);
+
+	spin_unlock(&iplist_lock);
+	return new;
+}
+
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/signal.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/signal.c
--- linux-2.4.25-rc1/kernel/vserver/signal.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/signal.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,85 @@
+/*
+ *  linux/kernel/vserver/signal.c
+ *
+ *  Virtual Server: Signal Support
+ *
+ *  Copyright (C) 2003-2004  Herbert Pötzl
+ *
+ *  V0.01  broken out from vcontext V0.05
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/sched.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+#include <linux/vinline.h>
+#include <linux/vserver/signal.h>
+
+
+int vc_ctx_kill(uint32_t id, void *data)
+{
+	int retval, count=0;
+	struct vcmd_ctx_kill_v0 vc_data;
+	struct siginfo info;
+	struct task_struct *p;
+	struct vx_info *vxi;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	info.si_signo = vc_data.sig;
+	info.si_errno = 0;
+	info.si_code = SI_USER;
+	info.si_pid = current->pid;
+	info.si_uid = current->uid;
+
+	vxi = find_vx_info(id);
+	if (!vxi)
+		return -ESRCH;
+
+	retval = -ESRCH;
+	read_lock(&tasklist_lock);
+	switch (vc_data.pid) {
+	case -1:
+	case  0:
+		for_each_task(p) {
+			int err = 0;
+
+			if (vx_task_xid(p) != id || p->pid <= 1 ||
+				(vc_data.pid && vxi->vx_initpid == p->pid) ||
+				!thread_group_leader(p))
+				continue;
+
+			err = send_sig_info(vc_data.sig, &info, p);
+			++count;
+			if (err != -EPERM)
+				retval = err;
+		}
+		break;
+		
+	default:
+	p = find_task_by_pid(vc_data.pid);
+		if (p) {
+			if (!thread_group_leader(p)) {
+				struct task_struct *tg;
+			
+				tg = find_task_by_pid(p->tgid);
+				if (tg)
+					p = tg;
+			}
+			if ((id == -1) || (vx_task_xid(p) == id))
+				retval = send_sig_info(vc_data.sig, &info, p);
+		}
+		break;
+	}
+	read_unlock(&tasklist_lock);
+	put_vx_info(vxi);
+	return retval;
+}
+
+
diff -NurpP --minimal linux-2.4.25-rc1/kernel/vserver/switch.c linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/switch.c
--- linux-2.4.25-rc1/kernel/vserver/switch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/kernel/vserver/switch.c	2004-02-06 02:52:25.000000000 +0100
@@ -0,0 +1,84 @@
+/*
+ *  linux/kernel/vserver/switch.c
+ *
+ *  Virtual Server: Syscall Switch
+ *
+ *  Copyright (C) 2003-2004  Herbert Pötzl
+ *
+ *  V0.01  syscall switch
+ *  V0.02  added signal to context
+ *  V0.03  added rlimit functions
+ *  V0.04  added iattr, task/xid functions
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/errno.h>
+
+#include <linux/vserver/switch.h>
+
+
+static inline int
+vc_get_version(uint32_t id)
+{
+	return VCI_VERSION;
+}
+
+
+#include <linux/vserver/legacy.h>
+#include <linux/vserver/context.h>
+#include <linux/vserver/network.h>
+#include <linux/vserver/limit.h>
+#include <linux/vserver/inode.h>
+#include <linux/vserver/signal.h>
+
+extern asmlinkage int
+sys_vserver(uint32_t cmd, uint32_t id, void *data)
+{
+	int ret = -ENOTSUP;
+
+	switch (cmd) {
+	case VCMD_get_version:
+		ret = vc_get_version(id);
+		break;
+		
+	case VCMD_new_s_context:
+		ret = vc_new_s_context(id, data);
+		break;
+	case VCMD_set_ipv4root:
+		ret = vc_set_ipv4root(id, data);
+		break;
+
+	case VCMD_get_rlimit:
+		ret = vc_get_rlimit(id, data);
+		break;
+	case VCMD_set_rlimit:
+		ret = vc_set_rlimit(id, data);
+		break;
+	case VCMD_get_rlimit_mask:
+		ret = vc_get_rlimit_mask(id, data);
+		break;
+		
+	case VCMD_ctx_kill:
+		ret = vc_ctx_kill(id, data);
+		break;
+
+	case VCMD_get_iattr:
+		ret = vc_get_iattr(id, data);
+		break;
+	case VCMD_set_iattr:
+		ret = vc_set_iattr(id, data);
+		break;
+
+	case VCMD_task_xid:
+		ret = vc_task_xid(id, data);
+		break;
+	case VCMD_vx_info:
+		ret = vc_vx_info(id, data);
+		break;
+	}
+	return ret;
+}
+
+
diff -NurpP --minimal linux-2.4.25-rc1/mm/filemap.c linux-2.4.25-rc1-vs1.3.6.3/mm/filemap.c
--- linux-2.4.25-rc1/mm/filemap.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/filemap.c	2004-02-06 02:52:25.000000000 +0100
@@ -2610,6 +2610,8 @@ static long madvise_willneed(struct vm_a
 				LONG_MAX; /* default: see resource.h */
 	if ((vma->vm_mm->rss + (end - start)) > rlim_rss)
 		return error;
+	if (!vx_rsspages_avail(vma->vm_mm, end - start))
+		return error;
 
 	/* round to cluster boundaries if this isn't a "random" area. */
 	if (!VM_RandomReadHint(vma)) {
diff -NurpP --minimal linux-2.4.25-rc1/mm/memory.c linux-2.4.25-rc1-vs1.3.6.3/mm/memory.c
--- linux-2.4.25-rc1/mm/memory.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/memory.c	2004-02-06 02:52:25.000000000 +0100
@@ -257,7 +257,7 @@ skip_copy_pte_range:		address = (address
 					pte = pte_mkclean(pte);
 				pte = pte_mkold(pte);
 				get_page(ptepage);
-				dst->rss++;
+				vx_rsspages_inc(dst);
 
 cont_copy_pte_range:		set_pte(dst_pte, pte);
 cont_copy_pte_range_noset:	address += PAGE_SIZE;
@@ -393,9 +393,9 @@ void zap_page_range(struct mm_struct *mm
 	 * Notice that rss is an unsigned long.
 	 */
 	if (mm->rss > freed)
-		mm->rss -= freed;
+		vx_rsspages_sub(mm, freed);
 	else
-		mm->rss = 0;
+		vx_rsspages_sub(mm, mm->rss);
 	spin_unlock(&mm->page_table_lock);
 }
 
@@ -982,7 +982,7 @@ static int do_wp_page(struct mm_struct *
 	spin_lock(&mm->page_table_lock);
 	if (pte_same(*page_table, pte)) {
 		if (PageReserved(old_page))
-			++mm->rss;
+			vx_rsspages_inc(mm);
 		break_cow(vma, new_page, address, page_table);
 		lru_cache_add(new_page);
 
@@ -1166,7 +1166,7 @@ static int do_swap_page(struct mm_struct
 	if (vm_swap_full())
 		remove_exclusive_swap_page(page);
 
-	mm->rss++;
+	vx_rsspages_inc(mm);
 	pte = mk_pte(page, vma->vm_page_prot);
 	if (write_access && can_share_swap_page(page))
 		pte = pte_mkdirty(pte_mkwrite(pte));
@@ -1212,7 +1212,7 @@ static int do_anonymous_page(struct mm_s
 			spin_unlock(&mm->page_table_lock);
 			return 1;
 		}
-		mm->rss++;
+		vx_rsspages_inc(mm);
 		flush_page_to_ram(page);
 		entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
 		lru_cache_add(page);
@@ -1288,7 +1288,7 @@ static int do_no_page(struct mm_struct *
 	/* Only go through if we didn't race with anybody else... */
 	if (pte_none(*page_table)) {
 		if (!PageReserved(new_page))
-			++mm->rss;
+			vx_rsspages_inc(mm);
 		flush_page_to_ram(new_page);
 		flush_icache_page(vma, new_page);
 		entry = mk_pte(new_page, vma->vm_page_prot);
diff -NurpP --minimal linux-2.4.25-rc1/mm/mlock.c linux-2.4.25-rc1-vs1.3.6.3/mm/mlock.c
--- linux-2.4.25-rc1/mm/mlock.c	2001-09-18 00:30:23.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/mlock.c	2004-02-06 02:52:25.000000000 +0100
@@ -278,6 +278,7 @@ asmlinkage long sys_mlockall(int flags)
 	ret = -ENOMEM;
 	if (current->mm->total_vm > lock_limit)
 		goto out;
+	/* check vserver lock limits */
 
 	/* we may lock at most half of physical memory... */
 	/* (this check is pretty bogus, but doesn't hurt) */
diff -NurpP --minimal linux-2.4.25-rc1/mm/mmap.c linux-2.4.25-rc1-vs1.3.6.3/mm/mmap.c
--- linux-2.4.25-rc1/mm/mmap.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/mmap.c	2004-02-06 02:52:25.000000000 +0100
@@ -506,6 +506,10 @@ munmap_back:
 	    !vm_enough_memory(len >> PAGE_SHIFT))
 		return -ENOMEM;
 
+	/* check context space, maybe only Private writable mapping? */
+	if (!vx_vmpages_avail(mm, len >> PAGE_SHIFT))
+		return -ENOMEM;
+
 	/* Can we just expand an old anonymous mapping? */
 	if (!file && !(vm_flags & VM_SHARED) && rb_parent)
 		if (vma_merge(mm, prev, rb_parent, addr, addr + len, vm_flags))
@@ -586,7 +590,7 @@ munmap_back:
 		atomic_inc(&file->f_dentry->d_inode->i_writecount);
 
 out:	
-	mm->total_vm += len >> PAGE_SHIFT;
+	vx_vmpages_add(mm, len >> PAGE_SHIFT);
 	if (vm_flags & VM_LOCKED) {
 		mm->locked_vm += len >> PAGE_SHIFT;
 		make_pages_present(addr, addr + len);
@@ -797,9 +801,9 @@ static struct vm_area_struct * unmap_fix
 	struct vm_area_struct *mpnt;
 	unsigned long end = addr + len;
 
-	area->vm_mm->total_vm -= len >> PAGE_SHIFT;
+	vx_vmpages_sub(area->vm_mm, len >> PAGE_SHIFT);
 	if (area->vm_flags & VM_LOCKED)
-		area->vm_mm->locked_vm -= len >> PAGE_SHIFT;
+		vx_vmlocked_sub(area->vm_mm, len >> PAGE_SHIFT);
 
 	/* Unmapping the whole area. */
 	if (addr == area->vm_start && end == area->vm_end) {
@@ -1082,6 +1086,9 @@ unsigned long do_brk(unsigned long addr,
 	if (!vm_enough_memory(len >> PAGE_SHIFT))
 		return -ENOMEM;
 
+	if (!vx_vmpages_avail(mm, len >> PAGE_SHIFT))
+		return -ENOMEM;
+
 	flags = VM_DATA_DEFAULT_FLAGS | mm->def_flags;
 
 	/* Can we just expand an old anonymous mapping? */
@@ -1108,9 +1115,9 @@ unsigned long do_brk(unsigned long addr,
 	vma_link(mm, vma, prev, rb_link, rb_parent);
 
 out:
-	mm->total_vm += len >> PAGE_SHIFT;
+	vx_vmpages_add(mm, len >> PAGE_SHIFT);
 	if (flags & VM_LOCKED) {
-		mm->locked_vm += len >> PAGE_SHIFT;
+		vx_vmlocked_add(mm, len >> PAGE_SHIFT);
 		make_pages_present(addr, addr + len);
 	}
 	return addr;
@@ -1142,10 +1149,10 @@ void exit_mmap(struct mm_struct * mm)
 	mpnt = mm->mmap;
 	mm->mmap = mm->mmap_cache = NULL;
 	mm->mm_rb = RB_ROOT;
-	mm->rss = 0;
+	vx_rsspages_sub(mm, mm->rss);
+	vx_vmpages_sub(mm, mm->total_vm);
+	vx_vmlocked_sub(mm, mm->locked_vm);
 	spin_unlock(&mm->page_table_lock);
-	mm->total_vm = 0;
-	mm->locked_vm = 0;
 
 	flush_cache_mm(mm);
 	while (mpnt) {
diff -NurpP --minimal linux-2.4.25-rc1/mm/mremap.c linux-2.4.25-rc1-vs1.3.6.3/mm/mremap.c
--- linux-2.4.25-rc1/mm/mremap.c	2004-01-05 14:53:56.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/mremap.c	2004-02-06 02:52:25.000000000 +0100
@@ -194,9 +194,9 @@ static inline unsigned long move_vma(str
 
 		do_munmap(current->mm, addr, old_len);
 
-		current->mm->total_vm += new_len >> PAGE_SHIFT;
+		vx_vmpages_add(current->mm, new_len >> PAGE_SHIFT);
 		if (vm_locked) {
-			current->mm->locked_vm += new_len >> PAGE_SHIFT;
+			vx_vmlocked_add(current->mm, new_len >> PAGE_SHIFT);
 			if (new_len > old_len)
 				make_pages_present(new_addr + old_len,
 						   new_addr + new_len);
@@ -302,6 +302,9 @@ unsigned long do_mremap(unsigned long ad
 	    !(flags & MAP_NORESERVE)				 &&
 	    !vm_enough_memory((new_len - old_len) >> PAGE_SHIFT))
 		goto out;
+	/* check context space, maybe only Private writable mapping? */
+	if (!vx_vmpages_avail(current->mm, (new_len - old_len) >> PAGE_SHIFT))
+		goto out;
 
 	/* old_len exactly to the end of the area..
 	 * And we're not relocating the area.
@@ -318,9 +321,9 @@ unsigned long do_mremap(unsigned long ad
 			spin_lock(&vma->vm_mm->page_table_lock);
 			vma->vm_end = addr + new_len;
 			spin_unlock(&vma->vm_mm->page_table_lock);
-			current->mm->total_vm += pages;
+			vx_vmpages_add(current->mm, pages);
 			if (vma->vm_flags & VM_LOCKED) {
-				current->mm->locked_vm += pages;
+				vx_vmlocked_add(current->mm, pages);
 				make_pages_present(addr + old_len,
 						   addr + new_len);
 			}
diff -NurpP --minimal linux-2.4.25-rc1/mm/swapfile.c linux-2.4.25-rc1-vs1.3.6.3/mm/swapfile.c
--- linux-2.4.25-rc1/mm/swapfile.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/swapfile.c	2004-02-06 02:52:25.000000000 +0100
@@ -374,7 +374,7 @@ static inline void unuse_pte(struct vm_a
 	get_page(page);
 	set_pte(dir, pte_mkold(mk_pte(page, vma->vm_page_prot)));
 	swap_free(entry);
-	++vma->vm_mm->rss;
+	vx_rsspages_inc(vma->vm_mm);
 }
 
 /* mmlist_lock and vma->vm_mm->page_table_lock are held */
diff -NurpP --minimal linux-2.4.25-rc1/mm/vmscan.c linux-2.4.25-rc1-vs1.3.6.3/mm/vmscan.c
--- linux-2.4.25-rc1/mm/vmscan.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/mm/vmscan.c	2004-02-06 02:52:25.000000000 +0100
@@ -119,7 +119,7 @@ static inline int try_to_swap_out(struct
 set_swap_pte:
 		set_pte(page_table, swp_entry_to_pte(entry));
 drop_pte:
-		mm->rss--;
+		vx_rsspages_dec(mm);
 		UnlockPage(page);
 		{
 			int freeable = page_count(page) - !!page->buffers <= 2;
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv4/af_inet.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/af_inet.c
--- linux-2.4.25-rc1/net/ipv4/af_inet.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/af_inet.c	2004-02-06 02:52:25.000000000 +0100
@@ -177,6 +177,10 @@ void inet_sock_destruct(struct sock *sk)
 
 	if (sk->protinfo.af_inet.opt)
 		kfree(sk->protinfo.af_inet.opt);
+
+	/* reordering required? */
+	put_ip_info(sk->ip_info);
+	sk->ip_info = NULL;
 	dst_release(sk->dst_cache);
 #ifdef INET_REFCNT_DEBUG
 	atomic_dec(&inet_sock_nr);
@@ -393,6 +397,9 @@ static int inet_create(struct socket *so
 	sk->protinfo.af_inet.mc_index	= 0;
 	sk->protinfo.af_inet.mc_list	= NULL;
 
+	sk->xid = vx_current_xid();
+	sk->ip_info = NULL;
+
 #ifdef INET_REFCNT_DEBUG
 	atomic_inc(&inet_sock_nr);
 #endif
@@ -477,6 +484,11 @@ int inet_bind(struct socket *sock, struc
 	unsigned short snum;
 	int chk_addr_ret;
 	int err;
+	__u32 s_addr;	/* Address used for validation */
+	__u32 s_addr1;
+	__u32 s_addr2 = 0xffffffffl;	/* Optional address of the socket */
+					/* bcast in ipv4root world */
+	struct ip_info *ip_info;
 
 	/* If the socket has its own bind function then use it. (RAW) */
 	if(sk->prot->bind)
@@ -485,7 +497,37 @@ int inet_bind(struct socket *sock, struc
 	if (addr_len < sizeof(struct sockaddr_in))
 		return -EINVAL;
 
-	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	s_addr = s_addr1 = addr->sin_addr.s_addr;
+	ip_info = current->ip_info;
+	if (ip_info) {
+		__u32 v4_bcast = ip_info->v4_bcast;
+		__u32 ipv4root = ip_info->ipv4[0];
+		int nbipv4 = ip_info->nbipv4;
+		if (s_addr == 0) {
+			s_addr = ipv4root;
+			if (nbipv4 > 1)
+				s_addr1 = 0;
+			else {
+				s_addr1 = ipv4root;
+				ip_info = NULL;
+			}
+			s_addr2 = v4_bcast;
+		} else if (s_addr == 0x0100007f) {
+			s_addr = s_addr1 = ipv4root;
+			ip_info = NULL;
+		} else if (s_addr != v4_bcast
+			&& s_addr != ipv4root) {
+			int i;
+			for (i=0; i<nbipv4; i++) {
+				if (s_addr == ip_info->ipv4[i])
+					break;
+			}
+			if (i == nbipv4)
+				return -EADDRNOTAVAIL;
+			ip_info = NULL;
+		}
+	}
+	chk_addr_ret = inet_addr_type(s_addr);
 
 	/* Not specified by any standard per-se, however it breaks too
 	 * many applications when removed.  It is unfortunate since
@@ -496,7 +538,7 @@ int inet_bind(struct socket *sock, struc
 	 */
 	if (sysctl_ip_nonlocal_bind == 0 && 
 	    sk->protinfo.af_inet.freebind == 0 &&
-	    addr->sin_addr.s_addr != INADDR_ANY &&
+	    s_addr != INADDR_ANY &&
 	    chk_addr_ret != RTN_LOCAL &&
 	    chk_addr_ret != RTN_MULTICAST &&
 	    chk_addr_ret != RTN_BROADCAST)
@@ -521,13 +563,19 @@ int inet_bind(struct socket *sock, struc
 	    (sk->num != 0))
 		goto out;
 
-	sk->rcv_saddr = sk->saddr = addr->sin_addr.s_addr;
+	sk->rcv_saddr = sk->saddr = s_addr1;
+	sk->rcv_saddr2 = s_addr2;
+	sk->ip_info = get_ip_info(ip_info);
+
 	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
 		sk->saddr = 0;  /* Use device */
 
 	/* Make sure we are allowed to bind here. */
 	if (sk->prot->get_port(sk, snum) != 0) {
 		sk->saddr = sk->rcv_saddr = 0;
+		/* check for locking here */
+		sk->ip_info = NULL;
+		put_ip_info(ip_info);
 		err = -EADDRINUSE;
 		goto out;
 	}
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv4/devinet.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/devinet.c
--- linux-2.4.25-rc1/net/ipv4/devinet.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/devinet.c	2004-02-06 02:52:25.000000000 +0100
@@ -455,6 +455,33 @@ static __inline__ int inet_abc_len(u32 a
   	return -1;
 }
 
+/*
+	Check that a device is not member of the ipv4root assigned to the process
+	Return true if this is the case
+
+	If the process is not bound to specific IP, then it returns 0 (all
+	interface are fine).
+*/
+static int devinet_notiproot (struct in_ifaddr *ifa)
+{
+	int ret = 0;
+	struct ip_info *info = current->ip_info;
+
+	if (info && !vx_check(0, VX_ADMIN)) {
+		int i;
+		int nbip = info->nbipv4;
+		__u32 addr = ifa->ifa_local;
+		ret = 1;
+		for (i=0; i<nbip; i++) {
+			if(info->ipv4[i] == addr) {
+				ret = 0;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
 
 int devinet_ioctl(unsigned int cmd, void *arg)
 {
@@ -558,7 +585,10 @@ int devinet_ioctl(unsigned int cmd, void
 		ret = -EADDRNOTAVAIL;
 		goto done;
 	}
-
+	if (ifa != NULL && devinet_notiproot(ifa)) {
+		ret = -EADDRNOTAVAIL;
+		goto done;
+	}
 	switch(cmd) {
 		case SIOCGIFADDR:	/* Get interface address */
 			sin->sin_addr.s_addr = ifa->ifa_local;
@@ -691,6 +721,9 @@ inet_gifconf(struct net_device *dev, cha
 		return 0;
 
 	for ( ; ifa; ifa = ifa->ifa_next) {
+		// We do not show other IP devices to vservers
+		if (devinet_notiproot(ifa))
+			continue;
 		if (!buf) {
 			done += sizeof(ifr);
 			continue;
@@ -933,6 +966,8 @@ static int inet_dump_ifaddr(struct sk_bu
 		read_lock(&in_dev->lock);
 		for (ifa = in_dev->ifa_list, ip_idx = 0; ifa;
 		     ifa = ifa->ifa_next, ip_idx++) {
+			if (devinet_notiproot(ifa))
+				continue;
 			if (ip_idx < s_ip_idx)
 				continue;
 			if (inet_fill_ifaddr(skb, ifa, NETLINK_CB(cb->skb).pid,
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv4/raw.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/raw.c
--- linux-2.4.25-rc1/net/ipv4/raw.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/raw.c	2004-02-06 02:52:25.000000000 +0100
@@ -96,16 +96,47 @@ static void raw_v4_unhash(struct sock *s
 	write_unlock_bh(&raw_v4_lock);
 }
 
+
+/*
+	Check if an address is in the list
+*/
+static inline int raw_addr_in_list (
+	u32 rcv_saddr1,
+	u32 rcv_saddr2,
+	u32 loc_addr,
+	struct ip_info *ip_info)
+{
+	int ret = 0;
+	if (loc_addr != 0 &&
+		(rcv_saddr1 == loc_addr || rcv_saddr2 == loc_addr))
+		ret = 1;
+	else if (rcv_saddr1 == 0) {
+		/* Accept any address or only the one in the list */
+		if (ip_info == NULL)
+			ret = 1;
+		else {
+			int n = ip_info->nbipv4;
+			int i;
+			for (i=0; i<n; i++) {
+				if (ip_info->ipv4[i] == loc_addr) {
+					ret = 1;
+					break;
+				}
+			}
+		}
+	}
+	return ret;
+}
+
 struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
 			     unsigned long raddr, unsigned long laddr,
 			     int dif)
 {
 	struct sock *s = sk;
-
 	for (s = sk; s; s = s->next) {
 		if (s->num == num 				&&
 		    !(s->daddr && s->daddr != raddr) 		&&
-		    !(s->rcv_saddr && s->rcv_saddr != laddr)	&&
+		    raw_addr_in_list(s->rcv_saddr,s->rcv_saddr2,laddr,s->ip_info) &&
 		    !(s->bound_dev_if && s->bound_dev_if != dif))
 			break; /* gotcha */
 	}
@@ -657,7 +688,8 @@ int raw_get_info(char *buffer, char **st
 		struct sock *sk;
 
 		for (sk = raw_v4_htable[i]; sk; sk = sk->next, num++) {
-			if (sk->family != PF_INET)
+			if (sk->family != PF_INET ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += 128;
 			if (pos <= offset)
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv4/tcp_ipv4.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/tcp_ipv4.c
--- linux-2.4.25-rc1/net/ipv4/tcp_ipv4.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/tcp_ipv4.c	2004-02-06 02:52:25.000000000 +0100
@@ -180,6 +180,49 @@ static inline void tcp_bind_hash(struct 
 	sk->prev = (struct sock *) tb;
 }
 
+/*
+	Return 1 if addr match the socket IP list
+	or the socket is INADDR_ANY
+*/
+static inline int tcp_in_list (struct sock *sk, u32 addr)
+{
+	struct ip_info *ip_info = sk->ip_info;
+
+	if (ip_info) {
+		int n = ip_info->nbipv4;
+		int i;
+
+		for (i=0; i<n; i++)
+			if (ip_info->ipv4[i] == addr)
+				return 1;
+	}
+	else if (!sk->rcv_saddr || sk->rcv_saddr == addr)
+		return 1;
+	return 0;
+}
+	
+/*
+	Check if the addresses in sk1 conflict with those in sk2
+*/
+int tcp_ipv4_addr_conflict (struct sock *sk1, struct sock *sk2)
+{
+	if (sk1->rcv_saddr) {
+		/* Bind to one address only */
+		return tcp_in_list (sk2,sk1->rcv_saddr);
+	} else if (sk1->ip_info) {
+		/* A restricted bind(any) */
+		struct ip_info *ip_info = sk1->ip_info;
+		int n = ip_info->nbipv4;
+		int i;
+
+		for (i=0; i<n; i++)
+			if (tcp_in_list (sk2,ip_info->ipv4[i]))
+				return 1;
+	} else	/* A bind(any) do not allow other bind on the same port */
+		return 1;
+	return 0;
+}
+
 static inline int tcp_bind_conflict(struct sock *sk, struct tcp_bind_bucket *tb)
 {
 	struct sock *sk2 = tb->owners;
@@ -195,9 +238,7 @@ static inline int tcp_bind_conflict(stru
 			if (!sk_reuse	||
 			    !sk2->reuse	||
 			    sk2->state == TCP_LISTEN) {
-				if (!sk2->rcv_saddr	||
-				    !sk->rcv_saddr	||
-				    (sk2->rcv_saddr == sk->rcv_saddr))
+				if (tcp_ipv4_addr_conflict(sk,sk2))
 					break;
 			}
 		}
@@ -416,6 +457,34 @@ void tcp_unhash(struct sock *sk)
 		wake_up(&tcp_lhash_wait);
 }
 
+/*
+	Check if an address is in the list
+*/
+static inline int tcp_addr_in_list (
+	u32 rcv_saddr,
+	u32 daddr,
+	struct ip_info *ip_info)
+{
+	if (rcv_saddr == daddr)
+		return 1;
+	else if (rcv_saddr == 0) {
+		/* Accept any address or check the list */
+		if (!ip_info)
+			return 1;
+		else {
+			int n = ip_info->nbipv4;
+			int i;
+
+			for (i=0; i<n; i++)
+				if (ip_info->ipv4[i] == daddr)
+					return 1;
+		}
+	}
+	return 0;
+}
+
+
+
 /* Don't inline this cruft.  Here are some nice properties to
  * exploit here.  The BSD API does not allow a listening TCP
  * to specify the remote port nor the remote address for the
@@ -437,11 +506,10 @@ static struct sock *__tcp_v4_lookup_list
 #else
 			score = 1;
 #endif
-			if(rcv_saddr) {
-				if (rcv_saddr != daddr)
-					continue;
+			if (tcp_addr_in_list(rcv_saddr,daddr,sk->ip_info))
 				score+=2;
-			}
+			else
+				continue;
 			if (sk->bound_dev_if) {
 				if (sk->bound_dev_if != dif)
 					continue;
@@ -468,8 +536,8 @@ inline struct sock *tcp_v4_lookup_listen
 	if (sk) {
 		if (sk->num == hnum &&
 		    sk->next == NULL &&
-		    (!sk->rcv_saddr || sk->rcv_saddr == daddr) &&
 		    (sk->family == PF_INET || !ipv6_only_sock(sk)) &&
+		    tcp_addr_in_list(sk->rcv_saddr,daddr,sk->ip_info) &&
 		    !sk->bound_dev_if)
 			goto sherry_cache;
 		sk = __tcp_v4_lookup_listener(sk, daddr, hnum, dif);
@@ -2191,6 +2259,9 @@ int tcp_get_info(char *buffer, char **st
 			int uid;
 			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
 
+			if (!vx_check(sk->xid, VX_WATCH|VX_IDENT))
+				continue;
+			
 			if (!TCP_INET_FAMILY(sk->family))
 				goto skip_listen;
 
@@ -2244,7 +2315,8 @@ skip_listen:
 
 		read_lock(&head->lock);
 		for(sk = head->chain; sk; sk = sk->next, num++) {
-			if (!TCP_INET_FAMILY(sk->family))
+			if (!TCP_INET_FAMILY(sk->family) ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += TMPSZ;
 			if (pos <= offset)
@@ -2259,7 +2331,8 @@ skip_listen:
 		for (tw = (struct tcp_tw_bucket *)tcp_ehash[i+tcp_ehash_size].chain;
 		     tw != NULL;
 		     tw = (struct tcp_tw_bucket *)tw->next, num++) {
-			if (!TCP_INET_FAMILY(tw->family))
+			if (!TCP_INET_FAMILY(tw->family) ||
+				!vx_check(tw->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += TMPSZ;
 			if (pos <= offset)
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv4/tcp_minisocks.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/tcp_minisocks.c
--- linux-2.4.25-rc1/net/ipv4/tcp_minisocks.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/tcp_minisocks.c	2004-02-06 02:52:25.000000000 +0100
@@ -380,6 +380,9 @@ void tcp_time_wait(struct sock *sk, int 
 		tw->ts_recent_stamp= tp->ts_recent_stamp;
 		tw->pprev_death = NULL;
 
+		tw->xid		= sk->xid;
+		tw->ip_info	= NULL;
+
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 		if(tw->family == PF_INET6) {
 			memcpy(&tw->v6_daddr,
@@ -651,6 +654,7 @@ struct sock *tcp_create_openreq_child(st
 #endif
 
 		memcpy(newsk, sk, sizeof(*newsk));
+		newsk->ip_info = get_ip_info(sk->ip_info);
 		newsk->state = TCP_SYN_RECV;
 
 		/* SANITY */
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv4/udp.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/udp.c
--- linux-2.4.25-rc1/net/ipv4/udp.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv4/udp.c	2004-02-06 02:52:25.000000000 +0100
@@ -110,6 +110,9 @@ rwlock_t udp_hash_lock = RW_LOCK_UNLOCKE
 /* Shared by v4/v6 udp. */
 int udp_port_rover;
 
+int tcp_ipv4_addr_conflict (struct sock *sk1, struct sock *sk2);
+
+
 static int udp_v4_get_port(struct sock *sk, unsigned short snum)
 {
 	write_lock_bh(&udp_hash_lock);
@@ -167,9 +170,7 @@ gotit:
 			    (!sk2->bound_dev_if ||
 			     !sk->bound_dev_if ||
 			     sk2->bound_dev_if == sk->bound_dev_if) &&
-			    (!sk2->rcv_saddr ||
-			     !sk->rcv_saddr ||
-			     sk2->rcv_saddr == sk->rcv_saddr) &&
+			    tcp_ipv4_addr_conflict (sk2,sk) &&
 			    (!sk2->reuse || !sk->reuse))
 				goto fail;
 		}
@@ -212,6 +213,17 @@ static void udp_v4_unhash(struct sock *s
 	write_unlock_bh(&udp_hash_lock);
 }
 
+static int udp_in_list (struct ip_info *ip_info, u32 addr)
+{
+	int n = ip_info->nbipv4;
+	int i;
+
+	for (i=0; i<n; i++)
+		if (ip_info->ipv4[i] == addr)
+			return 1;
+	return 0;
+}
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -233,6 +245,11 @@ struct sock *udp_v4_lookup_longway(u32 s
 				if(sk->rcv_saddr != daddr)
 					continue;
 				score+=2;
+			} else if (sk->ip_info) {
+				if (udp_in_list (sk->ip_info,daddr))
+					score+=2;
+				else
+					continue;
 			}
 			if(sk->daddr) {
 				if(sk->daddr != saddr)
@@ -286,7 +303,7 @@ static inline struct sock *udp_v4_mcast_
 		if ((s->num != hnum)					||
 		    (s->daddr && s->daddr!=rmt_addr)			||
 		    (s->dport != rmt_port && s->dport != 0)			||
-		    (s->rcv_saddr  && s->rcv_saddr != loc_addr)		||
+		    (s->rcv_saddr  && s->rcv_saddr != loc_addr && s->rcv_saddr2 != loc_addr)	||
 		    ipv6_only_sock(s)					||
 		    (s->bound_dev_if && s->bound_dev_if != dif))
 			continue;
@@ -534,6 +551,18 @@ int udp_sendmsg(struct sock *sk, struct 
 		rt = (struct rtable*)sk_dst_check(sk, 0);
 
 	if (rt == NULL) {
+		struct ip_info *ip_info = current->ip_info;
+
+		if (ip_info != NULL) {
+			__u32 ipv4root = ip_info->ipv4[0];
+			if (ipv4root) {
+				if (daddr == 0x0100007f &&
+					!vx_check(0, VX_ADMIN))
+					daddr = ipv4root;
+				if (ufh.saddr == 0)
+					ufh.saddr = ipv4root;
+			}
+		}
 		err = ip_route_output(&rt, daddr, ufh.saddr, tos, ipc.oif);
 		if (err)
 			goto out;
@@ -1021,7 +1050,8 @@ int udp_get_info(char *buffer, char **st
 		struct sock *sk;
 
 		for (sk = udp_hash[i]; sk; sk = sk->next, num++) {
-			if (sk->family != PF_INET)
+			if (sk->family != PF_INET ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += 128;
 			if (pos <= offset)
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv6/raw.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv6/raw.c
--- linux-2.4.25-rc1/net/ipv6/raw.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv6/raw.c	2004-02-06 02:52:25.000000000 +0100
@@ -880,7 +880,8 @@ int raw6_get_info(char *buffer, char **s
 		struct sock *sk;
 
 		for (sk = raw_v6_htable[i]; sk; sk = sk->next, num++) {
-			if (sk->family != PF_INET6)
+			if (sk->family != PF_INET6 ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += LINE_LEN+1;
 			if (pos <= offset)
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv6/tcp_ipv6.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv6/tcp_ipv6.c
--- linux-2.4.25-rc1/net/ipv6/tcp_ipv6.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv6/tcp_ipv6.c	2004-02-06 02:52:25.000000000 +0100
@@ -2029,7 +2029,8 @@ int tcp6_get_info(char *buffer, char **s
 			int uid;
 			struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
 
-			if (sk->family != PF_INET6)
+			if (sk->family != PF_INET6 ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += LINE_LEN+1;
 			if (pos >= offset) {
@@ -2079,7 +2080,8 @@ int tcp6_get_info(char *buffer, char **s
 
 		read_lock(&head->lock);
 		for(sk = head->chain; sk; sk = sk->next, num++) {
-			if (sk->family != PF_INET6)
+			if (sk->family != PF_INET6 ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += LINE_LEN+1;
 			if (pos <= offset)
@@ -2094,7 +2096,8 @@ int tcp6_get_info(char *buffer, char **s
 		for (tw = (struct tcp_tw_bucket *)tcp_ehash[i+tcp_ehash_size].chain;
 		     tw != NULL;
 		     tw = (struct tcp_tw_bucket *)tw->next, num++) {
-			if (tw->family != PF_INET6)
+			if (tw->family != PF_INET6 ||
+				!vx_check(tw->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += LINE_LEN+1;
 			if (pos <= offset)
diff -NurpP --minimal linux-2.4.25-rc1/net/ipv6/udp.c linux-2.4.25-rc1-vs1.3.6.3/net/ipv6/udp.c
--- linux-2.4.25-rc1/net/ipv6/udp.c	2004-02-06 00:45:55.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/ipv6/udp.c	2004-02-06 02:52:25.000000000 +0100
@@ -982,7 +982,8 @@ int udp6_get_info(char *buffer, char **s
 		struct sock *sk;
 
 		for (sk = udp_hash[i]; sk; sk = sk->next, num++) {
-			if (sk->family != PF_INET6)
+			if (sk->family != PF_INET6 ||
+				!vx_check(sk->xid, VX_WATCH|VX_IDENT))
 				continue;
 			pos += LINE_LEN+1;
 			if (pos <= offset)
diff -NurpP --minimal linux-2.4.25-rc1/net/unix/af_unix.c linux-2.4.25-rc1-vs1.3.6.3/net/unix/af_unix.c
--- linux-2.4.25-rc1/net/unix/af_unix.c	2002-11-29 00:53:16.000000000 +0100
+++ linux-2.4.25-rc1-vs1.3.6.3/net/unix/af_unix.c	2004-02-06 02:52:25.000000000 +0100
@@ -109,6 +109,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/rtnetlink.h>
+#include <linux/vinline.h>
 
 #include <asm/checksum.h>
 
@@ -479,6 +480,8 @@ static struct sock * unix_create1(struct
 
 	sk->write_space		=	unix_write_space;
 
+	sk->xid = vx_current_xid();
+
 	sk->max_ack_backlog = sysctl_unix_max_dgram_qlen;
 	sk->destruct = unix_sock_destructor;
 	sk->protinfo.af_unix.dentry=NULL;
@@ -1756,6 +1759,9 @@ static int unix_read_proc(char *buffer, 
 	read_lock(&unix_table_lock);
 	forall_unix_sockets (i,s)
 	{
+		if (!vx_check(s->xid, VX_WATCH|VX_IDENT))
+			continue;
+
 		unix_state_rlock(s);
 
 		len+=sprintf(buffer+len,"%p: %08X %08X %08X %04X %02X %5lu",
