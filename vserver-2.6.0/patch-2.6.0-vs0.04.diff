diff -NurpP --minimal linux-2.6.0/arch/alpha/kernel/systbls.S linux-2.6.0-vs0.04/arch/alpha/kernel/systbls.S
--- linux-2.6.0/arch/alpha/kernel/systbls.S	Thu Dec 18 03:59:05 2003
+++ linux-2.6.0-vs0.04/arch/alpha/kernel/systbls.S	Sun Dec 28 03:00:23 2003
@@ -291,7 +291,7 @@ sys_call_table:
 	.quad alpha_ni_syscall			/* 270 */
 	.quad alpha_ni_syscall
 	.quad alpha_ni_syscall
-	.quad alpha_ni_syscall
+	.quad sys_vserver			/* 273 sys_vserver */
 	.quad alpha_ni_syscall
 	.quad alpha_ni_syscall			/* 275 */
 	.quad alpha_ni_syscall
diff -NurpP --minimal linux-2.6.0/arch/i386/kernel/entry.S linux-2.6.0-vs0.04/arch/i386/kernel/entry.S
--- linux-2.6.0/arch/i386/kernel/entry.S	Thu Dec 18 03:58:30 2003
+++ linux-2.6.0-vs0.04/arch/i386/kernel/entry.S	Sun Dec 28 03:00:23 2003
@@ -881,6 +881,6 @@ ENTRY(sys_call_table)
 	.long sys_tgkill	/* 270 */
 	.long sys_utimes
  	.long sys_fadvise64_64
-	.long sys_ni_syscall	/* sys_vserver */
+	.long sys_vserver
 
 syscall_table_size=(.-sys_call_table)
diff -NurpP --minimal linux-2.6.0/arch/ppc/kernel/misc.S linux-2.6.0-vs0.04/arch/ppc/kernel/misc.S
--- linux-2.6.0/arch/ppc/kernel/misc.S	Thu Dec 18 03:59:38 2003
+++ linux-2.6.0-vs0.04/arch/ppc/kernel/misc.S	Sun Dec 28 03:00:23 2003
@@ -1385,3 +1385,23 @@ _GLOBAL(sys_call_table)
 	.long sys_statfs64
 	.long sys_fstatfs64
 	.long ppc_fadvise64_64
+	.long sys_ni_syscall	/* 255 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 260 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 265 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_ni_syscall	/* 270 */
+	.long sys_ni_syscall
+	.long sys_ni_syscall
+	.long sys_vserver	/* 273 sys_vserver */
+
diff -NurpP --minimal linux-2.6.0/arch/ppc64/kernel/misc.S linux-2.6.0-vs0.04/arch/ppc64/kernel/misc.S
--- linux-2.6.0/arch/ppc64/kernel/misc.S	Thu Dec 18 03:59:29 2003
+++ linux-2.6.0-vs0.04/arch/ppc64/kernel/misc.S	Sun Dec 28 03:00:23 2003
@@ -852,6 +852,26 @@ _GLOBAL(sys_call_table32)
 	.llong .sys32_utimes
 	.llong .sys_statfs64
 	.llong .sys_fstatfs64
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 255 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 260 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 265 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 270 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_vserver		/* 273 sys_vserver */
 
 	.balign 8
 _GLOBAL(sys_call_table)
@@ -1109,3 +1129,24 @@ _GLOBAL(sys_call_table)
 	.llong .sys_utimes
 	.llong .sys_statfs64
 	.llong .sys_fstatfs64
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 255 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 260 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 265 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall	/* 270 */
+	.llong .sys_ni_syscall
+	.llong .sys_ni_syscall
+	.llong .sys_vserver		/* 273 sys_vserver */
+
diff -NurpP --minimal linux-2.6.0/arch/s390/kernel/syscalls.S linux-2.6.0-vs0.04/arch/s390/kernel/syscalls.S
--- linux-2.6.0/arch/s390/kernel/syscalls.S	Thu Dec 18 03:58:08 2003
+++ linux-2.6.0-vs0.04/arch/s390/kernel/syscalls.S	Sun Dec 28 03:00:23 2003
@@ -271,4 +271,4 @@ SYSCALL(sys_clock_settime,sys_clock_sett
 SYSCALL(sys_clock_gettime,sys_clock_gettime,sys_ni_syscall)	/* 260 */
 SYSCALL(sys_clock_getres,sys_clock_getres,sys_ni_syscall)
 SYSCALL(sys_clock_nanosleep,sys_clock_nanosleep,sys_ni_syscall)
-NI_SYSCALL							/* reserved for vserver */
+SYSCALL(sys_vserver,sys_vserver,sys_vserver)
diff -NurpP --minimal linux-2.6.0/arch/sparc/kernel/systbls.S linux-2.6.0-vs0.04/arch/sparc/kernel/systbls.S
--- linux-2.6.0/arch/sparc/kernel/systbls.S	Thu Dec 18 03:58:49 2003
+++ linux-2.6.0-vs0.04/arch/sparc/kernel/systbls.S	Sun Dec 28 03:00:23 2003
@@ -72,7 +72,7 @@ sys_call_table:
 /*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 /*255*/	.long sys_nis_syscall, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.long sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-/*265*/	.long sys_timer_delete, sys_timer_create, sys_nis_syscall, sys_io_setup, sys_io_destroy
+/*265*/	.long sys_timer_delete, sys_timer_create, sys_vserver, sys_io_setup, sys_io_destroy
 /*270*/	.long sys_io_submit, sys_io_cancel, sys_io_getevents, sys_nis_syscall
 
 #ifdef CONFIG_SUNOS_EMUL
diff -NurpP --minimal linux-2.6.0/arch/sparc64/kernel/systbls.S linux-2.6.0-vs0.04/arch/sparc64/kernel/systbls.S
--- linux-2.6.0/arch/sparc64/kernel/systbls.S	Thu Dec 18 03:58:48 2003
+++ linux-2.6.0-vs0.04/arch/sparc64/kernel/systbls.S	Sun Dec 28 03:00:23 2003
@@ -72,7 +72,7 @@ sys_call_table32:
 /*250*/	.word sys32_mremap, sys32_sysctl, sys_getsid, sys_fdatasync, sys32_nfsservctl
 	.word sys_ni_syscall, compat_clock_settime, compat_clock_gettime, compat_clock_getres, compat_clock_nanosleep
 /*260*/	.word compat_sys_sched_getaffinity, compat_sys_sched_setaffinity, compat_timer_settime, compat_timer_gettime, sys_timer_getoverrun
-	.word sys_timer_delete, sys32_timer_create, sys_ni_syscall, sys_ni_syscall, sys_ni_syscall
+	.word sys_timer_delete, sys32_timer_create, sys_vserver, sys_ni_syscall, sys_ni_syscall
 /*270*/	.word sys_ni_syscall, sys_ni_syscall, sys_ni_syscall, sys_ni_syscall
 
 	/* Now the 64-bit native Linux syscall table. */
@@ -134,7 +134,7 @@ sys_call_table:
 /*250*/	.word sys64_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 	.word sys_ni_syscall, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.word sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
-	.word sys_timer_delete, sys_timer_create, sys_ni_syscall, sys_io_setup, sys_io_destroy
+	.word sys_timer_delete, sys_timer_create, sys_vserver, sys_io_setup, sys_io_destroy
 /*270*/	.word sys_io_submit, sys_io_cancel, sys_io_getevents, sys_ni_syscall
 
 #if defined(CONFIG_SUNOS_EMUL) || defined(CONFIG_SOLARIS_EMUL) || \
diff -NurpP --minimal linux-2.6.0/arch/x86_64/ia32/ia32entry.S linux-2.6.0-vs0.04/arch/x86_64/ia32/ia32entry.S
--- linux-2.6.0/arch/x86_64/ia32/ia32entry.S	Thu Dec 18 03:58:48 2003
+++ linux-2.6.0-vs0.04/arch/x86_64/ia32/ia32entry.S	Sun Dec 28 03:00:23 2003
@@ -448,34 +448,35 @@ ia32_sys_call_table:
         .quad compat_sys_sched_getaffinity
 	.quad sys32_set_thread_area
 	.quad sys32_get_thread_area
-	.quad sys32_io_setup
+	.quad sys32_io_setup	/* 245 */
 	.quad sys_io_destroy
 	.quad sys32_io_getevents
 	.quad sys32_io_submit
 	.quad sys_io_cancel
-	.quad sys_fadvise64
+	.quad sys_fadvise64	/* 250 */
 	.quad sys_ni_syscall /* free_huge_pages */
 	.quad sys_exit_group /* exit_group */
 	.quad sys_lookup_dcookie
 	.quad sys_epoll_create
-	.quad sys_epoll_ctl
+	.quad sys_epoll_ctl	/* 255 */
 	.quad sys_epoll_wait
 	.quad sys_remap_file_pages
 	.quad sys_set_tid_address
 	.quad sys32_timer_create
-	.quad compat_timer_settime
+	.quad compat_timer_settime	/* 260 */
 	.quad compat_timer_gettime
 	.quad sys_timer_getoverrun
 	.quad sys_timer_delete
 	.quad compat_clock_settime
-	.quad compat_clock_gettime
+	.quad compat_clock_gettime	/* 265 */
 	.quad compat_clock_getres
 	.quad compat_clock_nanosleep
 	.quad compat_statfs64   /* statfs64 */
 	.quad compat_fstatfs64  /* fstatfs64 */
-	.quad sys_tgkill
+	.quad sys_tgkill	/* 270 */
 	.quad compat_sys_utimes
 	.quad sys32_fadvise64_64
+	.quad sys_vserver	/* 273 sys_vserver */
 	/* don't forget to change IA32_NR_syscalls */
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
diff -NurpP --minimal linux-2.6.0/fs/inode.c linux-2.6.0-vs0.04/fs/inode.c
--- linux-2.6.0/fs/inode.c	Thu Dec 18 03:59:55 2003
+++ linux-2.6.0-vs0.04/fs/inode.c	Sun Dec 28 03:00:23 2003
@@ -131,6 +131,7 @@ static struct inode *alloc_inode(struct 
 		inode->i_bdev = NULL;
 		inode->i_cdev = NULL;
 		inode->i_rdev = 0;
+		inode->i_xid = 0;	/* maybe not too wise ... */
 		inode->i_security = NULL;
 		if (security_inode_alloc(inode)) {
 			if (inode->i_sb->s_op->destroy_inode)
diff -NurpP --minimal linux-2.6.0/fs/proc/Makefile linux-2.6.0-vs0.04/fs/proc/Makefile
--- linux-2.6.0/fs/proc/Makefile	Thu Dec 18 03:58:07 2003
+++ linux-2.6.0-vs0.04/fs/proc/Makefile	Sun Dec 28 03:00:23 2003
@@ -8,7 +8,7 @@ proc-y			:= task_nommu.o
 proc-$(CONFIG_MMU)	:= task_mmu.o
 
 proc-y       += inode.o root.o base.o generic.o array.o \
-		kmsg.o proc_tty.o proc_misc.o
+		kmsg.o proc_tty.o proc_misc.o virtual.o
 
 proc-$(CONFIG_PROC_KCORE)	+= kcore.o
 proc-$(CONFIG_PROC_DEVICETREE)	+= proc_devtree.o
diff -NurpP --minimal linux-2.6.0/fs/proc/base.c linux-2.6.0-vs0.04/fs/proc/base.c
--- linux-2.6.0/fs/proc/base.c	Thu Dec 18 03:58:58 2003
+++ linux-2.6.0-vs0.04/fs/proc/base.c	Mon Dec 29 21:13:39 2003
@@ -32,6 +32,7 @@
 #include <linux/mount.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/vinline.h>
 
 /*
  * For hysterical raisins we keep the same inumbers as in the old procfs.
@@ -67,6 +68,7 @@ enum pid_directory_inos {
 	PROC_TGID_ATTR_EXEC,
 	PROC_TGID_ATTR_FSCREATE,
 #endif
+	PROC_TGID_VINFO,
 	PROC_TGID_FD_DIR,
 	PROC_TID_INO,
 	PROC_TID_STATUS,
@@ -90,6 +92,7 @@ enum pid_directory_inos {
 	PROC_TID_ATTR_EXEC,
 	PROC_TID_ATTR_FSCREATE,
 #endif
+	PROC_TID_VINFO,
 	PROC_TID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 };
 
@@ -123,6 +126,7 @@ static struct pid_entry tgid_base_stuff[
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TGID_WCHAN,     "wchan",   S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TGID_VINFO,     "vinfo",   S_IFREG|S_IRUGO),
 	{0,0,NULL,0}
 };
 static struct pid_entry tid_base_stuff[] = {
@@ -145,6 +149,7 @@ static struct pid_entry tid_base_stuff[]
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TID_WCHAN,      "wchan",   S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TID_VINFO,      "vinfo",   S_IFREG|S_IRUGO),
 	{0,0,NULL,0}
 };
 
@@ -181,6 +186,7 @@ int proc_pid_stat(struct task_struct*,ch
 int proc_pid_status(struct task_struct*,char*);
 int proc_pid_statm(struct task_struct*,char*);
 int proc_pid_cpu(struct task_struct*,char*);
+int proc_pid_vinfo(struct task_struct*,char*);
 
 static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsmount **mnt)
 {
@@ -932,6 +938,7 @@ static struct inode *proc_pid_make_inode
 		inode->i_uid = task->euid;
 		inode->i_gid = task->egid;
 	}
+	inode->i_xid = vx_task_id(task);
 	security_task_to_inode(task, inode);
 
 out:
@@ -1361,6 +1368,11 @@ static struct dentry *proc_pident_lookup
 			ei->op.proc_read = proc_pid_wchan;
 			break;
 #endif
+		case PROC_TID_VINFO:
+		case PROC_TGID_VINFO:
+			inode->i_fop = &proc_info_file_operations;
+			ei->op.proc_read = proc_pid_vinfo;
+			break;
 		default:
 			printk("procfs: impossible type (%d)",p->type);
 			iput(inode);
@@ -1552,6 +1564,10 @@ struct dentry *proc_pid_lookup(struct in
 	if (!task)
 		goto out;
 
+	if (tgid != 1 && !vx_check(task->vx_id, VX_WATCH|VX_IDENT)) {
+		put_task_struct(task);
+		goto out;
+	}
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_TGID_INO);
 
 
@@ -1599,7 +1615,6 @@ static struct dentry *proc_task_lookup(s
 
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_TID_INO);
 
-
 	if (!inode) {
 		put_task_struct(task);
 		goto out;
@@ -1641,6 +1656,10 @@ static int get_tgid_list(int index, unsi
 	for_each_process(p) {
 		int tgid = p->pid;
 		if (!pid_alive(p))
+			continue;
+		if (tgid != 1 && !vx_check(p->vx_id, VX_WATCH|VX_IDENT))
+			continue;
+		if (current->vx_info && current->vx_info->vx_initpid == tgid)
 			continue;
 		if (--index >= 0)
 			continue;
diff -NurpP --minimal linux-2.6.0/fs/proc/generic.c linux-2.6.0-vs0.04/fs/proc/generic.c
--- linux-2.6.0/fs/proc/generic.c	Thu Dec 18 03:59:57 2003
+++ linux-2.6.0-vs0.04/fs/proc/generic.c	Mon Dec 29 21:14:49 2003
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/mount.h>
 #include <linux/smp_lock.h>
+#include <linux/vinline.h>
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 
@@ -424,9 +425,12 @@ int proc_readdir(struct file * filp,
 			}
 
 			do {
+				if (de->vx_flags && !vx_check(de->xid, de->vx_flags))
+					goto skip;
 				if (filldir(dirent, de->name, de->namelen, filp->f_pos,
 					    de->low_ino, de->mode >> 12) < 0)
 					goto out;
+			skip:
 				filp->f_pos++;
 				de = de->next;
 			} while (de);
diff -NurpP --minimal linux-2.6.0/fs/proc/inode.c linux-2.6.0-vs0.04/fs/proc/inode.c
--- linux-2.6.0/fs/proc/inode.c	Thu Dec 18 03:59:36 2003
+++ linux-2.6.0-vs0.04/fs/proc/inode.c	Sun Dec 28 03:00:23 2003
@@ -207,6 +207,9 @@ printk("proc_iget: using deleted entry %
 			inode->i_uid = de->uid;
 			inode->i_gid = de->gid;
 		}
+		inode->i_xid = de->xid;
+		if (de->vx_flags)
+			PROC_I(inode)->vx_flags = de->vx_flags;
 		if (de->size)
 			inode->i_size = de->size;
 		if (de->nlink)
diff -NurpP --minimal linux-2.6.0/fs/proc/root.c linux-2.6.0-vs0.04/fs/proc/root.c
--- linux-2.6.0/fs/proc/root.c	Thu Dec 18 03:59:17 2003
+++ linux-2.6.0-vs0.04/fs/proc/root.c	Sun Dec 28 03:00:23 2003
@@ -23,6 +23,7 @@ struct proc_dir_entry *proc_net, *proc_b
 #ifdef CONFIG_SYSCTL
 struct proc_dir_entry *proc_sys_root;
 #endif
+struct proc_dir_entry *proc_virtual;
 
 static struct super_block *proc_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
@@ -78,6 +79,7 @@ void __init proc_root_init(void)
 	proc_rtas_init();
 #endif
 	proc_bus = proc_mkdir("bus", 0);
+	proc_virtual = proc_mkdir("virtual", 0);
 }
 
 static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)
diff -NurpP --minimal linux-2.6.0/fs/proc/virtual.c linux-2.6.0-vs0.04/fs/proc/virtual.c
--- linux-2.6.0/fs/proc/virtual.c	Thu Jan  1 01:00:00 1970
+++ linux-2.6.0-vs0.04/fs/proc/virtual.c	Mon Dec 29 21:23:11 2003
@@ -0,0 +1,179 @@
+/*
+ *  linux/fs/proc/virtual.c
+ *
+ *  Virtual Context ProcFS Support
+ *
+ *  Copyright (C) 2003  Herbert Pötzl
+ *
+ *  V0.01  basic directory array
+ *  V0.02  per context info & stat
+ *  V0.03  proc permissions
+ *
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+
+#include <linux/init.h>
+#include <linux/vswitch.h>
+#include <linux/vinline.h>
+
+
+extern struct proc_dir_entry *proc_virtual;
+static struct proc_dir_entry *proc_virtual_info;
+
+
+char *task_vinfo(struct task_struct *p, char *buffer)
+{
+	return buffer + sprintf(buffer,
+		"VxID:\t%d\n"
+		,p->vx_id);
+}
+
+int proc_pid_vinfo(struct task_struct *p, char *buffer)
+{
+	char * orig = buffer;
+
+        buffer = task_vinfo(p, buffer);
+        return buffer - orig;
+}
+
+
+static int __generic_info_read_func(char *page, char **start,
+	off_t off, int count, int *eof, void *data,
+	char *(*info_func)(void *, char *))
+{
+	int len;
+	char *buffer = page;
+
+	buffer = info_func(data, buffer);
+
+	len = buffer-page;
+	if (len <= off+count) *eof = 1;
+	
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+
+char *vx_proc_info (void *data, char *buffer)
+{
+	struct vx_info *vxi = data;
+	buffer += sprintf(buffer,
+		"VxID:\t%d\n"
+		"Info:\t%p\n"
+		"Init:\t%d\n"
+		,vxi->vx_id
+		,vxi
+		,vxi->vx_initpid);
+	return buffer;
+}
+
+int vx_info_read_func (char *page, char **start,
+	off_t off, int count, int *eof, void *data)
+{
+	return __generic_info_read_func(page, start,
+	    off, count, eof, data, vx_proc_info);
+}
+
+char *vx_proc_status (void *data, char *buffer)
+{
+	struct vx_info *vxi = data;
+	buffer += sprintf(buffer,
+		"RefC:\t%d\n"		
+		"Flags:\t%08x\n"
+		"Ticks:\t%d\n"		
+		,atomic_read(&vxi->vx_refcount)
+		,vxi->vx_flags
+		,atomic_read(&vxi->limit.ticks));
+	return buffer;
+}
+
+int vx_status_read_func (char *page, char **start,
+	off_t off, int count, int *eof, void *data)
+{
+	return __generic_info_read_func(page, start,
+	    off, count, eof, data, vx_proc_status);
+}
+
+
+static int vx_proc_permission(struct inode *inode,
+	int mask, struct nameidata *nd)
+{
+	vxdprintk("vx_proc_permission(%p) = #%d,%04x\n",
+		inode, inode->i_xid, PROC_I(inode)->vx_flags);
+	if (vx_check(inode->i_xid, PROC_I(inode)->vx_flags))
+		return 0;
+	vxdprintk("vx_proc_permission(%p) #%d != #%d\n",
+		inode, inode->i_xid, vx_current_id());
+	return -ENOENT;
+}
+
+static struct inode_operations vx_proc_inode_operations = {
+	.lookup = proc_lookup,
+	.permission = vx_proc_permission,
+};
+
+
+int vx_proc_create(struct vx_info *vxi)
+{
+	struct proc_dir_entry *entry, *sub;
+	char name[8];
+
+	snprintf(name, sizeof(name)-1, "%d", vxi->vx_id);
+	entry = create_proc_entry(name,
+		S_IFDIR|S_IXUGO, proc_virtual);
+	entry->vx_flags = VX_ADMIN|VX_WATCH|VX_IDENT;
+	entry->xid = vxi->vx_id;
+	entry->proc_iops = &vx_proc_inode_operations;
+        vxi->vx_procent = entry;
+	sub = create_proc_read_entry("info",
+		S_IFREG|S_IRUGO|S_IWUSR,
+		entry, vx_info_read_func, vxi);
+	sub = create_proc_read_entry("status",
+		S_IFREG|S_IRUGO|S_IWUSR,
+		entry, vx_status_read_func, vxi);
+	return 0;
+}
+
+int vx_proc_destroy(struct vx_info *vxi)
+{
+	struct proc_dir_entry *entry = vxi->vx_procent;
+	if (!entry)
+	    return 0;
+	remove_proc_entry(entry->name, proc_virtual);
+	vxi->vx_procent = NULL;
+	return 0;
+}
+
+char *vs_proc_info(void *data, char *buffer)
+{
+	buffer += sprintf(buffer,
+		"VCIVersion:\t%04x:%04x\n"
+		,VCI_VERSION >> 16
+		,VCI_VERSION & 0xFFFF);
+	return buffer;
+}
+
+int vs_info_read_func(char *page, char **start,
+	off_t off, int count, int *eof, void *data)
+{
+	return __generic_info_read_func(page, start,
+	    off, count, eof, data, vs_proc_info);
+}
+
+
+static int __init virtual_proc_init(void)
+{
+	proc_virtual_info = create_proc_read_entry("info",
+		S_IFREG|S_IRUGO|S_IWUSR,
+		proc_virtual, vs_info_read_func, NULL);
+	return 0;
+}
+
+__initcall(virtual_proc_init);
diff -NurpP --minimal linux-2.6.0/include/asm-alpha/unistd.h linux-2.6.0-vs0.04/include/asm-alpha/unistd.h
--- linux-2.6.0/include/asm-alpha/unistd.h	Thu Dec 18 03:58:47 2003
+++ linux-2.6.0-vs0.04/include/asm-alpha/unistd.h	Sun Dec 28 03:00:23 2003
@@ -233,6 +233,7 @@
 #define __NR_osf_memcntl	260	/* not implemented */
 #define __NR_osf_fdatasync	261	/* not implemented */
 
+#define __NR_vserver		273
 
 /*
  * Linux-specific system calls begin at 300
diff -NurpP --minimal linux-2.6.0/include/asm-m68k/unistd.h linux-2.6.0-vs0.04/include/asm-m68k/unistd.h
--- linux-2.6.0/include/asm-m68k/unistd.h	Thu Dec 18 03:58:49 2003
+++ linux-2.6.0-vs0.04/include/asm-m68k/unistd.h	Sun Dec 28 03:00:23 2003
@@ -239,7 +239,9 @@
 #define __NR_fremovexattr	234
 #define __NR_futex		235
 
-#define NR_syscalls		236
+#define __NR_vserver		273
+
+#define NR_syscalls		274
 
 /* user-visible error numbers are in the range -1 - -124: see
    <asm-m68k/errno.h> */
diff -NurpP --minimal linux-2.6.0/include/asm-m68knommu/unistd.h linux-2.6.0-vs0.04/include/asm-m68knommu/unistd.h
--- linux-2.6.0/include/asm-m68knommu/unistd.h	Thu Dec 18 03:58:50 2003
+++ linux-2.6.0-vs0.04/include/asm-m68knommu/unistd.h	Sun Dec 28 03:00:23 2003
@@ -221,7 +221,9 @@
 #define __NR_setfsuid32		215
 #define __NR_setfsgid32		216
 
-#define	NR_syscalls		256
+#define __NR_vserver		273
+
+#define	NR_syscalls		274
 
 /* user-visible error numbers are in the range -1 - -122: see
    <asm-m68k/errno.h> */
diff -NurpP --minimal linux-2.6.0/include/asm-mips/unistd.h linux-2.6.0-vs0.04/include/asm-mips/unistd.h
--- linux-2.6.0/include/asm-mips/unistd.h	Thu Dec 18 03:58:04 2003
+++ linux-2.6.0-vs0.04/include/asm-mips/unistd.h	Sun Dec 28 03:00:23 2003
@@ -289,10 +289,12 @@
 #define __NR_tgkill			(__NR_Linux + 266)
 #define __NR_utimes			(__NR_Linux + 267)
 
+#define __NR_vserver			(__NR_Linux + 273)
+
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		267
+#define __NR_Linux_syscalls		273
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
diff -NurpP --minimal linux-2.6.0/include/asm-parisc/unistd.h linux-2.6.0-vs0.04/include/asm-parisc/unistd.h
--- linux-2.6.0/include/asm-parisc/unistd.h	Thu Dec 18 03:57:59 2003
+++ linux-2.6.0-vs0.04/include/asm-parisc/unistd.h	Sun Dec 28 03:00:23 2003
@@ -722,8 +722,9 @@
 #define __NR_remap_file_pages	(__NR_Linux + 227)
 #define __NR_semtimedop		(__NR_Linux + 228)
 
+#define __NR_vserver		(__NR_Linux + 273)
 
-#define __NR_Linux_syscalls     228
+#define __NR_Linux_syscalls     273
 
 #define HPUX_GATEWAY_ADDR       0xC0000004
 #define LINUX_GATEWAY_ADDR      0x100
diff -NurpP --minimal linux-2.6.0/include/asm-ppc/unistd.h linux-2.6.0-vs0.04/include/asm-ppc/unistd.h
--- linux-2.6.0/include/asm-ppc/unistd.h	Thu Dec 18 03:58:18 2003
+++ linux-2.6.0-vs0.04/include/asm-ppc/unistd.h	Sun Dec 28 03:00:23 2003
@@ -260,7 +260,9 @@
 #define __NR_fstatfs64		253
 #define __NR_fadvise64_64	254
 
-#define __NR_syscalls		255
+#define __NR_vserver		273
+
+#define __NR_syscalls		274
 
 #define __NR(n)	#n
 
diff -NurpP --minimal linux-2.6.0/include/asm-ppc64/unistd.h linux-2.6.0-vs0.04/include/asm-ppc64/unistd.h
--- linux-2.6.0/include/asm-ppc64/unistd.h	Thu Dec 18 03:58:04 2003
+++ linux-2.6.0-vs0.04/include/asm-ppc64/unistd.h	Sun Dec 28 03:00:23 2003
@@ -265,7 +265,9 @@
 #define __NR_statfs64		252
 #define __NR_fstatfs64		253
 
-#define __NR_syscalls		254
+#define __NR_vserver		273
+
+#define __NR_syscalls		274
 #ifdef __KERNEL__
 #define NR_syscalls	__NR_syscalls
 #endif
diff -NurpP --minimal linux-2.6.0/include/asm-s390/unistd.h linux-2.6.0-vs0.04/include/asm-s390/unistd.h
--- linux-2.6.0/include/asm-s390/unistd.h	Thu Dec 18 04:00:01 2003
+++ linux-2.6.0-vs0.04/include/asm-s390/unistd.h	Sun Dec 28 03:00:23 2003
@@ -256,9 +256,7 @@
 #define __NR_clock_gettime	(__NR_timer_create+6)
 #define __NR_clock_getres	(__NR_timer_create+7)
 #define __NR_clock_nanosleep	(__NR_timer_create+8)
-/*
- * Number 263 is reserved for vserver
- */
+#define __NR_vserver		263
 
 #define NR_syscalls 264
 
diff -NurpP --minimal linux-2.6.0/include/asm-sh/unistd.h linux-2.6.0-vs0.04/include/asm-sh/unistd.h
--- linux-2.6.0/include/asm-sh/unistd.h	Thu Dec 18 03:59:29 2003
+++ linux-2.6.0-vs0.04/include/asm-sh/unistd.h	Sun Dec 28 03:00:23 2003
@@ -276,7 +276,9 @@
 #define __NR_clock_getres	(__NR_timer_create+7)
 #define __NR_clock_nanosleep	(__NR_timer_create+8)
 
-#define NR_syscalls 268
+#define __NR_vserver		273
+
+#define NR_syscalls		274
 
 /* user-visible error numbers are in the range -1 - -124: see <asm-sh/errno.h> */
 
diff -NurpP --minimal linux-2.6.0/include/asm-sparc/unistd.h linux-2.6.0-vs0.04/include/asm-sparc/unistd.h
--- linux-2.6.0/include/asm-sparc/unistd.h	Thu Dec 18 03:58:08 2003
+++ linux-2.6.0-vs0.04/include/asm-sparc/unistd.h	Sun Dec 28 03:00:23 2003
@@ -283,7 +283,7 @@
 #define __NR_timer_getoverrun	264
 #define __NR_timer_delete	265
 #define __NR_timer_create	266
-/* #define __NR_vserver		267 Reserved for VSERVER */
+#define __NR_vserver		267
 #define __NR_io_setup		268
 #define __NR_io_destroy		268
 #define __NR_io_submit		269
diff -NurpP --minimal linux-2.6.0/include/asm-sparc64/unistd.h linux-2.6.0-vs0.04/include/asm-sparc64/unistd.h
--- linux-2.6.0/include/asm-sparc64/unistd.h	Thu Dec 18 03:58:16 2003
+++ linux-2.6.0-vs0.04/include/asm-sparc64/unistd.h	Sun Dec 28 03:00:23 2003
@@ -285,7 +285,7 @@
 #define __NR_timer_getoverrun	264
 #define __NR_timer_delete	265
 #define __NR_timer_create	266
-/* #define __NR_vserver		267 Reserved for VSERVER */
+#define __NR_vserver		267
 #define __NR_io_setup		268
 #define __NR_io_destroy		268
 #define __NR_io_submit		269
diff -NurpP --minimal linux-2.6.0/include/asm-x86_64/ia32_unistd.h linux-2.6.0-vs0.04/include/asm-x86_64/ia32_unistd.h
--- linux-2.6.0/include/asm-x86_64/ia32_unistd.h	Thu Dec 18 03:59:05 2003
+++ linux-2.6.0-vs0.04/include/asm-x86_64/ia32_unistd.h	Sun Dec 28 03:00:23 2003
@@ -278,6 +278,7 @@
 #define __NR_ia32_tgkill		270
 #define __NR_ia32_utimes		271
 #define __NR_ia32_fadvise64_64		272
+#define __NR_ia32_vserver		273
 
 #define IA32_NR_syscalls 275	/* must be > than biggest syscall! */	
 
diff -NurpP --minimal linux-2.6.0/include/linux/fs.h linux-2.6.0-vs0.04/include/linux/fs.h
--- linux-2.6.0/include/linux/fs.h	Thu Dec 18 03:58:29 2003
+++ linux-2.6.0-vs0.04/include/linux/fs.h	Sun Dec 28 03:00:23 2003
@@ -376,6 +376,7 @@ struct inode {
 	unsigned int		i_nlink;
 	uid_t			i_uid;
 	gid_t			i_gid;
+	xid_t			i_xid;
 	dev_t			i_rdev;
 	loff_t			i_size;
 	struct timespec		i_atime;
diff -NurpP --minimal linux-2.6.0/include/linux/init_task.h linux-2.6.0-vs0.04/include/linux/init_task.h
--- linux-2.6.0/include/linux/init_task.h	Thu Dec 18 03:58:08 2003
+++ linux-2.6.0-vs0.04/include/linux/init_task.h	Sun Dec 28 03:32:11 2003
@@ -108,6 +108,10 @@
 	.proc_lock	= SPIN_LOCK_UNLOCKED,				\
 	.switch_lock	= SPIN_LOCK_UNLOCKED,				\
 	.journal_info	= NULL,						\
+	.cap_bset	= CAP_INIT_EFF_SET,				\
+	.vx_id		= 0,						\
+	.vx_info	= NULL,						\
+	.ip_info	= NULL,						\
 }
 
 
diff -NurpP --minimal linux-2.6.0/include/linux/ip.h linux-2.6.0-vs0.04/include/linux/ip.h
--- linux-2.6.0/include/linux/ip.h	Thu Dec 18 03:58:38 2003
+++ linux-2.6.0-vs0.04/include/linux/ip.h	Sun Jan  4 20:32:25 2004
@@ -111,9 +111,11 @@ struct inet_opt {
 	/* Socket demultiplex comparisons on incoming packets. */
 	__u32			daddr;		/* Foreign IPv4 addr */
 	__u32			rcv_saddr;	/* Bound local IPv4 addr */
+	__u32			rcv_saddr2;	/* Second bound ipv4 addr, for ipv4root */
 	__u16			dport;		/* Destination port */
 	__u16			num;		/* Local port */
 	__u32			saddr;		/* Sending source */
+//	__u32			saddr2;		/* Second bound ipv4 addr, for ipv4root */
 	int			uc_ttl;		/* Unicast TTL */
 	int			tos;		/* TOS */
 	unsigned	   	cmsg_flags;
diff -NurpP --minimal linux-2.6.0/include/linux/proc_fs.h linux-2.6.0-vs0.04/include/linux/proc_fs.h
--- linux-2.6.0/include/linux/proc_fs.h	Thu Dec 18 03:57:58 2003
+++ linux-2.6.0-vs0.04/include/linux/proc_fs.h	Sun Dec 28 03:00:23 2003
@@ -60,6 +60,8 @@ struct proc_dir_entry {
 	nlink_t nlink;
 	uid_t uid;
 	gid_t gid;
+	xid_t xid;
+	int vx_flags;
 	unsigned long size;
 	struct inode_operations * proc_iops;
 	struct file_operations * proc_fops;
@@ -236,6 +238,7 @@ extern struct kcore_list *kclist_del(voi
 struct proc_inode {
 	struct task_struct *task;
 	int type;
+	int vx_flags;
 	union {
 		int (*proc_get_link)(struct inode *, struct dentry **, struct vfsmount **);
 		int (*proc_read)(struct task_struct *task, char *page);
diff -NurpP --minimal linux-2.6.0/include/linux/sched.h linux-2.6.0-vs0.04/include/linux/sched.h
--- linux-2.6.0/include/linux/sched.h	Thu Dec 18 03:58:08 2003
+++ linux-2.6.0-vs0.04/include/linux/sched.h	Sun Dec 28 03:36:02 2003
@@ -102,6 +102,7 @@ extern unsigned long nr_iowait(void);
 #include <linux/timer.h>
 
 #include <asm/processor.h>
+#include <linux/vcontext.h>
 
 #define TASK_RUNNING		0
 #define TASK_INTERRUPTIBLE	1
@@ -297,9 +298,10 @@ struct user_struct {
 	/* Hash table maintenance information */
 	struct list_head uidhash_list;
 	uid_t uid;
+	int vx_id;
 };
 
-extern struct user_struct *find_user(uid_t);
+extern struct user_struct *find_user(xid_t, uid_t);
 
 extern struct user_struct root_user;
 #define INIT_USER (&root_user)
@@ -441,6 +443,12 @@ struct task_struct {
 	
 	void *security;
 
+/* vserver data */
+	kernel_cap_t cap_bset;
+	xid_t vx_id;
+	struct vx_info *vx_info;
+	struct ip_info *ip_info;
+
 /* Thread group tracking */
    	u32 parent_exec_id;
    	u32 self_exec_id;
@@ -562,7 +570,7 @@ extern void set_special_pids(pid_t sessi
 extern void __set_special_pids(pid_t session, pid_t pgrp);
 
 /* per-UID process charging. */
-extern struct user_struct * alloc_uid(uid_t);
+extern struct user_struct * alloc_uid(xid_t, uid_t);
 extern void free_uid(struct user_struct *);
 extern void switch_uid(struct user_struct *);
 
diff -NurpP --minimal linux-2.6.0/include/linux/types.h linux-2.6.0-vs0.04/include/linux/types.h
--- linux-2.6.0/include/linux/types.h	Thu Dec 18 03:59:30 2003
+++ linux-2.6.0-vs0.04/include/linux/types.h	Sun Dec 28 03:00:23 2003
@@ -37,6 +37,7 @@ typedef __kernel_uid32_t	uid_t;
 typedef __kernel_gid32_t	gid_t;
 typedef __kernel_uid16_t        uid16_t;
 typedef __kernel_gid16_t        gid16_t;
+typedef unsigned int		xid_t;
 
 #ifdef CONFIG_UID16
 /* This is defined by include/asm-{arch}/posix_types.h */
diff -NurpP --minimal linux-2.6.0/include/linux/vcontext.h linux-2.6.0-vs0.04/include/linux/vcontext.h
--- linux-2.6.0/include/linux/vcontext.h	Thu Jan  1 01:00:00 1970
+++ linux-2.6.0-vs0.04/include/linux/vcontext.h	Sun Dec 28 01:50:15 2003
@@ -0,0 +1,127 @@
+#ifndef _VX_CONTEXT_H
+#define _VX_CONTEXT_H
+
+
+#define VX_INFO_LOCK		1	/* Can't request a new vx_id */
+#define VX_INFO_SCHED		2	/* All process in the vx_id */
+					/* Contribute to the schedular */
+#define VX_INFO_NPROC		4	/* Limit number of processes in a context */
+#define VX_INFO_PRIVATE		8	/* Noone can join this security context */
+#define VX_INFO_INIT		16	/* This process wants to become the */
+					/* logical process 1 of the security */
+					/* context */
+#define VX_INFO_HIDEINFO	32	/* Hide some information in /proc */
+#define VX_INFO_ULIMIT		64	/* Use ulimit of the current process */
+					/* to become the global limits */
+					/* of the context */
+	
+#define MAX_S_CONTEXT	65535	/* Arbitrary limit */
+#define MIN_D_CONTEXT	49152	/* dynamic contexts start here */
+#define VX_DYNAMIC_ID	(-1UL)	/* id for dynamic context */
+
+#define NB_S_CONTEXT	16
+
+#define NB_IPV4ROOT	16
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/utsname.h>
+#include <asm/resource.h>
+#include <asm/atomic.h>
+
+
+struct _vx_virt {
+	int nr_threads;
+	int nr_running;
+	int max_threads;
+	unsigned long total_forks;
+
+	unsigned int bias_cswtch;
+	long bias_jiffies;
+	long bias_idle;
+
+	struct new_utsname utsname;
+};
+
+struct _vx_limit {
+	atomic_t ticks;
+
+	unsigned long rlim[RLIM_NLIMITS];	/* Per context limit */
+	atomic_t res[RLIM_NLIMITS];		/* Current value */
+};
+
+struct _vx_sched {
+	spinlock_t tokens_lock; /* lock for this structure */
+	
+	int tokens;		/* number of CPU tokens in this context */
+	int tokens_fr;	/* Fill rate: add X tokens... */
+	int tokens_div;	/* Divisor:   per Y jiffies   */
+	int tokens_max;	/* Limit:     no more than N tokens */
+	uint32_t tokens_jfy;	/* add an integral multiple of Y to this */
+};	
+
+
+struct vx_info {
+	struct list_head vx_list;		/* linked list of contexts */
+	xid_t vx_id;				/* context id */
+	atomic_t vx_refcount;			/* refcount */
+	struct vx_info *vx_parent;		/* parent context */
+
+	struct proc_dir_entry *vx_procent;	/* proc entry */
+	unsigned int vx_flags;			/* VX_INFO_xxx */
+	pid_t vx_initpid;			/* PID of fake init process */
+
+	struct _vx_virt virt;			/* virtual/bias stuff */
+	struct _vx_limit limit;			/* vserver limits */
+	struct _vx_sched sched;			/* vserver scheduler */
+};
+
+
+extern spinlock_t vxlist_lock;
+extern struct list_head vx_infos;
+
+
+#define	VX_ADMIN	0x0001
+#define	VX_WATCH	0x0002
+
+#define	VX_IDENT	0x0010
+#define	VX_EQUIV	0x0020
+#define	VX_PARENT	0x0040
+#define	VX_CHILD	0x0080
+
+#define	VX_ARG_MASK	0x00F0
+
+#define	VX_DYNAMIC	0x0100
+#define	VX_STATIC	0x0200
+
+#define	VX_ATR_MASK	0x0F00
+
+
+
+#include <asm/current.h>
+
+
+
+struct ip_info {
+	struct list_head ip_list;		/* linked list of ipinfos */
+	atomic_t ip_refcount;
+	int nbipv4;
+	__u32 ipv4[NB_IPV4ROOT];/* Process can only bind to these IPs */
+				/* The first one is used to connect */
+				/* and for bind any service */
+				/* The other must be used explicity when */
+				/* binding */
+	__u32 mask[NB_IPV4ROOT];/* Netmask for each ipv4 */
+				/* Used to select the proper source address */
+				/* for sockets */
+	__u32 v4_bcast;	/* Broadcast address used to receive UDP packets */
+};
+
+
+extern spinlock_t iplist_lock;
+extern struct list_head ip_infos;
+
+int vc_new_s_context(uint32_t, void *);
+int vc_set_ipv4root(uint32_t, void *);
+
+#endif
diff -NurpP --minimal linux-2.6.0/include/linux/vinline.h linux-2.6.0-vs0.04/include/linux/vinline.h
--- linux-2.6.0/include/linux/vinline.h	Thu Jan  1 01:00:00 1970
+++ linux-2.6.0-vs0.04/include/linux/vinline.h	Sun Dec 28 01:51:34 2003
@@ -0,0 +1,173 @@
+#ifndef _VX_INLINE_H
+#define _VX_INLINE_H
+
+
+// #define VX_DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#if defined(VX_DEBUG)
+#define vxdprintk(x...) printk("vxd: " x)
+#else
+#define vxdprintk(x...)
+#endif
+
+
+void free_vx_info(struct vx_info *);
+
+extern int proc_pid_vinfo(struct task_struct *, char *);
+
+
+#define get_vx_info(i)	__get_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ struct vx_info *__get_vx_info(struct vx_info *vxi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!vxi)
+		return NULL;
+	vxdprintk("get_vx_info(%p[#%d.%d])\t%s:%d\n", vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount),
+		_file, _line);
+	atomic_inc(&vxi->vx_refcount);
+	return vxi;
+}
+
+#define put_vx_info(i)	__put_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ void __put_vx_info(struct vx_info *vxi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!vxi)
+		return;
+	vxdprintk("put_vx_info(%p[#%d.%d])\t%s:%d\n", vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount),
+		_file, _line);
+	if (atomic_dec_and_lock(&vxi->vx_refcount, &vxlist_lock)) {
+		list_del(&vxi->vx_list);
+		spin_unlock(&vxlist_lock);
+		free_vx_info(vxi);
+	}
+}
+
+#define task_get_vx_info(i)	__task_get_vx_info(i,__FILE__,__LINE__)
+
+static __inline__ struct vx_info *__task_get_vx_info(struct task_struct *p,
+	const char *_file, int _line)
+{
+	struct vx_info *vxi;
+	
+	task_lock(p);
+	vxi = __get_vx_info(p->vx_info, _file, _line);
+	task_unlock(p);
+	return vxi;
+}
+
+
+#define vx_verify_info(p,i)	\
+	__vx_verify_info((p)->vx_info,i,__FILE__,__LINE__)
+
+static __inline__ void __vx_verify_info(
+	struct vx_info *vxa, struct vx_info *vxb,
+	const char *_file, int _line)
+{
+	if (vxa == vxb)
+		return;
+	printk(KERN_ERR "vx bad assumption (%p==%p) at %s:%d\n",
+		vxa, vxb, _file, _line);
+}
+
+
+#define vx_task_id(t)   ((t)->vx_id)
+
+#define vx_current_id() vx_task_id(current)
+
+#define vx_check(c,m)	__vx_check(vx_current_id(),c,m)
+
+/*
+ * check current context for ADMIN/WATCH and
+ * optionally agains supplied argument
+ */
+static __inline__ int __vx_check(xid_t cid, xid_t id, unsigned int mode)
+{
+	if (mode & VX_ARG_MASK) {
+		if ((mode & VX_IDENT) &&
+			(id == cid))
+			return 1;
+	}
+	if (mode & VX_ATR_MASK) {
+		if ((mode & VX_DYNAMIC) &&
+			(id >= MIN_D_CONTEXT) &&
+			(id <= MAX_S_CONTEXT))
+			return 1;
+		if ((mode & VX_STATIC) &&
+			(id > 1) && (id < MIN_D_CONTEXT))
+			return 1;
+	}
+	return (((mode & VX_ADMIN) && (cid == 0)) ||
+		((mode & VX_WATCH) && (cid == 1)));
+}
+
+
+
+void free_ip_info(struct ip_info *);
+
+#define get_ip_info(i)	__get_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ struct ip_info *__get_ip_info(struct ip_info *ipi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!ipi)
+		return NULL;
+	vxdprintk("get_ip_info(%p[%d])\t%s:%d\n", ipi,
+		atomic_read(&ipi->ip_refcount), _file, _line);
+	atomic_inc(&ipi->ip_refcount);
+	return ipi;
+}
+
+#define put_ip_info(i)	__put_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ void __put_ip_info(struct ip_info *ipi, const char *_file, int _line)
+{
+	/* for now we allow vxi to be null */
+	if (!ipi)
+		return;
+	vxdprintk("put_ip_info(%p[%d])\t%s:%d\n", ipi,
+		atomic_read(&ipi->ip_refcount), _file, _line);
+	if (atomic_dec_and_lock(&ipi->ip_refcount, &iplist_lock)) {
+		list_del(&ipi->ip_list);
+		spin_unlock(&iplist_lock);
+		free_ip_info(ipi);
+	}
+}
+
+#define task_get_ip_info(i)	__task_get_ip_info(i,__FILE__,__LINE__)
+
+static __inline__ struct ip_info *__task_get_ip_info(struct task_struct *p,
+	const char *_file, int _line)
+{
+	struct ip_info *ipi;
+	
+	task_lock(p);
+	ipi = __get_ip_info(p->ip_info, _file, _line);
+	task_unlock(p);
+	return ipi;
+}
+
+
+#define ip_verify_info(p,i)	\
+	__ip_verify_info((p)->ip_info,i,__FILE__,__LINE__)
+
+static __inline__ void __ip_verify_info(
+	struct ip_info *ipa, struct ip_info *ipb,
+	const char *_file, int _line)
+{
+	if (ipa == ipb)
+		return;
+	printk(KERN_ERR "ip bad assumption (%p==%p) at %s:%d\n",
+		ipa, ipb, _file, _line);
+}
+
+
+
+#endif
diff -NurpP --minimal linux-2.6.0/include/linux/vswitch.h linux-2.6.0-vs0.04/include/linux/vswitch.h
--- linux-2.6.0/include/linux/vswitch.h	Thu Jan  1 01:00:00 1970
+++ linux-2.6.0-vs0.04/include/linux/vswitch.h	Sun Dec 28 01:53:09 2003
@@ -0,0 +1,140 @@
+#ifndef _LINUX_VIRTUAL_H
+#define _LINUX_VIRTUAL_H
+
+#include <linux/types.h>
+#include <linux/vcontext.h>
+
+#define VC_CATEGORY(c)		(((c) >> 24) & 0x3F)
+#define VC_COMMAND(c)		(((c) >> 16) & 0xFF)
+#define VC_VERSION(c)		((c) & 0xFFF)
+
+#define VC_CMD(c,i,v)		((((VC_CAT_ ## c) & 0x3F) << 24) \
+				| (((i) & 0xFF) << 16) | ((v) & 0xFFF))
+
+/*
+
+  Syscall Matrix V2.3
+
+         |VERSION|CREATE |MODIFY |MIGRATE|CONTROL|EXPERIM| |SPECIAL|SPECIAL|
+         |STATS  |DESTROY|ALTER  |CHANGE |LIMIT  |TEST   | |       |       |
+         |INFO   |SETUP  |       |MOVE   |       |       | |       |       |
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  SYSTEM |VERSION|       |       |       |       |       | |DEVICES|       |
+  HOST   |     00|     01|     02|     03|     04|     05| |     06|     07|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  CPU    |       |       |       |       |       |       | |SCHED. |       |
+  PROCESS|     08|     09|     10|     11|     12|     13| |     14|     15|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  MEMORY |       |       |       |       |       |       | |SWAP   |       |
+         |     16|     17|     18|     19|     20|     21| |     22|     23|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  NETWORK|       |       |       |       |       |       | |SERIAL |       |
+         |     24|     25|     26|     27|     28|     29| |     30|     31|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  DISK   |       |       |       |       |       |       | |       |       |
+  VFS    |     32|     33|     34|     35|     36|     37| |     38|     39|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  OTHER  |       |       |       |       |       |       | |       |       |
+         |     40|     41|     42|     43|     44|     45| |     46|     47|
+  =======+=======+=======+=======+=======+=======+=======+ +=======+=======+
+  SPECIAL|       |       |       |       |       |       | |       |       |
+         |     48|     49|     50|     51|     52|     53| |     54|     55|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+  SPECIAL|       |       |       |       |RLIMIT |SYSCALL| |       |COMPAT |
+         |     56|     57|     58|     59|     60|TEST 61| |     62|     63|
+  -------+-------+-------+-------+-------+-------+-------+ +-------+-------+
+
+*/
+
+#define VC_CAT_VERSION		0
+	
+#define VC_CAT_PROCTRL		12
+
+#define VC_CAT_RLIMIT		60
+
+#define VC_CAT_SYSTEST		61
+#define VC_CAT_COMPAT		63
+	
+/*  interface version */
+
+#define VCI_VERSION		0x00010004
+
+
+
+/*  query version */
+
+#define VCMD_get_version	VC_CMD(VERSION, 0, 0)
+
+
+/*  compatibiliy vserver commands */
+
+#define VCMD_new_s_context	VC_CMD(COMPAT, 1, 1)
+#define VCMD_set_ipv4root	VC_CMD(COMPAT, 2, 3)
+
+/*  compatibiliy vserver arguments */
+
+struct  vcmd_new_s_context_v1 {
+	uint32_t remove_cap;
+	uint32_t flags;
+};
+
+struct  vcmd_set_ipv4root_v3 {
+	/* number of pairs in id */
+	uint32_t broadcast;
+	struct {
+		uint32_t ip;
+		uint32_t mask;
+	} ip_mask_pair[NB_IPV4ROOT];
+};
+
+/*  context signalling */
+
+#define VCMD_ctx_kill		VC_CMD(PROCTRL, 1, 0)
+
+struct  vcmd_ctx_kill_v0 {
+	int32_t pid;
+	int32_t sig;
+};
+
+/*  rlimit vserver commands */
+
+#define VCMD_get_rlimit		VC_CMD(RLIMIT, 1, 0)
+#define VCMD_set_rlimit		VC_CMD(RLIMIT, 2, 0)
+#define VCMD_get_rlimit_mask	VC_CMD(RLIMIT, 3, 0)
+
+struct  vcmd_ctx_rlimit_v0 {
+	uint32_t id;
+	uint64_t minimum;
+	uint64_t softlimit;
+	uint64_t maximum;
+};
+
+struct  vcmd_ctx_rlimit_mask_v0 {
+	uint32_t minimum;
+	uint32_t softlimit;
+	uint32_t maximum;
+};
+
+#define CRLIM_INFINITY		(~0ULL)
+#define CRLIM_KEEP		(~1ULL)
+
+
+/* Structure for setting a context's TBF scheduling priorities */
+
+#define VCMD_set_sched		VC_CMD(SYSTEST, 1, 1)
+
+
+/* Options - these ones enable or disable the CTX_SCHED flag */
+#define TBF_SCHED_ENABLE       0x0001
+#define TBF_SCHED_DISABLE      0x0002
+
+struct  vcmd_set_sched_v1 {
+	uint32_t options;
+
+	int32_t fill_rate;
+	int32_t period;
+	int32_t fill_level;
+	int32_t bucket_size;
+};
+
+#endif /* _LINUX_VIRTUAL_H */
diff -NurpP --minimal linux-2.6.0/include/net/route.h linux-2.6.0-vs0.04/include/net/route.h
--- linux-2.6.0/include/net/route.h	Thu Dec 18 03:57:58 2003
+++ linux-2.6.0-vs0.04/include/net/route.h	Sun Jan  4 20:10:04 2004
@@ -33,6 +33,7 @@
 #include <linux/route.h>
 #include <linux/ip.h>
 #include <linux/cache.h>
+#include <linux/vinline.h>
 
 #ifndef __KERNEL__
 #warning This file is not supposed to be used outside of kernel.
@@ -160,6 +161,45 @@ static inline int ip_route_connect(struc
 					 .dport = dport } } };
 
 	int err;
+	struct ip_info *ip_info = current->ip_info;
+	if (ip_info) {
+		__u32 ipv4root = ip_info->ipv4[0];
+		if (ipv4root) {
+			int n = ip_info->nbipv4;
+			if (src == 0) {
+				if (n > 1) {
+					u32 foundsrc;
+					int i;
+					err = __ip_route_output_key(rp, &fl);
+					if (err)
+						return err;
+					foundsrc = (*rp)->rt_src;
+					ip_rt_put(*rp);
+					for (i=0; i<n; i++){
+						u32 mask = ip_info->mask[i];
+						u32 ipv4 = ip_info->ipv4[i];
+						u32 netipv4 = ipv4 & mask;
+						if ((foundsrc & mask) == netipv4) {
+							src = ipv4;
+							break;
+						}
+					}
+				}
+				if (src == 0)
+					src = dst == 0x0100007f
+						? 0x0100007f: ipv4root;
+			} else {
+				int i;
+				for (i=0; i<n; i++) {
+					if (ip_info->ipv4[i] == src) break;
+				}
+				if (i == n)
+					return -EPERM;
+			}
+			if (dst == 0x0100007f && !vx_check(0, VX_ADMIN))
+				dst = ipv4root;
+		}
+	}
 	if (!dst || !src) {
 		err = __ip_route_output_key(rp, &fl);
 		if (err)
diff -NurpP --minimal linux-2.6.0/include/net/sock.h linux-2.6.0-vs0.04/include/net/sock.h
--- linux-2.6.0/include/net/sock.h	Thu Dec 18 03:59:15 2003
+++ linux-2.6.0-vs0.04/include/net/sock.h	Sun Jan  4 20:25:19 2004
@@ -50,6 +50,7 @@
 #include <linux/security.h>
 
 #include <linux/filter.h>
+#include <linux/vinline.h>
 
 #include <asm/atomic.h>
 #include <net/dst.h>
@@ -109,6 +110,8 @@ struct sock_common {
 	struct hlist_node	skc_node;
 	struct hlist_node	skc_bind_node;
 	atomic_t		skc_refcnt;
+	xid_t			skc_xid;
+	struct ip_info		*skc_ip_info;
 };
 
 /**
@@ -186,6 +189,8 @@ struct sock {
 #define sk_node			__sk_common.skc_node
 #define sk_bind_node		__sk_common.skc_bind_node
 #define sk_refcnt		__sk_common.skc_refcnt
+#define sk_xid			__sk_common.skc_xid
+#define sk_ip_info		__sk_common.skc_ip_info
 	volatile unsigned char	sk_zapped;
 	unsigned char		sk_shutdown;
 	unsigned char		sk_use_write_queue;
diff -NurpP --minimal linux-2.6.0/include/net/tcp.h linux-2.6.0-vs0.04/include/net/tcp.h
--- linux-2.6.0/include/net/tcp.h	Thu Dec 18 03:58:15 2003
+++ linux-2.6.0-vs0.04/include/net/tcp.h	Sun Jan  4 20:10:04 2004
@@ -195,6 +195,8 @@ struct tcp_tw_bucket {
 #define tw_node			__tw_common.skc_node
 #define tw_bind_node		__tw_common.skc_bind_node
 #define tw_refcnt		__tw_common.skc_refcnt
+#define tw_xid			__tw_common.skc_xid
+#define tw_ip_info		__tw_common.skc_ip_info
 	volatile unsigned char	tw_substate;
 	unsigned char		tw_rcv_wscale;
 	__u16			tw_sport;
diff -NurpP --minimal linux-2.6.0/kernel/Makefile linux-2.6.0-vs0.04/kernel/Makefile
--- linux-2.6.0/kernel/Makefile	Thu Dec 18 03:58:18 2003
+++ linux-2.6.0-vs0.04/kernel/Makefile	Sun Dec 28 03:00:23 2003
@@ -3,9 +3,9 @@
 #
 
 obj-y     = sched.o fork.o exec_domain.o panic.o printk.o profile.o \
-	    exit.o itimer.o time.o softirq.o resource.o \
+	    exit.o itimer.o time.o softirq.o resource.o vswitch.o \
 	    sysctl.o capability.o ptrace.o timer.o user.o \
-	    signal.o sys.o kmod.o workqueue.o pid.o \
+	    signal.o sys.o kmod.o workqueue.o pid.o vcontext.o \
 	    rcupdate.o intermodule.o extable.o params.o posix-timers.o
 
 obj-$(CONFIG_FUTEX) += futex.o
diff -NurpP --minimal linux-2.6.0/kernel/fork.c linux-2.6.0-vs0.04/kernel/fork.c
--- linux-2.6.0/kernel/fork.c	Thu Dec 18 03:58:08 2003
+++ linux-2.6.0-vs0.04/kernel/fork.c	Sun Dec 28 03:28:38 2003
@@ -30,6 +30,7 @@
 #include <linux/futex.h>
 #include <linux/ptrace.h>
 #include <linux/mount.h>
+#include <linux/vinline.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -76,6 +77,7 @@ static kmem_cache_t *task_struct_cachep;
 static void free_task(struct task_struct *tsk)
 {
 	free_thread_info(tsk->thread_info);
+	put_vx_info(tsk->vx_info);
 	free_task_struct(tsk);
 }
 
@@ -859,6 +861,16 @@ struct task_struct *copy_process(unsigne
 			goto bad_fork_free;
 	}
 
+	if (current->vx_info)
+		p->vx_info = get_vx_info(current->vx_info);
+	else
+		p->vx_info = NULL;
+	p->vx_id = vx_current_id();
+	if (current->ip_info)
+		p->ip_info = get_ip_info(current->ip_info);
+	else
+		p->ip_info = NULL;
+
 	atomic_inc(&p->user->__count);
 	atomic_inc(&p->user->processes);
 
@@ -1074,6 +1086,10 @@ struct task_struct *copy_process(unsigne
 		link_pid(p, p->pids + PIDTYPE_TGID, &p->group_leader->pids[PIDTYPE_TGID].pid);
 
 	nr_threads++;
+	if (p->vx_info) {
+		p->vx_info->virt.nr_threads++;
+		atomic_inc(&p->vx_info->limit.res[RLIMIT_NPROC]);
+	}
 	write_unlock_irq(&tasklist_lock);
 	retval = 0;
 
diff -NurpP --minimal linux-2.6.0/kernel/sys.c linux-2.6.0-vs0.04/kernel/sys.c
--- linux-2.6.0/kernel/sys.c	Thu Dec 18 03:58:08 2003
+++ linux-2.6.0-vs0.04/kernel/sys.c	Mon Dec 29 21:22:15 2003
@@ -23,6 +23,7 @@
 #include <linux/security.h>
 #include <linux/dcookies.h>
 #include <linux/suspend.h>
+#include <linux/vinline.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -314,7 +315,7 @@ asmlinkage long sys_setpriority(int whic
 			if (!who)
 				user = current->user;
 			else
-				user = find_user(who);
+				user = find_user(vx_current_id(), who);
 
 			if (!user)
 				goto out_unlock;
@@ -373,7 +374,7 @@ asmlinkage long sys_getpriority(int whic
 			if (!who)
 				user = current->user;
 			else
-				user = find_user(who);
+				user = find_user(vx_current_id(), who);
 
 			if (!user)
 				goto out_unlock;
@@ -614,7 +615,7 @@ static int set_user(uid_t new_ruid, int 
 {
 	struct user_struct *new_user;
 
-	new_user = alloc_uid(new_ruid);
+	new_user = alloc_uid(vx_current_id(), new_ruid);
 	if (!new_user)
 		return -EAGAIN;
 
diff -NurpP --minimal linux-2.6.0/kernel/user.c linux-2.6.0-vs0.04/kernel/user.c
--- linux-2.6.0/kernel/user.c	Thu Dec 18 03:58:40 2003
+++ linux-2.6.0-vs0.04/kernel/user.c	Sun Dec 28 03:00:23 2003
@@ -20,8 +20,8 @@
 #define UIDHASH_BITS		8
 #define UIDHASH_SZ		(1 << UIDHASH_BITS)
 #define UIDHASH_MASK		(UIDHASH_SZ - 1)
-#define __uidhashfn(uid)	(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)
-#define uidhashentry(uid)	(uidhash_table + __uidhashfn((uid)))
+#define __uidhashfn(xid,uid)	((((uid) >> UIDHASH_BITS) + ((uid)^(xid))) & UIDHASH_MASK)
+#define uidhashentry(xid,uid)	(uidhash_table + __uidhashfn((xid),(uid)))
 
 static kmem_cache_t *uid_cachep;
 static struct list_head uidhash_table[UIDHASH_SZ];
@@ -46,7 +46,7 @@ static inline void uid_hash_remove(struc
 	list_del(&up->uidhash_list);
 }
 
-static inline struct user_struct *uid_hash_find(uid_t uid, struct list_head *hashent)
+static inline struct user_struct *uid_hash_find(xid_t xid, uid_t uid, struct list_head *hashent)
 {
 	struct list_head *up;
 
@@ -55,7 +55,7 @@ static inline struct user_struct *uid_ha
 
 		user = list_entry(up, struct user_struct, uidhash_list);
 
-		if(user->uid == uid) {
+		if(user->uid == uid && user->vx_id == xid) {
 			atomic_inc(&user->__count);
 			return user;
 		}
@@ -64,9 +64,9 @@ static inline struct user_struct *uid_ha
 	return NULL;
 }
 
-struct user_struct *find_user(uid_t uid)
+struct user_struct *find_user(xid_t xid, uid_t uid)
 {
-	return uid_hash_find(uid, uidhashentry(uid));
+	return uid_hash_find(xid, uid, uidhashentry(xid, uid));
 }
 
 void free_uid(struct user_struct *up)
@@ -78,13 +78,13 @@ void free_uid(struct user_struct *up)
 	}
 }
 
-struct user_struct * alloc_uid(uid_t uid)
+struct user_struct * alloc_uid(xid_t xid, uid_t uid)
 {
-	struct list_head *hashent = uidhashentry(uid);
+	struct list_head *hashent = uidhashentry(xid, uid);
 	struct user_struct *up;
 
 	spin_lock(&uidhash_lock);
-	up = uid_hash_find(uid, hashent);
+	up = uid_hash_find(xid, uid, hashent);
 	spin_unlock(&uidhash_lock);
 
 	if (!up) {
@@ -94,6 +94,7 @@ struct user_struct * alloc_uid(uid_t uid
 		if (!new)
 			return NULL;
 		new->uid = uid;
+		new->vx_id = xid;
 		atomic_set(&new->__count, 1);
 		atomic_set(&new->processes, 0);
 		atomic_set(&new->files, 0);
@@ -103,7 +104,7 @@ struct user_struct * alloc_uid(uid_t uid
 		 * on adding the same user already..
 		 */
 		spin_lock(&uidhash_lock);
-		up = uid_hash_find(uid, hashent);
+		up = uid_hash_find(xid, uid, hashent);
 		if (up) {
 			kmem_cache_free(uid_cachep, new);
 		} else {
@@ -148,7 +149,7 @@ static int __init uid_cache_init(void)
 
 	/* Insert the root user immediately (init already runs as root) */
 	spin_lock(&uidhash_lock);
-	uid_hash_insert(&root_user, uidhashentry(0));
+	uid_hash_insert(&root_user, uidhashentry(0,0));
 	spin_unlock(&uidhash_lock);
 
 	return 0;
diff -NurpP --minimal linux-2.6.0/kernel/vcontext.c linux-2.6.0-vs0.04/kernel/vcontext.c
--- linux-2.6.0/kernel/vcontext.c	Thu Jan  1 01:00:00 1970
+++ linux-2.6.0-vs0.04/kernel/vcontext.c	Sun Dec 28 03:37:58 2003
@@ -0,0 +1,548 @@
+/*
+ *  linux/kernel/vcontext.c
+ *
+ *  Virtual Context Support
+ *
+ *  Copyright (C) 2003  Herbert Pötzl
+ *
+ *  V0.01  context helper
+ *  V0.02  vx_ctx_kill syscall command
+ *  V0.03  replaced context_info calls
+ *  V0.04  redesign of struct (de)alloc
+ *  V0.05  added O(1) scheduler stuff
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <linux/utsname.h>
+#include <linux/slab.h>
+#include <linux/vcontext.h>
+#include <linux/vswitch.h>
+#include <linux/vinline.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+
+int vc_ctx_kill(uint32_t id, void *data)
+{
+	int retval, count=0;
+	struct vcmd_ctx_kill_v0 vc_data;
+	struct siginfo info;
+	struct task_struct *p;
+	pid_t initpid = 0;
+
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	if (!vx_check(0, VX_ADMIN))
+		return -EPERM;
+	
+	info.si_signo = vc_data.sig;
+	info.si_errno = 0;
+	info.si_code = SI_USER;
+	info.si_pid = current->pid;
+	info.si_uid = current->uid;
+
+	retval = -ESRCH;
+	read_lock(&tasklist_lock);
+	switch (vc_data.pid) {
+	case -1:
+	case  0:
+		for_each_process(p) {
+			if (!initpid && vx_task_id(p) == id && p->vx_info)
+				initpid = p->vx_info->vx_initpid;
+			if (vx_task_id(p) == id  && p->pid > 1
+				&& (!vc_data.pid || initpid != p->pid)
+				&& thread_group_leader(p)) {
+				int err = send_sig_info(vc_data.sig, &info, p);
+
+				++count;
+				if (err != -EPERM)
+					retval = err;
+			}
+		}
+		break;
+		
+	default:
+	p = find_task_by_pid(vc_data.pid);
+		if (p) {
+			if (!thread_group_leader(p)) {
+				struct task_struct *tg;
+			
+				tg = find_task_by_pid(p->tgid);
+				if (tg)
+					p = tg;
+			}
+			if ((id == -1) || (vx_task_id(p) == id))
+				retval = send_sig_info(vc_data.sig, &info, p);
+		}
+		break;
+	}
+	read_unlock(&tasklist_lock);
+	return retval;
+}
+
+int vc_get_rlimit(uint32_t id, void *data)
+{
+	return -ENOSYS;
+}
+
+int vc_set_rlimit(uint32_t id, void *data)
+{
+	return -ENOSYS;
+}
+
+int vc_get_rlimit_mask(uint32_t id, void *data)
+{
+	return -ENOSYS;
+}
+
+
+static struct vx_info *find_vx_info(int);
+
+/*
+ * vc_set_sched - switched syscall to alter a context's sched. prio
+ *
+ * Negative values indicate to leave the value as is
+ */
+int vc_set_sched(uint32_t ctx, void *data)
+{
+	struct vcmd_set_sched_v1 vc_data;
+	struct vx_info *s;
+
+	if (!vx_check(0, VX_ADMIN))
+		return -ENOSYS;
+		
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+	
+	s = find_vx_info(ctx);
+	if (!s)
+		return -EINVAL;
+
+	spin_lock(&s->sched.tokens_lock);
+
+	if (vc_data.fill_rate > -1)
+		s->sched.tokens_fr = vc_data.fill_rate;
+	if (vc_data.period > -1)
+		s->sched.tokens_div = vc_data.period;
+	if (vc_data.fill_level > -1)
+		s->sched.tokens = vc_data.fill_level;
+	if (vc_data.bucket_size > -1)
+		s->sched.tokens_max = vc_data.bucket_size;
+
+	/* Sanity check the resultant values */
+	if (s->sched.tokens_fr == 0)
+		s->sched.tokens_fr = 1;
+	if (s->sched.tokens_div == 0)
+		s->sched.tokens_div = HZ;   /* arbitrary large number */
+	if (s->sched.tokens_max == 0)
+		s->sched.tokens_max = 1;
+	if (s->sched.tokens > s->sched.tokens_max)
+		s->sched.tokens = s->sched.tokens_max;
+
+	if (vc_data.options & TBF_SCHED_ENABLE)
+		s->vx_flags |= VX_INFO_SCHED;
+	if (vc_data.options & TBF_SCHED_DISABLE)
+		s->vx_flags &= ~VX_INFO_SCHED;
+
+	spin_unlock(&s->sched.tokens_lock);
+	put_vx_info(s);
+
+	return 0;
+}
+
+
+
+/*  system functions */
+
+
+LIST_HEAD(vx_infos);
+
+spinlock_t vxlist_lock
+	__cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ *	struct vx_info allocation and deallocation
+ */
+
+static struct vx_info *alloc_vx_info(int id)
+{
+	struct vx_info *new = NULL;
+	
+	vxdprintk("alloc_vx_info(%d)\n", id);
+	/* would this benefit from a slab cache? */
+	new = kmalloc(sizeof(struct vx_info), GFP_KERNEL);
+	if (!new)
+		return 0;
+
+	memset (new, 0, sizeof(struct vx_info));
+	new->vx_id = id;
+	/* rest of init goes here */
+	
+	/* scheduling; hard code starting values as constants */
+	new->sched.tokens_fr = 1;
+	new->sched.tokens_div = 4;
+	new->sched.tokens     = HZ * 5;
+	new->sched.tokens_max = HZ * 10;
+	new->sched.tokens_jfy = jiffies;
+	new->sched.tokens_lock = SPIN_LOCK_UNLOCKED;
+	
+	new->virt.nr_threads = 1;
+	// new->virt.bias_cswtch = kstat.context_swtch;
+	new->virt.bias_jiffies = jiffies;
+	/* new->virt.bias_idle = init_tasks[0]->times.tms_utime +
+		init_tasks[0]->times.tms_stime; */
+	down_read(&uts_sem);
+	new->virt.utsname = system_utsname;
+	up_read(&uts_sem);
+	
+	vxdprintk("alloc_vx_info(%d) = %p\n", id, new);
+	return new;
+}
+
+extern int vx_proc_destroy(struct vx_info *);
+
+void free_vx_info(struct vx_info *vxi)
+{
+	vxdprintk("free_vx_info(%p)\n", vxi);
+	vx_proc_destroy(vxi);
+	kfree(vxi);
+}
+
+
+/*
+ *	struct vx_info search by id
+ *	assumes vxlist_lock is held
+ */
+
+static __inline__ struct vx_info *__find_vx_info(int id)
+{
+	struct vx_info *vxi;
+
+	list_for_each_entry(vxi, &vx_infos, vx_list)
+		if (vxi->vx_id == id)
+			return vxi;
+	return 0;
+}
+
+
+/*
+ *	struct vx_info ref stuff
+ */
+
+static struct vx_info *find_vx_info(int id)
+{
+	struct vx_info *vxi;
+	
+	spin_lock(&vxlist_lock);
+	if ((vxi = __find_vx_info(id)))
+		get_vx_info(vxi);
+	spin_unlock(&vxlist_lock);
+	return vxi;
+}
+
+
+/*
+ *	struct vx_info search by id
+ *	assumes vxlist_lock is held
+ */
+
+static __inline__ xid_t __vx_dynamic_id(void)
+{
+	static xid_t seq = MAX_S_CONTEXT;
+	xid_t barrier = seq;
+	
+	do {
+		if (++seq > MAX_S_CONTEXT)
+			seq = MIN_D_CONTEXT;
+		if (!__find_vx_info(seq))
+			return seq;
+	} while (barrier != seq);
+	return 0;
+}
+
+
+extern int vx_proc_create(struct vx_info *);
+
+static struct vx_info *find_or_create_vx_info(int id)
+{
+	struct vx_info *new, *vxi = NULL;
+	
+	vxdprintk("find_or_create_vx_info(%d)\n", id);
+	if (!(new = alloc_vx_info(id)))
+		return 0;
+
+	spin_lock(&vxlist_lock);
+
+	/* dynamic context requested */
+	if (id == VX_DYNAMIC_ID) {
+		id = __vx_dynamic_id();
+		if (!id) {
+			printk(KERN_ERR "no dynamic context available.\n");
+			goto out_unlock;
+		}
+		new->vx_id = id;
+	}
+	/* existing context requested */
+	else if ((vxi = __find_vx_info(id))) {
+		vxdprintk("find_or_create_vx_info(%d) = %p (found)\n", id, vxi);
+		get_vx_info(vxi);
+		goto out_unlock;
+	}
+
+	/* new context requested */
+	vxdprintk("find_or_create_vx_info(%d) = %p (new)\n", id, vxi);
+	atomic_set(&new->vx_refcount, 1);
+	list_add(&new->vx_list, &vx_infos);
+	vx_proc_create(new);
+	vxi = new, new = NULL;
+
+out_unlock:
+	spin_unlock(&vxlist_lock);
+	if (new)
+		free_vx_info(new);
+	return vxi;
+}
+
+
+
+static int vx_migrate_user(struct task_struct *p, struct vx_info *vxi)
+{
+	struct user_struct *new_user, *old_user;
+	
+	if (!p || !vxi)
+		BUG();
+	new_user = alloc_uid(vxi->vx_id, p->uid);
+	if (!new_user)
+		return -ENOMEM;
+
+	old_user = p->user;
+	if (new_user != old_user) {
+		atomic_inc(&new_user->processes);
+		atomic_dec(&old_user->processes);
+		p->user = new_user;
+	}
+	free_uid(old_user);
+	return 0;
+}
+
+/*
+ *	migrate task to new context
+ *	gets vxi, puts old_vxi on change
+ */
+
+static int vx_migrate_task(struct task_struct *p, struct vx_info *vxi)
+{
+	struct vx_info *old_vxi;
+	int ret = 0;
+	
+	if (!p || !vxi)
+		BUG();
+
+	vxdprintk("vx_migrate_task(%p,%p[#%d.%d)\n", p, vxi,
+		vxi->vx_id, atomic_read(&vxi->vx_refcount));
+	spin_lock(&p->alloc_lock);
+	if ((old_vxi = p->vx_info) == vxi)
+		goto out;
+
+	if (!(ret = vx_migrate_user(p, vxi))) {
+		if (old_vxi)
+			old_vxi->virt.nr_threads--;
+		vxi->virt.nr_threads++;
+		p->vx_info = get_vx_info(vxi);
+		p->vx_id = vxi->vx_id;
+		if (old_vxi)
+			put_vx_info(old_vxi);
+	}
+out:
+	spin_unlock(&p->alloc_lock);
+	return ret;
+}
+
+
+
+
+static int vx_set_initpid(struct vx_info *vxi, int pid)
+{
+	int ret = 0;
+	if (vxi->vx_initpid)
+		ret = -EPERM;
+	else
+		vxi->vx_initpid = pid;
+	return ret;
+}
+
+int vc_new_s_context(uint32_t ctx, void *data)
+{
+	int ret = -EPERM;
+	struct vcmd_new_s_context_v1 vc_data;
+	struct vx_info *new_vxi;
+
+	if (copy_from_user(&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	/* legacy hack, will be removed soon */
+	if (ctx == -2) {
+		/* assign flags and initpid */
+		if (!current->vx_info)
+			return -EINVAL;
+		ret = 0;
+		if (vc_data.flags & VX_INFO_INIT)
+			ret = vx_set_initpid(current->vx_info, current->tgid);
+		if (ret == 0) {
+			/* We keep the same vx_id, but lower the capabilities */
+			current->cap_bset &= (~vc_data.remove_cap);
+			ret = vx_current_id();
+			current->vx_info->vx_flags |= vc_data.flags;
+		}
+		return ret;
+	}
+	
+	if (!vx_check(0, VX_ADMIN) ||
+		!capable(CAP_SYS_ADMIN) ||
+		(current->vx_info &&
+		(current->vx_info->vx_flags & VX_INFO_LOCK)))
+		return -EPERM;
+
+	if (((ctx > MAX_S_CONTEXT) && (ctx != VX_DYNAMIC_ID)) ||
+		(ctx == 0))
+		return -EINVAL;
+		
+	if ((ctx == VX_DYNAMIC_ID) || (ctx < MIN_D_CONTEXT))
+		new_vxi = find_or_create_vx_info(ctx);
+	else
+		new_vxi = find_vx_info(ctx);
+		
+	if (!new_vxi)
+		return -EINVAL;
+
+	ret = vx_migrate_task(current, new_vxi);
+	if (ret == 0) {
+		current->cap_bset &= (~vc_data.remove_cap);
+		new_vxi->vx_flags |= vc_data.flags;
+		if (vc_data.flags & VX_INFO_INIT)
+			vx_set_initpid(new_vxi, current->tgid);
+		ret = new_vxi->vx_id;
+	}
+	put_vx_info(new_vxi);
+	return ret;
+}
+
+
+
+LIST_HEAD(ip_infos);
+
+spinlock_t iplist_lock
+	__cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
+
+
+/*
+ *	struct ip_info allocation and deallocation
+ */
+
+static struct ip_info *alloc_ip_info(void)
+{
+	struct ip_info *new = NULL;
+	
+	vxdprintk("alloc_ip_info()\n");
+	/* would this benefit from a slab cache? */
+	new = kmalloc(sizeof(struct ip_info), GFP_KERNEL);
+	if (!new)
+		return 0;
+	
+	memset (new, 0, sizeof(struct ip_info));
+	/* rest of init goes here */
+	
+	
+	vxdprintk("alloc_ip_info() = %p\n", new);
+	return new;
+}
+
+// extern int ip_proc_destroy(struct ip_info *);
+
+void free_ip_info(struct ip_info *ipi)
+{
+	vxdprintk("free_ip_info(%p)\n", ipi);
+//	ip_proc_destroy(ipi);
+	kfree(ipi);
+}
+
+static struct ip_info *create_ip_info(void)
+{
+	struct ip_info *new;
+	
+	vxdprintk("create_ip_info()\n");
+	if (!(new = alloc_ip_info()))
+		return 0;
+
+	spin_lock(&iplist_lock);
+
+	/* new ip info */
+	atomic_set(&new->ip_refcount, 1);
+	list_add(&new->ip_list, &ip_infos);
+//	ip_proc_create(new);
+
+	spin_unlock(&iplist_lock);
+	return new;
+}
+
+
+
+/*  set ipv4 root (syscall) */
+
+int vc_set_ipv4root(uint32_t nbip, void *data)
+{
+	int i, err = -EPERM;
+	struct vcmd_set_ipv4root_v3 vc_data;
+	struct ip_info *new_ipi, *ipi = current->ip_info;
+
+	if (nbip < 0 || nbip > NB_IPV4ROOT)
+		return -EINVAL;
+	if (copy_from_user (&vc_data, data, sizeof(vc_data)))
+		return -EFAULT;
+
+	if (!ipi || ipi->ipv4[0] == 0 || capable(CAP_NET_ADMIN))
+		// We are allowed to change everything
+		err = 0;
+	else if (ipi) {
+		int found = 0;
+		
+		// We are allowed to select a subset of the currently
+		// installed IP numbers. No new one allowed
+		// We can't change the broadcast address though
+		for (i=0; i<nbip; i++) {
+			int j;
+			__u32 ipip = vc_data.ip_mask_pair[i].ip;
+			for (j=0; j<ipi->nbipv4; j++) {
+				if (ipip == ipi->ipv4[j]) {
+					found++;
+					break;
+				}
+			}
+		}
+		if ((found == nbip) &&
+			(vc_data.broadcast == ipi->v4_bcast))
+			err = 0;
+	}
+	if (err)
+		return err;
+
+	new_ipi = create_ip_info();
+	if (!new_ipi)
+		return -EINVAL;
+
+	new_ipi->nbipv4 = nbip;
+	for (i=0; i<nbip; i++) {
+		new_ipi->ipv4[i] = vc_data.ip_mask_pair[i].ip;
+		new_ipi->mask[i] = vc_data.ip_mask_pair[i].mask;
+	}
+	new_ipi->v4_bcast = vc_data.broadcast;
+	current->ip_info = new_ipi;
+	put_ip_info(ipi);
+	return 0;
+}
diff -NurpP --minimal linux-2.6.0/kernel/vswitch.c linux-2.6.0-vs0.04/kernel/vswitch.c
--- linux-2.6.0/kernel/vswitch.c	Thu Jan  1 01:00:00 1970
+++ linux-2.6.0-vs0.04/kernel/vswitch.c	Sun Dec 28 03:00:24 2003
@@ -0,0 +1,71 @@
+/*
+ *  linux/kernel/vswitch.c
+ *
+ *  Virtual Context Support
+ *
+ *  Copyright (C) 2003  Herbert Pötzl
+ *
+ *  V0.01  syscall switch
+ *  V0.02  added signal to context
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/errno.h>
+
+#include <linux/vswitch.h>
+
+
+static inline int
+vc_get_version(uint32_t id)
+{
+	return VCI_VERSION;
+}
+
+
+extern int vc_new_s_context(uint32_t, void *);
+extern int vc_set_ipv4root(uint32_t, void *);
+
+extern int vc_get_rlimit(uint32_t, void *);
+extern int vc_set_rlimit(uint32_t, void *);
+extern int vc_get_rlimit_mask(uint32_t, void *);
+
+extern int vc_ctx_kill(uint32_t, void *);
+
+
+asmlinkage int
+sys_vserver(uint32_t cmd, uint32_t id, void *data)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+	case VCMD_get_version:
+		ret = vc_get_version(id);
+		break;
+		
+	case VCMD_new_s_context:
+		ret = vc_new_s_context(id, data);
+		break;
+	case VCMD_set_ipv4root:
+		ret = vc_set_ipv4root(id, data);
+		break;
+
+	case VCMD_get_rlimit:
+		ret = vc_get_rlimit(id, data);
+		break;
+	case VCMD_set_rlimit:
+		ret = vc_set_rlimit(id, data);
+		break;
+	case VCMD_get_rlimit_mask:
+		ret = vc_get_rlimit_mask(id, data);
+		break;
+		
+	case VCMD_ctx_kill:
+		ret = vc_ctx_kill(id, data);
+		break;
+
+	}
+	return ret;
+}
+
diff -NurpP --minimal linux-2.6.0/net/ipv4/af_inet.c linux-2.6.0-vs0.04/net/ipv4/af_inet.c
--- linux-2.6.0/net/ipv4/af_inet.c	Thu Dec 18 03:58:15 2003
+++ linux-2.6.0-vs0.04/net/ipv4/af_inet.c	Sun Jan  4 20:10:04 2004
@@ -158,6 +158,10 @@ void inet_sock_destruct(struct sock *sk)
 
 	if (inet->opt)
 		kfree(inet->opt);
+	
+	/* reordering required? */
+	put_ip_info(sk->sk_ip_info);
+	sk->sk_ip_info = NULL;
 	dst_release(sk->sk_dst_cache);
 #ifdef INET_REFCNT_DEBUG
 	atomic_dec(&inet_sock_nr);
@@ -397,6 +401,9 @@ static int inet_create(struct socket *so
 	sk->sk_family	   = PF_INET;
 	sk->sk_protocol	   = protocol;
 	sk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;
+	
+	sk->sk_xid = vx_current_id();
+	sk->sk_ip_info = NULL;
 
 	inet->uc_ttl	= -1;
 	inet->mc_loop	= 1;
@@ -476,6 +483,10 @@ int inet_bind(struct socket *sock, struc
 	unsigned short snum;
 	int chk_addr_ret;
 	int err;
+	__u32 s_addr;	/* Address used for validation */
+	__u32 s_addr1;
+	__u32 s_addr2 = 0xffffffffl;	/* Optional address of the socket */
+	struct ip_info *ip_info;
 
 	/* If the socket has its own bind function then use it. (RAW) */
 	if (sk->sk_prot->bind) {
@@ -486,7 +497,37 @@ int inet_bind(struct socket *sock, struc
 	if (addr_len < sizeof(struct sockaddr_in))
 		goto out;
 
-	chk_addr_ret = inet_addr_type(addr->sin_addr.s_addr);
+	s_addr = s_addr1 = addr->sin_addr.s_addr;
+	ip_info = current->ip_info;
+	if (ip_info) {
+		__u32 v4_bcast = ip_info->v4_bcast;
+		__u32 ipv4root = ip_info->ipv4[0];
+		int nbipv4 = ip_info->nbipv4;
+		if (s_addr == 0) {
+			s_addr = ipv4root;
+			if (nbipv4 > 1)
+				s_addr1 = 0;
+			else {
+				s_addr1 = ipv4root;
+				ip_info = NULL;
+			}
+			s_addr2 = v4_bcast;
+		} else if (s_addr == 0x0100007f) {
+			s_addr = s_addr1 = ipv4root;
+			ip_info = NULL;
+		} else if (s_addr != v4_bcast
+			&& s_addr != ipv4root) {
+			int i;
+			for (i=0; i<nbipv4; i++) {
+				if (s_addr == ip_info->ipv4[i])
+					break;
+			}
+			if (i == nbipv4)
+				return -EADDRNOTAVAIL;
+			ip_info = NULL;
+		}
+	}
+	chk_addr_ret = inet_addr_type(s_addr);
 
 	/* Not specified by any standard per-se, however it breaks too
 	 * many applications when removed.  It is unfortunate since
@@ -498,7 +539,7 @@ int inet_bind(struct socket *sock, struc
 	err = -EADDRNOTAVAIL;
 	if (!sysctl_ip_nonlocal_bind &&
 	    !inet->freebind &&
-	    addr->sin_addr.s_addr != INADDR_ANY &&
+	    s_addr != INADDR_ANY &&
 	    chk_addr_ret != RTN_LOCAL &&
 	    chk_addr_ret != RTN_MULTICAST &&
 	    chk_addr_ret != RTN_BROADCAST)
@@ -523,13 +564,18 @@ int inet_bind(struct socket *sock, struc
 	if (sk->sk_state != TCP_CLOSE || inet->num)
 		goto out_release_sock;
 
-	inet->rcv_saddr = inet->saddr = addr->sin_addr.s_addr;
+	inet->rcv_saddr = inet->saddr = s_addr1;
+	inet->rcv_saddr2 = s_addr2;
+	sk->sk_ip_info = get_ip_info(ip_info);
+
 	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
 		inet->saddr = 0;  /* Use device */
 
 	/* Make sure we are allowed to bind here. */
 	if (sk->sk_prot->get_port(sk, snum)) {
 		inet->saddr = inet->rcv_saddr = 0;
+		sk->sk_ip_info = NULL;
+		put_ip_info(ip_info);
 		err = -EADDRINUSE;
 		goto out_release_sock;
 	}
diff -NurpP --minimal linux-2.6.0/net/ipv4/devinet.c linux-2.6.0-vs0.04/net/ipv4/devinet.c
--- linux-2.6.0/net/ipv4/devinet.c	Thu Dec 18 03:58:28 2003
+++ linux-2.6.0-vs0.04/net/ipv4/devinet.c	Sun Jan  4 20:10:04 2004
@@ -487,6 +487,33 @@ static __inline__ int inet_abc_len(u32 a
   	return rc;
 }
 
+/*
+	Check that a device is not member of the ipv4root assigned to the process
+	Return true if this is the case
+
+	If the process is not bound to specific IP, then it returns 0 (all
+	interface are fine).
+*/
+static int devinet_notiproot (struct in_ifaddr *ifa)
+{
+	int ret = 0;
+	struct ip_info *info = current->ip_info;
+
+	if (info && !vx_check(0, VX_ADMIN)) {
+		int i;
+		int nbip = info->nbipv4;
+		__u32 addr = ifa->ifa_local;
+		ret = 1;
+		for (i=0; i<nbip; i++) {
+			if(info->ipv4[i] == addr) {
+				ret = 0;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
 
 int devinet_ioctl(unsigned int cmd, void *arg)
 {
@@ -594,6 +621,8 @@ int devinet_ioctl(unsigned int cmd, void
 	ret = -EADDRNOTAVAIL;
 	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)
 		goto done;
+	if (ifa != NULL && devinet_notiproot(ifa))
+		goto done;
 
 	switch(cmd) {
 	case SIOCGIFADDR:	/* Get interface address */
@@ -723,6 +752,8 @@ static int inet_gifconf(struct net_devic
 		goto out;
 
 	for (; ifa; ifa = ifa->ifa_next) {
+		if (devinet_notiproot(ifa))
+			continue;
 		if (!buf) {
 			done += sizeof(ifr);
 			continue;
@@ -980,6 +1011,8 @@ static int inet_dump_ifaddr(struct sk_bu
 		read_lock(&in_dev->lock);
 		for (ifa = in_dev->ifa_list, ip_idx = 0; ifa;
 		     ifa = ifa->ifa_next, ip_idx++) {
+			if (devinet_notiproot(ifa))
+				continue;
 			if (ip_idx < s_ip_idx)
 				continue;
 			if (inet_fill_ifaddr(skb, ifa, NETLINK_CB(cb->skb).pid,
diff -NurpP --minimal linux-2.6.0/net/ipv4/raw.c linux-2.6.0-vs0.04/net/ipv4/raw.c
--- linux-2.6.0/net/ipv4/raw.c	Thu Dec 18 03:58:57 2003
+++ linux-2.6.0-vs0.04/net/ipv4/raw.c	Sun Jan  4 20:10:04 2004
@@ -102,6 +102,38 @@ static void raw_v4_unhash(struct sock *s
 	write_unlock_bh(&raw_v4_lock);
 }
 
+
+/*
+	Check if an address is in the list
+*/
+static inline int raw_addr_in_list (
+	u32 rcv_saddr1,
+	u32 rcv_saddr2,
+	u32 loc_addr,
+	struct ip_info *ip_info)
+{
+	int ret = 0;
+	if (loc_addr != 0 &&
+		(rcv_saddr1 == loc_addr || rcv_saddr2 == loc_addr))
+		ret = 1;
+	else if (rcv_saddr1 == 0) {
+		/* Accept any address or only the one in the list */
+		if (ip_info == NULL)
+			ret = 1;
+		else {
+			int n = ip_info->nbipv4;
+			int i;
+			for (i=0; i<n; i++) {
+				if (ip_info->ipv4[i] == loc_addr) {
+					ret = 1;
+					break;
+				}
+			}
+		}
+	}
+	return ret;
+}
+
 struct sock *__raw_v4_lookup(struct sock *sk, unsigned short num,
 			     unsigned long raddr, unsigned long laddr,
 			     int dif)
@@ -113,7 +145,8 @@ struct sock *__raw_v4_lookup(struct sock
 
 		if (inet->num == num 					&&
 		    !(inet->daddr && inet->daddr != raddr) 		&&
-		    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
+		    raw_addr_in_list(inet->rcv_saddr, inet->rcv_saddr2,
+			laddr, sk->sk_ip_info) &&
 		    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
 			goto found; /* gotcha */
 	}
@@ -698,7 +731,8 @@ static struct sock *raw_get_first(struct
 		struct hlist_node *node;
 
 		sk_for_each(sk, node, &raw_v4_htable[state->bucket])
-			if (sk->sk_family == PF_INET)
+			if (sk->sk_family == PF_INET &&
+				vx_check(sk->sk_xid, VX_WATCH|VX_IDENT))
 				goto found;
 	}
 	sk = NULL;
diff -NurpP --minimal linux-2.6.0/net/ipv4/tcp_ipv4.c linux-2.6.0-vs0.04/net/ipv4/tcp_ipv4.c
--- linux-2.6.0/net/ipv4/tcp_ipv4.c	Tue Dec 30 09:56:23 2003
+++ linux-2.6.0-vs0.04/net/ipv4/tcp_ipv4.c	Sun Jan  4 20:39:26 2004
@@ -179,9 +179,52 @@ void tcp_bind_hash(struct sock *sk, stru
 	tcp_sk(sk)->bind_hash = tb;
 }
 
+/*
+	Return 1 if addr match the socket IP list
+	or the socket is INADDR_ANY
+*/
+static inline int tcp_in_list (struct sock *sk, u32 addr)
+{
+	struct ip_info *ip_info = sk->sk_ip_info;
+
+	if (ip_info) {
+		int n = ip_info->nbipv4;
+		int i;
+
+		for (i=0; i<n; i++)
+			if (ip_info->ipv4[i] == addr)
+				return 1;
+	}
+	else if (!tcp_v4_rcv_saddr(sk) || tcp_v4_rcv_saddr(sk) == addr)
+		return 1;
+	return 0;
+}
+	
+/*
+	Check if the addresses in sk1 conflict with those in sk2
+*/
+int tcp_ipv4_addr_conflict (struct sock *sk1, struct sock *sk2)
+{
+	if (tcp_v4_rcv_saddr(sk1)) {
+		/* Bind to one address only */
+		return tcp_in_list (sk2, tcp_v4_rcv_saddr(sk1));
+	} else if (sk1->sk_ip_info) {
+		/* A restricted bind(any) */
+		struct ip_info *ip_info = sk1->sk_ip_info;
+		int n = ip_info->nbipv4;
+		int i;
+
+		for (i=0; i<n; i++)
+			if (tcp_in_list (sk2, ip_info->ipv4[i]))
+				return 1;
+	} else	/* A bind(any) do not allow other bind on the same port */
+		return 1;
+	return 0;
+}
+
 static inline int tcp_bind_conflict(struct sock *sk, struct tcp_bind_bucket *tb)
 {
-	const u32 sk_rcv_saddr = tcp_v4_rcv_saddr(sk);
+//	const u32 sk_rcv_saddr = tcp_v4_rcv_saddr(sk);
 	struct sock *sk2;
 	struct hlist_node *node;
 	int reuse = sk->sk_reuse;
@@ -194,9 +237,8 @@ static inline int tcp_bind_conflict(stru
 		     sk->sk_bound_dev_if == sk2->sk_bound_dev_if)) {
 			if (!reuse || !sk2->sk_reuse ||
 			    sk2->sk_state == TCP_LISTEN) {
-				const u32 sk2_rcv_saddr = tcp_v4_rcv_saddr(sk2);
-				if (!sk2_rcv_saddr || !sk_rcv_saddr ||
-				    sk2_rcv_saddr == sk_rcv_saddr)
+//				const u32 sk2_rcv_saddr = tcp_v4_rcv_saddr(sk2);
+				if (tcp_ipv4_addr_conflict(sk, sk2))
 					break;
 			}
 		}
@@ -405,6 +447,34 @@ void tcp_unhash(struct sock *sk)
 		wake_up(&tcp_lhash_wait);
 }
 
+/*
+	Check if an address is in the list
+*/
+static inline int tcp_addr_in_list (
+	u32 rcv_saddr,
+	u32 daddr,
+	struct ip_info *ip_info)
+{
+	if (rcv_saddr == daddr)
+		return 1;
+	else if (rcv_saddr == 0) {
+		/* Accept any address or check the list */
+		if (!ip_info)
+			return 1;
+		else {
+			int n = ip_info->nbipv4;
+			int i;
+
+			for (i=0; i<n; i++)
+				if (ip_info->ipv4[i] == daddr)
+					return 1;
+		}
+	}
+	return 0;
+}
+
+
+
 /* Don't inline this cruft.  Here are some nice properties to
  * exploit here.  The BSD API does not allow a listening TCP
  * to specify the remote port nor the remote address for the
@@ -426,11 +496,10 @@ static struct sock *__tcp_v4_lookup_list
 			__u32 rcv_saddr = inet->rcv_saddr;
 
 			score = (sk->sk_family == PF_INET ? 1 : 0);
-			if (rcv_saddr) {
-				if (rcv_saddr != daddr)
-					continue;
+			if (tcp_addr_in_list(rcv_saddr, daddr, sk->sk_ip_info))
 				score+=2;
-			}
+			else
+				continue;
 			if (sk->sk_bound_dev_if) {
 				if (sk->sk_bound_dev_if != dif)
 					continue;
@@ -460,8 +529,8 @@ inline struct sock *tcp_v4_lookup_listen
 		struct inet_opt *inet = inet_sk((sk = __sk_head(head)));
 
 		if (inet->num == hnum && !sk->sk_node.next &&
-		    (!inet->rcv_saddr || inet->rcv_saddr == daddr) &&
 		    (sk->sk_family == PF_INET || !ipv6_only_sock(sk)) &&
+		    tcp_addr_in_list(inet->rcv_saddr, daddr, sk->sk_ip_info) &&
 		    !sk->sk_bound_dev_if)
 			goto sherry_cache;
 		sk = __tcp_v4_lookup_listener(head, daddr, hnum, dif);
diff -NurpP --minimal linux-2.6.0/net/ipv4/tcp_minisocks.c linux-2.6.0-vs0.04/net/ipv4/tcp_minisocks.c
--- linux-2.6.0/net/ipv4/tcp_minisocks.c	Thu Dec 18 03:59:17 2003
+++ linux-2.6.0-vs0.04/net/ipv4/tcp_minisocks.c	Sun Jan  4 20:10:04 2004
@@ -362,6 +362,9 @@ void tcp_time_wait(struct sock *sk, int 
 		tw->tw_ts_recent_stamp	= tp->ts_recent_stamp;
 		tw_dead_node_init(tw);
 
+		tw->tw_xid		= sk->sk_xid;
+		tw->tw_ip_info		= NULL;
+		
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 		if (tw->tw_family == PF_INET6) {
 			struct ipv6_pinfo *np = inet6_sk(sk);
@@ -686,6 +689,7 @@ struct sock *tcp_create_openreq_child(st
 		struct sk_filter *filter;
 
 		memcpy(newsk, sk, sizeof(struct tcp_sock));
+		newsk->sk_ip_info = get_ip_info(sk->sk_ip_info);
 		newsk->sk_state = TCP_SYN_RECV;
 
 		/* SANITY */
diff -NurpP --minimal linux-2.6.0/net/ipv4/udp.c linux-2.6.0-vs0.04/net/ipv4/udp.c
--- linux-2.6.0/net/ipv4/udp.c	Thu Dec 18 03:58:16 2003
+++ linux-2.6.0-vs0.04/net/ipv4/udp.c	Sun Jan  4 20:10:04 2004
@@ -120,6 +120,9 @@ rwlock_t udp_hash_lock = RW_LOCK_UNLOCKE
 /* Shared by v4/v6 udp. */
 int udp_port_rover;
 
+int tcp_ipv4_addr_conflict (struct sock *sk1, struct sock *sk2);
+
+
 static int udp_v4_get_port(struct sock *sk, unsigned short snum)
 {
 	struct hlist_node *node;
@@ -179,9 +182,7 @@ gotit:
 			    (!sk2->sk_bound_dev_if ||
 			     !sk->sk_bound_dev_if ||
 			     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&
-			    (!inet2->rcv_saddr ||
-			     !inet->rcv_saddr ||
-			     inet2->rcv_saddr == inet->rcv_saddr) &&
+			    tcp_ipv4_addr_conflict(sk2, sk) &&
 			    (!sk2->sk_reuse || !sk->sk_reuse))
 				goto fail;
 		}
@@ -216,6 +217,17 @@ static void udp_v4_unhash(struct sock *s
 	write_unlock_bh(&udp_hash_lock);
 }
 
+static int udp_in_list (struct ip_info *ip_info, u32 addr)
+{
+	int n = ip_info->nbipv4;
+	int i;
+
+	for (i=0; i<n; i++)
+		if (ip_info->ipv4[i] == addr)
+			return 1;
+	return 0;
+}
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -235,6 +247,11 @@ struct sock *udp_v4_lookup_longway(u32 s
 				if (inet->rcv_saddr != daddr)
 					continue;
 				score+=2;
+			} else if (sk->sk_ip_info) {
+				if (udp_in_list(sk->sk_ip_info, daddr))
+					score+=2;
+				else
+					continue;
 			}
 			if (inet->daddr) {
 				if (inet->daddr != saddr)
@@ -290,7 +307,8 @@ static inline struct sock *udp_v4_mcast_
 		if (inet->num != hnum					||
 		    (inet->daddr && inet->daddr != rmt_addr)		||
 		    (inet->dport != rmt_port && inet->dport)		||
-		    (inet->rcv_saddr && inet->rcv_saddr != loc_addr)	||
+		    (inet->rcv_saddr && inet->rcv_saddr != loc_addr &&
+		     inet->rcv_saddr2 && inet->rcv_saddr2 != loc_addr)	||
 		    ipv6_only_sock(s)					||
 		    (s->sk_bound_dev_if && s->sk_bound_dev_if != dif))
 			continue;
@@ -610,6 +628,18 @@ int udp_sendmsg(struct kiocb *iocb, stru
 				    .uli_u = { .ports =
 					       { .sport = inet->sport,
 						 .dport = dport } } };
+               struct ip_info *ip_info = current->ip_info;
+
+               if (ip_info != NULL) {
+                       __u32 ipv4root = ip_info->ipv4[0];
+                       if (ipv4root) {
+                               if (daddr == 0x0100007f &&
+                                       !vx_check(0, VX_ADMIN))
+                                       daddr = ipv4root;
+                               if (fl.nl_u.ip4_u.saddr == 0)
+                                       fl.nl_u.ip4_u.saddr = ipv4root;
+                       }
+               }
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
 			goto out;
diff -NurpP --minimal linux-2.6.0/net/unix/af_unix.c linux-2.6.0-vs0.04/net/unix/af_unix.c
--- linux-2.6.0/net/unix/af_unix.c	Thu Dec 18 03:59:05 2003
+++ linux-2.6.0-vs0.04/net/unix/af_unix.c	Sun Jan  4 20:10:04 2004
@@ -120,6 +120,7 @@
 #include <linux/mount.h>
 #include <net/checksum.h>
 #include <linux/security.h>
+#include <linux/vinline.h>
 
 int sysctl_unix_max_dgram_qlen = 10;
 
@@ -480,6 +481,7 @@ static struct sock * unix_create1(struct
 	sock_init_data(sock,sk);
 	sk_set_owner(sk, THIS_MODULE);
 
+	sk->sk_xid = vx_current_id();
 	sk->sk_write_space	= unix_write_space;
 	sk->sk_max_ack_backlog	= sysctl_unix_max_dgram_qlen;
 	sk->sk_destruct		= unix_sock_destructor;
